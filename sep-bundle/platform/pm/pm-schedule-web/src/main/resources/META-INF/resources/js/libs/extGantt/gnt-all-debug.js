/*

Ext Gantt 2.2.15
Copyright(c) 2009-2013 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.locale.Locale

Base locale class. You need to subclass it, when creating new locales for Bryntum components. Usually subclasses of this class
will be singletones.

See <a href="#!/guide/gantt_scheduler_localization">Localization guide</a> for additional details.

*/
Ext.define('Sch.locale.Locale', {

    /**
     * @cfg {Object} l10n An object with the keys corresponding to class names and values are in turn objects with "phraseName/phraseTranslation"
     * key/values. For example:
     *
    l10n        : {
        'Sch.plugin.EventEditor' : {
            saveText: 'Speichern',
            deleteText: 'LÃ¶schen',
            cancelText: 'Abbrechen'
        },
        'Sch.plugin.CurrentTimeLine' : {
            tooltipText : 'Aktuelle Zeit'
        },

        ...
    }

     */
    l10n            : null,

    legacyMode      : true,
    
    localeName      : null,
    namespaceId     : null,
    

    constructor     : function () {
        if (!Sch.locale.Active) {
            Sch.locale.Active = {};
            this.bindRequire();
        }

        var name            = this.self.getName().split('.');
        var localeName      = this.localeName = name.pop();
        this.namespaceId    = name.join('.');

        var currentLocale   = Sch.locale.Active[ this.namespaceId ];
        
        // let's localize all the classes that are loaded
        // except the cases when English locale is being applied over some non-english locale
        if (!(localeName == 'En' && currentLocale && currentLocale.localeName != 'En')) this.apply();
    },

    bindRequire : function () {
        // OVERRIDE
        // we need central hook to localize class once it's been created
        // to achieve it we override Ext.ClassManager.triggerCreated
        var _triggerCreated = Ext.ClassManager.triggerCreated;

        Ext.ClassManager.triggerCreated = function(className) {
            _triggerCreated.apply(this, arguments);

            var cls     = Ext.ClassManager.get(className);
            // trying to apply locales for the loaded class
            for (var namespaceId in Sch.locale.Active) {
                Sch.locale.Active[namespaceId].apply(cls);
            }
        };
    },

    /**
     * Apply this locale to classes.
     * @param {String[]/Object[]} [classNames] Array of class names (or classes themself) to localize.
     * If no classes specified then will localize all exisiting classes.
     */
    apply       : function (classNames) {
        if (this.l10n) {
            var me              = this, i, l;
            var localeId        = this.self.getName();

            var applyToClass    = function (clsName, cls) {
                cls = cls || Ext.ClassManager.get(clsName);

                if (cls && (cls.activeLocaleId !== localeId)) {
                    var locale = me.l10n[clsName];

                    // if it's procedural localization - run provided callback
                    if (typeof locale === 'function') {
                        locale(clsName);

                    // if it's singleton - apply to it
                    } else if (cls.singleton) {
                        cls.l10n = Ext.apply(cls.l10n || {}, locale);

                    // otherwise we override class
                    } else {
                        Ext.override(cls, { l10n : locale });
                    }

                    // if we support old locales approach let's duplicate locale to old places
                    if (me.legacyMode) {
                        var target;

                        // we update either class prototype
                        if (cls.prototype) {
                            target = cls.prototype;
                        // or object itself in case of singleton
                        } else if (cls.singleton) {
                            target = cls;
                        }

                        if (target) {

                            if (target.legacyHolderProp) {
                                if (!target[target.legacyHolderProp]) target[target.legacyHolderProp] = {};

                                target = target[target.legacyHolderProp];
                            }

                            for (var p in locale) {
                                if (typeof target[p] !== 'function') target[p] = locale[p];
                            }
                        }
                    }

                    // keep applied locale
                    cls.activeLocaleId  = localeId;

                    // for singletons we can have some postprocessing
                    if (cls.onLocalized) cls.onLocalized();
                }
            };

            // if class name is specified
            if (classNames) {
                if (!Ext.isArray(classNames)) classNames = [classNames];

                var name, cls;
                for (i = 0, l = classNames.length; i < l; i++) {
                    if (Ext.isObject(classNames[i])) {
                        if (classNames[i].singleton) {
                            cls     = classNames[i];
                            name    = Ext.getClassName(Ext.getClass(cls));
                        } else {
                            cls     = Ext.getClass(classNames[i]);
                            name    = Ext.getClassName(cls);
                        }
                    } else {
                        cls     = null;
                        name    = 'string' === typeof classNames[i] ? classNames[i] : Ext.getClassName(classNames[i]);
                    }

                    if (name && name in this.l10n) {
                        applyToClass(name, cls);
                    }
                }

            // localize all the classes that we know about
            } else {
                // update active locales
                Sch.locale.Active[this.namespaceId] = this;

                for (var clsName in this.l10n) {
                    applyToClass(clsName);
                }
            }
        }
    }
});

/**
 * English translations for the Scheduler component
 *
 * NOTE: To change locale for month/day names you have to use the corresponding Ext JS language file.
 */
Ext.define('Sch.locale.En', {
    extend      : 'Sch.locale.Locale',
    singleton   : true,

    l10n        : {
        'Sch.util.Date' : {
            unitNames : {
                YEAR        : { single : 'year',    plural : 'years',   abbrev : 'yr' },
                QUARTER     : { single : 'quarter', plural : 'quarters',abbrev : 'q' },
                MONTH       : { single : 'month',   plural : 'months',  abbrev : 'mon' },
                WEEK        : { single : 'week',    plural : 'weeks',   abbrev : 'w' },
                DAY         : { single : 'day',     plural : 'days',    abbrev : 'd' },
                HOUR        : { single : 'hour',    plural : 'hours',   abbrev : 'h' },
                MINUTE      : { single : 'minute',  plural : 'minutes', abbrev : 'min' },
                SECOND      : { single : 'second',  plural : 'seconds', abbrev : 's' },
                MILLI       : { single : 'ms',      plural : 'ms',      abbrev : 'ms' }
            }
        },
        
        'Sch.view.SchedulerGridView' : {
            loadingText : 'Loading events...'
        },

        'Sch.plugin.CurrentTimeLine' : {
            tooltipText : 'Current time'
        },

        'Sch.plugin.EventEditor' : {
            saveText    : 'Save',
            deleteText  : 'Delete',
            cancelText  : 'Cancel'
        },

        'Sch.plugin.SimpleEditor' : {
            newEventText    : 'New booking...'
        },

        'Sch.widget.ExportDialog' : {
            generalError                : 'An error occured, try again.',
            title                       : 'Export Settings',
            formatFieldLabel            : 'Paper format',
            orientationFieldLabel       : 'Orientation',
            rangeFieldLabel             : 'Export range',
            showHeaderLabel             : 'Add page number',
            orientationPortraitText     : 'Portrait',
            orientationLandscapeText    : 'Landscape',
            completeViewText            : 'Complete schedule',
            currentViewText             : 'Current view',
            dateRangeText               : 'Date range',
            dateRangeFromText           : 'Export from',
            pickerText                  : 'Resize column/rows to desired value',
            dateRangeToText             : 'Export to',
            exportButtonText            : 'Export',
            cancelButtonText            : 'Cancel',
            progressBarText             : 'Exporting...',
            exportToSingleLabel         : 'Export as single page',
            adjustCols                  : 'Adjust column width',
            adjustColsAndRows           : 'Adjust column width and row height',
            specifyDateRange            : 'Specify date range'
        },

        // -------------- View preset date formats/strings -------------------------------------
        'Sch.preset.Manager' : function () {
            var M = Sch.preset.Manager,
                vp = M.getPreset("hourAndDay");

            if (vp) {
                vp.displayDateFormat = 'G:iA';
                vp.headerConfig.middle.dateFormat = 'G:iA';
                vp.headerConfig.top.dateFormat = 'D d/m';
            }
            
            vp = M.getPreset("secondAndMinute");
            if (vp) {
                vp.displayDateFormat = 'g:i:s';
                vp.headerConfig.top.dateFormat = 'D, d g:iA';
            }
            

            vp = M.getPreset("dayAndWeek");
            if (vp) {
                vp.displayDateFormat = 'm/d h:i A';
                vp.headerConfig.middle.dateFormat = 'D d M';
            }

            vp = M.getPreset("weekAndDay");
            if (vp) {
                vp.displayDateFormat = 'm/d';
                vp.headerConfig.bottom.dateFormat = 'd M';
                vp.headerConfig.middle.dateFormat = 'Y F d';
            }

            vp = M.getPreset("weekAndMonth");
            if (vp) {
                vp.displayDateFormat = 'm/d/Y';
                vp.headerConfig.middle.dateFormat = 'm/d';
                vp.headerConfig.top.dateFormat = 'm/d/Y';
            }

            vp = M.getPreset("weekAndDayLetter");
            if (vp) {
                vp.displayDateFormat = 'm/d/Y';
                vp.headerConfig.middle.dateFormat = 'D d M Y';
            }

            vp = M.getPreset("weekDateAndMonth");
            if (vp) {
                vp.displayDateFormat = 'm/d/Y';
                vp.headerConfig.middle.dateFormat = 'd';
                vp.headerConfig.top.dateFormat = 'Y F';
            }

            vp = M.getPreset("monthAndYear");
            if (vp) {
                vp.displayDateFormat = 'm/d/Y';
                vp.headerConfig.middle.dateFormat = 'M Y';
                vp.headerConfig.top.dateFormat = 'Y';
            }

            vp = M.getPreset("year");
            if (vp) {
                vp.displayDateFormat = 'm/d/Y';
                vp.headerConfig.middle.dateFormat = 'Y';
            }

            vp = M.getPreset("manyYears");
            if (vp) {
                vp.displayDateFormat = 'm/d/Y';
                vp.headerConfig.middle.dateFormat = 'Y';
            }
        }
    }
});

/**
 * @class Sch.util.Patch
 * @static
 * @private
 * Private utility class for Ext JS patches for the Bryntum components
 */
Ext.define('Sch.util.Patch', {
    /**
     * @cfg {String} target The class name to override
     */
    target      : null,

    /**
     * @cfg {String} minVersion The minimum Ext JS version for which this override is applicable. E.g. "4.0.5"
     */
    minVersion  : null,
    
    /**
     * @cfg {String} maxVersion The minimum Ext JS version for which this override is applicable. E.g. "4.0.7"
     */
    maxVersion  : null,

    /**
     * @cfg {String} reportUrl A url to the forum post describing the bug/issue in greater detail
     */
    reportUrl   : null,
    
    /**
     * @cfg {String} description A brief description of why this override is required
     */
    description : null,
    
    /**
     * @cfg {Function} applyFn A function that will apply the patch(es) manually, instead of using 'overrides';
     */
    applyFn : null,

    /**
     * @cfg {Boolean} ieOnly true if patch is only applicable to IE
     */
    ieOnly : false,

    /**
     * @cfg {Object} overrides a custom object containing the methods to be overridden.
     */
    overrides : null,

    onClassExtended: function(cls, data) {
        
        if (Sch.disableOverrides) {
            return;
        }

        if (data.ieOnly && !Ext.isIE) {
            return;
        }

        if ((!data.minVersion || Ext.versions.extjs.equals(data.minVersion) || Ext.versions.extjs.isGreaterThan(data.minVersion)) &&
            (!data.maxVersion || Ext.versions.extjs.equals(data.maxVersion) || Ext.versions.extjs.isLessThan(data.maxVersion))) {
            if (data.applyFn) {
                // Custom override, implementor has full control
                data.applyFn();
            } else {
                // Simple case, just an Ext override
                Ext.ClassManager.get(data.target).override(data.overrides);
            }
        }
    }
});

//@PATCH to fix http://www.sencha.com/forum/showthread.php?261753-4.2-Drag-drop-bug-with-ScrollManager&p=959144#post959144
Ext.define('Sch.patches.ElementScroll', {
    override      : 'Sch.mixin.TimelineView',

    _onAfterRender : function() {
        this.callParent(arguments);

        if (Ext.versions.extjs.isLessThan('4.2.1') || Ext.versions.extjs.isGreaterThan('4.2.2')) return;

        this.el.scroll = function(direction, distance, animate) {
            if (!this.isScrollable()) {
                return false;
            }
            direction = direction.substr(0, 1);
            var me = this,
                dom = me.dom,
                side = direction === 'r' || direction === 'l' ? 'left' : 'top',
                scrolled = false,
                currentScroll, constrainedScroll;

            if (direction === 'r' || direction === 't' || direction === 'u') {
                distance = -distance;
            }

            if (side === 'left') {
                currentScroll = dom.scrollLeft;
                constrainedScroll = me.constrainScrollLeft(currentScroll + distance);
            } else {
                currentScroll = dom.scrollTop;
                constrainedScroll = me.constrainScrollTop(currentScroll + distance);
            }

            if (constrainedScroll !== currentScroll) {
                this.scrollTo(side, constrainedScroll, animate);
                scrolled = true;
            }

            return scrolled;
        };
    }
});

//@PATCH to fix https://www.assembla.com/spaces/bryntum/tickets/869#/activity/ticket
// When resizing columns with fixed locked grid width, columns become smaller due to the default Ext header resizing logic
Ext.define('Sch.patches.ColumnResize', {
    override      : 'Sch.panel.TimelineGridPanel',

    afterRender : function() {
        this.callParent(arguments);

        var resizer = this.lockedGrid.headerCt.findPlugin('gridheaderresizer');

        if (resizer) {
            // Implementation from Ext 4.2.0
            resizer.getConstrainRegion = function() {
                var me       = this,
                    dragHdEl = me.dragHd.el,
                    nextHd;



                if (me.headerCt.forceFit) {
                    nextHd = me.dragHd.nextNode('gridcolumn:not([hidden]):not([isGroupHeader])');
                    if (!me.headerInSameGrid(nextHd)) {
                        nextHd = null;
                    }
                }

                return me.adjustConstrainRegion(
                    Ext.util.Region.getRegion(dragHdEl),
                    0,
                    me.headerCt.forceFit ? (nextHd ? nextHd.getWidth() - me.minColWidth : 0) : me.maxColWidth - dragHdEl.getWidth(),
                    0,
                    me.minColWidth
                );
            };
        }
    }
});

//@PATCH to fix https://www.assembla.com/spaces/bryntum/tickets/869#/activity/ticket
// When resizing columns with fixed locked grid width, columns become smaller due to the default Ext header resizing logic
Ext.define('Sch.patches.ColumnResizeTree', {
    override      : 'Sch.panel.TimelineTreePanel',

    afterRender : function() {
        this.callParent(arguments);

        var resizer = this.lockedGrid.headerCt.findPlugin('gridheaderresizer');

        if (resizer) {
            // Implementation from Ext 4.2.0
            resizer.getConstrainRegion = function() {
                var me       = this,
                    dragHdEl = me.dragHd.el,
                    nextHd;



                if (me.headerCt.forceFit) {
                    nextHd = me.dragHd.nextNode('gridcolumn:not([hidden]):not([isGroupHeader])');
                    if (!me.headerInSameGrid(nextHd)) {
                        nextHd = null;
                    }
                }

                return me.adjustConstrainRegion(
                    Ext.util.Region.getRegion(dragHdEl),
                    0,
                    me.headerCt.forceFit ? (nextHd ? nextHd.getWidth() - me.minColWidth : 0) : me.maxColWidth - dragHdEl.getWidth(),
                    0,
                    me.minColWidth
                );
            };
        }
    }
});

/**
@class Sch.mixin.Localizable

A mixin providing localization functionality to the consuming class.

    Ext.define('My.Toolbar', {
        extend      : 'Ext.Toolbar',
        mixins      : [ 'Sch.mixin.Localizable' ],

        initComponent   : function () {
            Ext.apply(this, {
                items   : [
                    {
                        xtype       : 'button',

                        // get the button label from the current locale
                        text        : this.L('loginText')
                    }
                ]
            });

            this.callParent(arguments);
        }
    });

*/
Ext.define('Sch.mixin.Localizable', {

    // This line used to be like this:
    //      if Sch.config.locale is specified then we'll require corresponding class
    //      by default we require Sch.locale.En class
//          requires            : [ typeof Sch != 'undefined' && Sch.config && Sch.config.locale || 'Sch.locale.En' ],
    //
    // But, SenchaCMD does not support dynamic expressions for `requires`
    // Falling back to requiring English locale - that will cause English locale to always be included in the build
    // (even if user has specified another locale in other `requires`), but thats better than requiring users
    // to always specify and load the locale they need explicitly
    requires            : [ 'Sch.locale.En' ],

    legacyMode          : true,

    activeLocaleId      : '',

    /**
     * @cfg {Object} l10n Container of locales for the class.
     */
    l10n                : null,

    isLocaleApplied     : function () {
        var activeLocaleId = (this.singleton && this.activeLocaleId) || this.self.activeLocaleId;

        if (!activeLocaleId) return false;

        for (var ns in Sch.locale.Active) {
            if (activeLocaleId === Sch.locale.Active[ns].self.getName()) return true;
        }

        return false;
    },

    applyLocale         : function () {
        // loop over activated locale classes and call apply() method of each one
        for (var ns in Sch.locale.Active) {
            Sch.locale.Active[ns].apply(this.singleton ? this : this.self.getName());
        }
    },

    /**
     * This is shorthand reference to {@link #localize}. Retrieves translation of a phrase.
     * @param {String} id Identifier of phrase.
     * @param {String} [legacyHolderProp=this.legacyHolderProp] Legacy class property name containing locales.
     * @param {Boolean} [skipLocalizedCheck=false] Do not localize class if it's not localized yet.
     * @return {String} Translation of specified phrase.
     */
    L                   : function () {
        return this.localize.apply(this, arguments);
    },

    /**
     * Retrieves translation of a phrase. There is a shorthand {@link #L} for this method.
     * @param {String} id Identifier of phrase.
     * @param {String} [legacyHolderProp=this.legacyHolderProp] Legacy class property name containing locales.
     * @param {Boolean} [skipLocalizedCheck=false] Do not localize class if it's not localized yet.
     * @return {String} Translation of specified phrase.
     */
    localize            : function (id, legacyHolderProp, skipLocalizedCheck) {
        // if not localized yet let's do it
        if (!this.isLocaleApplied() && !skipLocalizedCheck) {
            this.applyLocale();
        }

        // `l10n` instance property has highest priority
        if (this.hasOwnProperty('l10n') && this.l10n.hasOwnProperty(id) && 'function' != typeof this.l10n[id]) return this.l10n[id];

        var clsProto    = this.self && this.self.prototype;

        // if there was old properties for locales on this class
        if (this.legacyMode) {
            // if they were kept under some property
            var prop        = legacyHolderProp || this.legacyHolderProp;

            // check object instance first
            var instHolder  = prop ? this[prop] : this;
            if (instHolder && instHolder.hasOwnProperty(id) && 'function' != typeof instHolder[id]) return instHolder[id];

            if (clsProto) {
                // then let's check class definition
                var clsHolder = prop ? clsProto[prop] : clsProto;
                if (clsHolder && clsHolder.hasOwnProperty(id) && 'function' != typeof clsHolder[id]) return clsHolder[id];
            }
        }

        // let's try to get locale from class prototype `l10n` property
        var result      = clsProto.l10n[id];

        // if no transalation found
        if (result === null || result === undefined) {

            var superClass  = clsProto && clsProto.superclass;
            // if parent class also has localize() method
            if (superClass && superClass.localize) {
                // try to get phrase translation from parent class
                result = superClass.localize(id, legacyHolderProp, skipLocalizedCheck);
            }

            if (result === null || result === undefined) throw 'Cannot find locale: '+id+' ['+this.self.getName()+']';
        }

        return result;
    }
});

/**
 * @class Sch.util.Date
 * @static
 * Static utility class for Date manipulation
 */
Ext.define('Sch.util.Date', {
    requires        : 'Ext.Date',
    mixins          : ['Sch.mixin.Localizable'],
    singleton       : true,

    // These stem from Ext.Date in Ext JS but since they don't exist in Sencha Touch we'll need to keep them here
    stripEscapeRe   : /(\\.)/g,
    hourInfoRe      : /([gGhHisucUOPZ]|MS)/,

    unitHash        : null,
    unitsByName     : {},

    // Override this to localize the time unit names.
    //unitNames   : {
        //YEAR    : { single : 'year', plural : 'years', abbrev : 'yr' },
        //QUARTER : { single : 'quarter', plural : 'quarters', abbrev : 'q' },
        //MONTH   : { single : 'month', plural : 'months', abbrev : 'mon' },
        //WEEK    : { single : 'week', plural : 'weeks', abbrev : 'w' },
        //DAY     : { single : 'day', plural : 'days', abbrev : 'd' },
        //HOUR    : { single : 'hour', plural : 'hours', abbrev : 'h' },
        //MINUTE  : { single : 'minute', plural : 'minutes', abbrev : 'min' },
        //SECOND  : { single : 'second', plural : 'seconds', abbrev : 's' },
        //MILLI   : { single : 'ms', plural : 'ms', abbrev : 'ms' }
    //},


    constructor : function () {
        var ED = Ext.Date;
        var unitHash = this.unitHash = {
            /**
             * Date interval constant
             * @static
             * @type String
             */
            MILLI : ED.MILLI,

            /**
             * Date interval constant
             * @static
             * @type String
             */
            SECOND : ED.SECOND,

            /**
             * Date interval constant
             * @static
             * @type String
             */
            MINUTE : ED.MINUTE,

            /** Date interval constant
             * @static
             * @type String
             */
            HOUR : ED.HOUR,

            /**
             * Date interval constant
             * @static
             * @type String
             */
            DAY : ED.DAY,

            /**
             * Date interval constant
             * @static
             * @type String
             */
            WEEK : "w",

            /**
             * Date interval constant
             * @static
             * @type String
             */
            MONTH : ED.MONTH,

            /**
             * Date interval constant
             * @static
             * @type String
             */
            QUARTER : "q",

            /**
             * Date interval constant
             * @static
             * @type String
             */
            YEAR : ED.YEAR
        };
        Ext.apply(this, unitHash);

        var me = this;
        this.units = [me.MILLI, me.SECOND, me.MINUTE, me.HOUR, me.DAY, me.WEEK, me.MONTH, me.QUARTER, me.YEAR];
    },


    onLocalized : function () {
        this.setUnitNames(this.L('unitNames'));
    },


    /**
     * Call this method to provide your own, localized values for duration unit names. See the "/js/Sch/locale/sch-lang-*.js" files for examples
     *
     * @param {Object} unitNames
     */
    setUnitNames : function (unitNames, preserveLocales) {
        var unitsByName = this.unitsByName = {};

        this.l10n.unitNames = unitNames;

        this._unitNames     = Ext.apply({}, unitNames);

        var unitHash        = this.unitHash;

        // Make it possible to lookup readable date names from both 'DAY' and 'd' etc.
        for (var name in unitHash) {
            if (unitHash.hasOwnProperty(name)) {
                var unitValue = unitHash[name];

                this._unitNames[ unitValue ] = this._unitNames[name];

                unitsByName[ name ] = unitValue;
                unitsByName[ unitValue ] = unitValue;
            }
        }
    },


    /**
     * Checks if this date is >= start and < end.
     * @param {Date} date The source date
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Boolean} true if this date falls on or between the given start and end dates.
     * @static
     */
    betweenLesser : function (date, start, end) {
        var t = date.getTime();
        return start.getTime() <= t && t < end.getTime();
    },

    /**
     * Constrains the date within a min and a max date
     * @param {Date} date The date to constrain
     * @param {Date} min Min date
     * @param {Date} max Max date
     * @return {Date} The constrained date
     * @static
     */
    constrain : function (date, min, max) {
        return this.min(this.max(date, min), max);
    },

    /**
     * Returns 1 if first param is a greater unit than second param, -1 if the opposite is true or 0 if they're equal
     * @static
     *
     * @param {String} unit1 The 1st unit
     * @param {String} unit2 The 2nd unit
     */
    compareUnits : function (u1, u2) {
        var ind1 = Ext.Array.indexOf(this.units, u1),
            ind2 = Ext.Array.indexOf(this.units, u2);

        return ind1 > ind2 ? 1 : (ind1 < ind2 ? -1 : 0);
    },

    /**
     * Returns true if first unit passed is strictly greater than the second.
     * @static
     *
     * @param {String} unit1 The 1st unit
     * @param {String} unit2 The 2nd unit
     */
    isUnitGreater : function (u1, u2) {
        return this.compareUnits(u1, u2) > 0;
    },

    /**
     * Copies hours, minutes, seconds, milliseconds from one date to another
     * @static
     *
     * @param {String} targetDate The target date
     * @param {String} sourceDate The source date
     */
    copyTimeValues : function (targetDate, sourceDate) {
        targetDate.setHours(sourceDate.getHours());
        targetDate.setMinutes(sourceDate.getMinutes());
        targetDate.setSeconds(sourceDate.getSeconds());
        targetDate.setMilliseconds(sourceDate.getMilliseconds());
    },

    /**
     * Adds a date unit and interval
     * @param {Date} date The source date
     * @param {String} unit The date unit to add
     * @param {Int} value The number of units to add to the date
     * @return {Date} The new date
     * @static
     */
    add : function (date, unit, value) {
        var d = Ext.Date.clone(date);
        if (!unit || value === 0) return d;

        switch (unit.toLowerCase()) {
            case this.MILLI:
                d = new Date(date.getTime() + value);
                break;
            case this.SECOND:
                d = new Date(date.getTime() + (value * 1000));
                break;
            case this.MINUTE:
                d = new Date(date.getTime() + (value * 60000));
                break;
            case this.HOUR:
                d = new Date(date.getTime() + (value * 3600000));
                break;
            case this.DAY:
                d.setDate(date.getDate() + value);
                break;
            case this.WEEK:
                d.setDate(date.getDate() + value * 7);
                break;
            case this.MONTH:
                var day = date.getDate();
                if (day > 28) {
                    day = Math.min(day, Ext.Date.getLastDateOfMonth(this.add(Ext.Date.getFirstDateOfMonth(date), this.MONTH, value)).getDate());
                }
                d.setDate(day);
                d.setMonth(d.getMonth() + value);
                break;
            case this.QUARTER:
                d = this.add(date, this.MONTH, value * 3);
                break;
            case this.YEAR:
                d.setFullYear(date.getFullYear() + value);
                break;
        }
        return d;
    },


    getMeasuringUnit : function (unit) {
        if (unit === this.WEEK) {
            return this.DAY;
        }
        return unit;
    },


    /**
     * Returns a duration of the timeframe in the given unit.
     * @static
     * @param {Date} start The start date of the timeframe
     * @param {Date} end The end date of the timeframe
     * @param {String} unit Duration unit
     * @return {Number} The duration in the units
     */
    getDurationInUnit : function (start, end, unit) {
        var units;

        switch (unit) {
            case this.YEAR:
                units = Math.round(this.getDurationInYears(start, end));
                break;

            case this.QUARTER:
                units = Math.round(this.getDurationInMonths(start, end) / 3);
                break;

            case this.MONTH:
                units = Math.round(this.getDurationInMonths(start, end));
                break;

            case this.WEEK:
                units = Math.round(this.getDurationInDays(start, end)) / 7;
                break;

            case this.DAY:
                units = Math.round(this.getDurationInDays(start, end));
                break;

            case this.HOUR:
                units = Math.round(this.getDurationInHours(start, end));
                break;

            case this.MINUTE:
                units = Math.round(this.getDurationInMinutes(start, end));
                break;

            case this.SECOND:
                units = Math.round(this.getDurationInSeconds(start, end));
                break;

            case this.MILLI:
                units = Math.round(this.getDurationInMilliseconds(start, end));
                break;
        }

        return units;
    },


    getUnitToBaseUnitRatio : function (baseUnit, unit) {
        if (baseUnit === unit) {
            return 1;
        }

        switch (baseUnit) {
            case this.YEAR:
                switch (unit) {
                    case this.QUARTER:
                        return 1 / 4;

                    case this.MONTH:
                        return 1 / 12;
                }
                break;

            case this.QUARTER:
                switch (unit) {
                    case this.YEAR:
                        return 4;

                    case this.MONTH:
                        return 1 / 3;
                }
                break;

            case this.MONTH:
                switch (unit) {
                    case this.YEAR:
                        return 12;

                    case this.QUARTER:
                        return 3;
                }
                break;

            case this.WEEK:
                switch (unit) {
                    case this.DAY:
                        return 1 / 7;

                    case this.HOUR:
                        return 1 / 168;
                }
                break;

            case this.DAY:
                switch (unit) {
                    case this.WEEK:
                        return 7;

                    case this.HOUR:
                        return 1 / 24;

                    case this.MINUTE:
                        return 1 / 1440;
                }
                break;

            case this.HOUR:
                switch (unit) {
                    case this.DAY:
                        return 24;

                    case this.MINUTE:
                        return 1 / 60;
                }
                break;

            case this.MINUTE:
                switch (unit) {
                    case this.HOUR:
                        return 60;

                    case this.SECOND:
                        return 1 / 60;

                    case this.MILLI:
                        return 1 / 60000;
                }
                break;

            case this.SECOND:
                switch (unit) {
                    case this.MILLI:
                        return 1 / 1000;
                }
                break;


            case this.MILLI:
                switch (unit) {
                    case this.SECOND:
                        return 1000;
                }
                break;

        }

        return -1;
    },

    /**
     * Returns the number of milliseconds between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Int} true number of minutes between the two dates
     * @static
     */
    getDurationInMilliseconds : function (start, end) {
        return (end - start);
    },

    /**
     * Returns the number of seconds between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Int} The number of seconds between the two dates
     * @static
     */
    getDurationInSeconds : function (start, end) {
        return (end - start) / 1000;
    },

    /**
     * Returns the number of minutes between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Int} true number of minutes between the two dates
     * @static
     */
    getDurationInMinutes : function (start, end) {
        return (end - start) / 60000;
    },

    /**
     * Returns the number of hours between the two dates.
     *
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Int} true number of hours between the two dates
     * @static
     */
    getDurationInHours : function (start, end) {
        return (end - start) / 3600000;
    },

    /**
     * Simplistic method which returns the number of days between the two dates. Assumes a day has 24 hours and does not take DST into account.
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Int} true number of days between the two dates
     * @static
     */
    getDurationInDays : function (start, end) {
        return (end - start) / 86400000;
    },

    /**
     * Returns the number of business days between the two dates
     * @deprecated Will be removed in v3.0. Use Calendar instead to find duration for a period of time, excluding non-working time.
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Int} true number of business days between the two dates
     * @static
     */
    getDurationInBusinessDays : function (start, end) {
        var nbrDays = Math.round((end - start) / 86400000),
            nbrBusinessDays = 0,
            d;

        for (var i = 0; i < nbrDays; i++) {
            d = this.add(start, this.DAY, i).getDay();
            if (d !== 6 && d !== 0) {
                nbrBusinessDays++;
            }
        }
        return nbrBusinessDays;
    },

    /**
     * Returns the number of whole months between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Int} The number of whole months between the two dates
     * @static
     */
    getDurationInMonths : function (start, end) {
        return ((end.getFullYear() - start.getFullYear()) * 12) + (end.getMonth() - start.getMonth());
    },

    /**
     * Returns the number of years between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Int} The number of whole months between the two dates
     * @static
     */
    getDurationInYears : function (start, end) {
        return this.getDurationInMonths(start, end) / 12;
    },

    /**
     * Returns the lesser of the two dates
     * @param {Date} date 1
     * @param {Date} date 2
     * @return {Date} Returns the lesser of the two dates
     * @static
     */
    min : function (d1, d2) {
        return d1 < d2 ? d1 : d2;
    },

    /**
     * Returns the greater of the two dates
     * @param {Date} date 1
     * @param {Date} date 2
     * @return {Date} Returns the greater of the two dates
     * @static
     */
    max : function (d1, d2) {
        return d1 > d2 ? d1 : d2;
    },

    /**
     * Returns true if dates intersect
     * @param {Date} start 1
     * @param {Date} end 1
     * @param {Date} start 2
     * @param {Date} end 2
     * @return {Boolean} Returns true if dates intersect
     * @static
     */
    intersectSpans : function (date1Start, date1End, date2Start, date2End) {
        return this.betweenLesser(date1Start, date2Start, date2End) ||
            this.betweenLesser(date2Start, date1Start, date1End);
    },

    /**
     * Returns a name of the duration unit, matching its property on the Sch.util.Date class.
     * So, for example:
     *
     *      Sch.util.Date.getNameOfUnit(Sch.util.Date.DAY) == 'DAY' // true
     *
     * @static
     * @param {String} unit Duration unit
     * @return {String}
     */
    getNameOfUnit : function (unit) {
        unit = this.getUnitByName(unit);

        switch (unit.toLowerCase()) {
            case this.YEAR      :
                return 'YEAR';
            case this.QUARTER   :
                return 'QUARTER';
            case this.MONTH     :
                return 'MONTH';
            case this.WEEK      :
                return 'WEEK';
            case this.DAY       :
                return 'DAY';
            case this.HOUR      :
                return 'HOUR';
            case this.MINUTE    :
                return 'MINUTE';
            case this.SECOND    :
                return 'SECOND';
            case this.MILLI     :
                return 'MILLI';
        }

        throw "Incorrect UnitName";
    },

    /**
     * Returns a human-readable name of the duration unit. For for example for `Sch.util.Date.DAY` it will return either
     * "day" or "days", depending from the `plural` argument
     * @static
     * @param {String} unit Duration unit
     * @param {Boolean} plural Whether to return a plural name or singular
     * @return {String}
     */
    getReadableNameOfUnit : function (unit, plural) {
        if (!this.isLocaleApplied()) this.applyLocale();
        return this._unitNames[ unit ][ plural ? 'plural' : 'single' ];
    },

    /**
     * Returns an abbreviated form of the name of the duration unit.
     * @static
     * @param {String} unit Duration unit
     * @return {String}
     */
    getShortNameOfUnit : function (unit) {
        if (!this.isLocaleApplied()) this.applyLocale();
        return this._unitNames[ unit ].abbrev;
    },

    getUnitByName : function (name) {
        if (!this.isLocaleApplied()) this.applyLocale();

        if (!this.unitsByName[ name ]) {
            Ext.Error.raise('Unknown unit name: ' + name);
        }

        return this.unitsByName[ name ];
    },


    /**
     * Returns the beginning of the Nth next duration unit, after the provided `date`.
     * For example for the this call:
     *      Sch.util.Date.getNext(new Date('Jul 15, 2011'), Sch.util.Date.MONTH, 1)
     *
     * will return: Aug 1, 2011
     *
     * @static
     * @param {Date} date The date
     * @param {String} unit The duration unit
     * @param {Integer} increment How many duration units to skip
     * @param {Number} weekStartDay The day index of the 1st day of the week.
     *                Only required when `unit` is `WEEK`. 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on (defaults to 1).
     * @return {Date} The beginning of the next duration unit interval
     */
    getNext : function (date, unit, increment, weekStartDay) {
        var dt = Ext.Date.clone(date);

        weekStartDay = arguments.length < 4 ? 1 : weekStartDay;
        increment = increment || 1;

        switch (unit) {
            case this.MILLI:
                dt = this.add(date, unit, increment);
                break;

            case this.SECOND:
                dt = this.add(date, unit, increment);

                if (dt.getMilliseconds() > 0) {
                    dt.setMilliseconds(0);
                }
                break;

            case this.MINUTE:
                dt = this.add(date, unit, increment);

                if (dt.getSeconds() > 0) {
                    dt.setSeconds(0);
                }
                if (dt.getMilliseconds() > 0) {
                    dt.setMilliseconds(0);
                }
                break;

            case this.HOUR:
                dt = this.add(date, unit, increment);

                // Without these checks Firefox messes up the date and it changes timezone in certain edge cases
                // See test 021_sch_util_date_dst.t.js
                if (dt.getMinutes() > 0) {
                    dt.setMinutes(0);
                }
                if (dt.getSeconds() > 0) {
                    dt.setSeconds(0);
                }
                if (dt.getMilliseconds() > 0) {
                    dt.setMilliseconds(0);
                }
                break;

            case this.DAY:
                // Check if date has 23 hrs and is in Chile timezone
                var midnightNotInTimeScale = date.getHours() === 23 && this.add(dt, this.HOUR, 1).getHours() === 1;

                if (midnightNotInTimeScale) {
                    // Correct the date manually for DST transitions happening at 00:00
                    dt = this.add(dt, this.DAY, 2);
                    Ext.Date.clearTime(dt);
                    return dt;
                }

                Ext.Date.clearTime(dt);

                dt = this.add(dt, this.DAY, increment);
                break;

            case this.WEEK:

                Ext.Date.clearTime(dt);
                var day = dt.getDay();
                dt = this.add(dt, this.DAY, weekStartDay - day + 7 * (increment - (weekStartDay <= day ? 0 : 1)));

                // For south american timezones, midnight does not exist on DST transitions, adjust...
                if (dt.getDay() !== weekStartDay) {
                    dt = this.add(dt, this.HOUR, 1);
                } else {
                    Ext.Date.clearTime(dt);
                }
                break;

            case this.MONTH:
                dt = this.add(dt, this.MONTH, increment);
                dt.setDate(1);
                Ext.Date.clearTime(dt);
                break;

            case this.QUARTER:
                dt = this.add(dt, this.MONTH, ((increment - 1) * 3) + (3 - (dt.getMonth() % 3)));
                Ext.Date.clearTime(dt);
                dt.setDate(1);
                break;

            case this.YEAR:
                dt = new Date(dt.getFullYear() + increment, 0, 1);
                break;

            default:
                throw 'Invalid date unit';
        }

        return dt;
    },


    getNumberOfMsFromTheStartOfDay : function (date) {
        return date - Ext.Date.clearTime(date, true) || 86400000;
    },


    getNumberOfMsTillTheEndOfDay : function (date) {
        return this.getStartOfNextDay(date, true) - date;
    },


    getStartOfNextDay : function (date, clone, noNeedToClearTime) {
        var nextDay = this.add(noNeedToClearTime ? date : Ext.Date.clearTime(date, clone), this.DAY, 1);

        // DST case
        if (nextDay.getDate() == date.getDate()) {
            var offsetNextDay   = this.add(Ext.Date.clearTime(date, clone), this.DAY, 2).getTimezoneOffset();
            var offsetDate      = date.getTimezoneOffset();

            nextDay             = this.add(nextDay, this.MINUTE, offsetDate - offsetNextDay);
        }

        return nextDay;
    },

    getEndOfPreviousDay : function (date, noNeedToClearTime) {
        var dateOnly = noNeedToClearTime ? date : Ext.Date.clearTime(date, true);

        // dates are different
        if (dateOnly - date) {
            return dateOnly;
        } else {
            return this.add(dateOnly, this.DAY, -1);
        }
    },

    /**
     * Returns true if the first time span completely 'covers' the second time span. E.g.
     *      Sch.util.Date.timeSpanContains(new Date(2010, 1, 2), new Date(2010, 1, 5), new Date(2010, 1, 3), new Date(2010, 1, 4)) ==> true
     *      Sch.util.Date.timeSpanContains(new Date(2010, 1, 2), new Date(2010, 1, 5), new Date(2010, 1, 3), new Date(2010, 1, 6)) ==> false
     * @static
     * @param {Date} spanStart The start date for initial time span
     * @param {Date} spanEnd The end date for initial time span
     * @param {Date} otherSpanStart The start date for the 2nd time span
     * @param {Date} otherSpanEnd The end date for the 2nd time span
     * @return {Boolean}
     */
    timeSpanContains : function (spanStart, spanEnd, otherSpanStart, otherSpanEnd) {
        return (otherSpanStart - spanStart) >= 0 && (spanEnd - otherSpanEnd) >= 0;
    }
});

/**
 * @class Sch.util.DragTracker
 * @private
 * 
 * Simple drag tracker with an extra useful getRegion method
 **/
Ext.define('Sch.util.DragTracker', {
    extend      : 'Ext.dd.DragTracker',
    
    /**
     * @cfg {Number} xStep
     * The number of horizontal pixels to snap to when dragging
     */
    xStep : 1,

    /**
     * @cfg {Number} yStep
     * The number of vertical pixels to snap to when dragging
     */
    yStep : 1,

    /**
     * Set the number of horizontal pixels to snap to when dragging
     * @param {Number} step
     */
    setXStep : function(step) {
        this.xStep = step;
    },

    /**
     * Set the number of vertical pixels to snap to when dragging
     * @param {Number} step
     */
    setYStep : function(step) {
        this.yStep = step;
    },

    getRegion : function() {
        var startXY   = this.startXY,
            currentXY = this.getXY(),
            minX      = Math.min(startXY[0], currentXY[0]),
            minY      = Math.min(startXY[1], currentXY[1]),
            width     = Math.abs(startXY[0] - currentXY[0]),
            height    = Math.abs(startXY[1] - currentXY[1]);
            
        return new Ext.util.Region(minY, minX + width, minY + height, minX);
    },

    // @OVERRIDE
    onMouseDown: function(e, target){
        // If this is disabled, or the mousedown has been processed by an upstream DragTracker, return
        if (this.disabled ||e.dragTracked) {
            return;
        }

        var xy = e.getXY(),
            elX, elY,
            x = xy[0], 
            y = xy[1];
        // TODO handle if this.el is scrolled
        if (this.xStep > 1) {
            elX = this.el.getX();
            x -= elX;
            x = Math.round(x/this.xStep)*this.xStep;
            x += elX;
        }
        
        if (this.yStep > 1) {
            elY = this.el.getY();
            y -= elY;
            y = Math.round(y/this.yStep)*this.yStep;
            y += elY;
        }

        // This information should be available in mousedown listener and onBeforeStart implementations
        this.dragTarget = this.delegate ? target : this.handle.dom;
        this.startXY = this.lastXY = [x, y];
        this.startRegion = Ext.fly(this.dragTarget).getRegion();

        if (this.fireEvent('mousedown', this, e) === false ||
            this.fireEvent('beforedragstart', this, e) === false ||
            this.onBeforeStart(e) === false) {
            return;
        }

        // Track when the mouse is down so that mouseouts while the mouse is down are not processed.
        // The onMouseOut method will only ever be called after mouseup.
        this.mouseIsDown = true;

        // Flag for downstream DragTracker instances that the mouse is being tracked.
        e.dragTracked = true;

        if (this.preventDefault !== false) {
            e.preventDefault();
        }
        Ext.getDoc().on({
            scope: this,
            mouseup: this.onMouseUp,
            mousemove: this.onMouseMove,
            selectstart: this.stopSelect
        });
        if (this.autoStart) {
            this.timer =  Ext.defer(this.triggerStart, this.autoStart === true ? 1000 : this.autoStart, this, [e]);
        }
    },

    // @OVERRIDE
    // Adds support for snapping to increments while dragging
    onMouseMove: function(e, target){

        // Bug fix required for IE
        if (this.active && Ext.isIE && Ext.ieVersion < 10 && !e.browserEvent.button) {
            e.preventDefault();
            this.onMouseUp(e);
            return;
        }

        e.preventDefault();
        var xy = e.getXY(),
            s = this.startXY;
        
        if (!this.active) {
            if (Math.max(Math.abs(s[0]-xy[0]), Math.abs(s[1]-xy[1])) > this.tolerance) {
                this.triggerStart(e);
            } else {
                return;
            }
        }

        var x = xy[0], 
            y = xy[1];
        
        // TODO handle if this.el is scrolled
        if (this.xStep > 1) {
            x -= this.startXY[0];
            x = Math.round(x/this.xStep)*this.xStep;
            x += this.startXY[0];
        }
        
        if (this.yStep > 1) {
            y -= this.startXY[1];
            y = Math.round(y/this.yStep)*this.yStep;
            y += this.startXY[1];
        }

        var snapping = this.xStep > 1 || this.yStep > 1;

        if (!snapping || x !== xy[0] || y !== xy[1]) {
            this.lastXY = [x,y];
        
            if (this.fireEvent('mousemove', this, e) === false) {
                this.onMouseUp(e);
            } else {
                this.onDrag(e);
                this.fireEvent('drag', this, e);
            }
        }
    }
});

/**

@class Sch.model.Customizable
@extends Ext.data.Model

This class represent a model with customizable field names. Customizable fields are defined in separate 
class config `customizableFields`. The format of definition is just the same as for usual fields:

    Ext.define('BaseModel', {
        extend      : 'Sch.model.Customizable',
        
        customizableFields  : [
            { name      : 'StartDate',  type    : 'date', dateFormat : 'c' },
            { name      : 'EndDate',    type    : 'date', dateFormat : 'c' }
        ],
        
        fields              : [
            'UsualField'
        ],
        
        getEndDate : function () {
            return "foo"
        }
    });

For each customizable field will be created getter and setter, using the camel-cased name of the field ("stable name"), 
prepended with "get/set" respectively. They will not overwrite any existing methods:

    var baseModel       = new BaseModel({
        StartDate   : new Date(2012, 1, 1),
        EndDate     : new Date(2012, 2, 3)
    });
    
    // using getter for "StartDate" field
    // returns date for "2012/02/01"
    var startDate   = baseModel.getStartDate();
    
    // using custom getter for "EndDate" field
    // returns "foo"
    var endDate     = baseModel.getEndDate();
    
You can change the name of the customizable fields in the subclasses of the model or completely re-define them. 
For that, add a special property to the class, name of this property should be formed as name of the field with lowercased first
letter, appended with "Field". The value of the property should contain the new name of the field.

    Ext.define('SubModel', {
        extend      : 'BaseModel',
        
        startDateField      : 'beginDate',
        endDateField        : 'finalizeDate',
        
        fields              : [
            { name      : 'beginDate',  type    : 'date', dateFormat : 'Y-m-d' },
        ]
    });
    
    var subModel       = new SubModel({
        beginDate       : new Date(2012, 1, 1),
        finalizeDate    : new Date(2012, 2, 3)
    });
    
    // name of getter is still the same
    var startDate   = subModel.getStartDate();

In the example above the `StartDate` field was completely re-defined to the `beginDate` field with different date format.
The `EndDate` has just changed its name to "finalizeDate". Note, that getters and setters are always named after "stable"
field name, not the customized one.

*/

// Don't redefine the class, which will screw up instanceof checks etc
if (!Ext.ClassManager.get("Sch.model.Customizable")) {

    Ext.define('Sch.model.Customizable', {
        extend      : 'Ext.data.Model',

        // Defined in subclasses, this prevents the default 'id' from being added to the fields collection
        idProperty  : null,

        /**
         * @cfg {Array} customizableFields
         *
         * The array of customizale fields definitions.
         */
        customizableFields      : null,

        // @private
        // Keeps temporary state of the previous state for a model, but is only available
        // when a model has changed, e.g. after 'set' or 'reject'. After those operations are completed, this property is cleared.
        previous                : null,

        onClassExtended : function (cls, data, hooks) {
            var onBeforeCreated = hooks.onBeforeCreated;

            hooks.onBeforeCreated = function (cls, data) {
                onBeforeCreated.call(this, cls, data);

                var proto                   = cls.prototype;

                if (!proto.customizableFields) {
                    return;
                }

                // combining our customizable fields with ones from superclass
                // our fields goes after fields from superclass to overwrite them if some names match
                proto.customizableFields    = (cls.superclass.customizableFields || []).concat(proto.customizableFields);

                var customizableFields      = proto.customizableFields;

                // collect fields here, overwriting old ones with new
                var customizableFieldsByName    = {};

                Ext.Array.each(customizableFields, function (field) {
                    // normalize to object
                    if (typeof field == 'string') field = { name : field };

                    customizableFieldsByName[ field.name ] = field;
                });

                // already processed by the Ext.data.Model `onBeforeCreated`
                var fields                  = proto.fields;

                var toRemove                = [];

                fields.each(function (field) {
                    if (field.isCustomizableField) toRemove.push(field);
                });

                fields.removeAll(toRemove);

                Ext.Object.each(customizableFieldsByName, function (name, customizableField) {
                    // mark all customizable fields with special property, to be able remove them later
                    customizableField.isCustomizableField     = true;

                    var stableFieldName     = customizableField.name || customizableField.getName();

                    var fieldProperty       = stableFieldName === 'Id' ? 'idProperty' : stableFieldName.charAt(0).toLowerCase() + stableFieldName.substr(1) + 'Field';
                    var overrideFieldName   = proto[ fieldProperty ];

                    var realFieldName       = overrideFieldName || stableFieldName;

                    if (fields.containsKey(realFieldName)) {
                        // if user has re-defined some customizable field, mark it accordingly
                        // such fields weren't be inheritable though (won't replace the customizable field)
                        fields.getByKey(realFieldName).isCustomizableField = true;

                        // add it to our customizable fields list on the last position, so in the subclasses
                        // it will overwrite other fields with this name
                        customizableFields.push(
                            new Ext.data.Field(
                                Ext.applyIf({ name : stableFieldName, isCustomizableField : true }, fields.getByKey(realFieldName))
                            )
                        );
                    } else
                        // we create a new copy of the `customizableField` using possibly new name
                        fields.add(new Ext.data.Field(Ext.applyIf({ name : realFieldName, isCustomizableField : true }, customizableField)));

                    var capitalizedStableName  = Ext.String.capitalize(stableFieldName);

                    // don't overwrite `getId` method
                    if (capitalizedStableName != 'Id') {
                        var getter              = 'get' + capitalizedStableName;
                        var setter              = 'set' + capitalizedStableName;

                        // overwrite old getters, pointing to a different field name
                        if (!proto[ getter ] || proto[ getter ].__getterFor__ && proto[ getter ].__getterFor__ != realFieldName) {
                            proto[ getter ] = function () {
                                return this.data[ realFieldName ];
                            };

                            proto[ getter ].__getterFor__   = realFieldName;
                        }

                        // same for setters
                        if (!proto[ setter ] || proto[ setter ].__setterFor__ && proto[ setter ].__setterFor__ != realFieldName) {
                            proto[ setter ] = function (value) {
                                return this.set(realFieldName, value);
                            };

                            proto[ setter ].__setterFor__   = realFieldName;
                        }
                    }
                });
            };
        },

        // Overridden to be able to track previous record field values
        set : function(fieldName, value) {
            var currentValue;
            this.previous = this.previous || {};

            if (arguments.length > 1) {
                currentValue = this.get(fieldName);

                // Store previous field value
                if (currentValue !== value) {
                    this.previous[fieldName] = currentValue;
                }
            } else {
                for (var o in fieldName) {
                    currentValue = this.get(o);

                    // Store previous field value
                    if (currentValue !== fieldName[o]) {
                        this.previous[o] = currentValue;
                    }
                }
            }
            this.callParent(arguments);
        },

        // @OVERRIDE
        // Overridden to be able to clear the previous record field values. Must be done here to have access to the 'previous' object after
        // an endEdit call.
        afterEdit : function() {
            this.callParent(arguments);

            // Reset the previous tracking object
            delete this.previous;
        },

        // Overridden to be able to track previous record field values
        reject : function () {
            var me = this,
                modified = me.modified,
                field;

            me.previous = me.previous || {};
            for (field in modified) {
                if (modified.hasOwnProperty(field)) {
                    if (typeof modified[field] != "function") {
                        me.previous[field] = me.get(field);
                    }
                }
            }
            me.callParent(arguments);

            // Reset the previous tracking object
            delete me.previous;
        }
    });
}

/**
@class Sch.data.mixin.EventStore

This is a mixin, containing functionality related to managing events. 

It is consumed by the regular {@link Sch.data.EventStore} class and {@link Gnt.data.TaskStore} class 
to allow data sharing between gantt chart and scheduler. Please note though, that datasharing is still
an experimental feature and not all methods of this mixin can be used yet on a TaskStore. 

*/
Ext.define("Sch.data.mixin.EventStore", {
    model : 'Sch.model.Event',
    config : { model : 'Sch.model.Event' },

    requires : [
        'Sch.util.Date'
    ],

    isEventStore : true,

    /**
     * Sets the resource store for this store
     * 
     * @param {Sch.data.ResourceStore} resourceStore
     */
    setResourceStore : function (resourceStore) {
        if (this.resourceStore) {
            this.resourceStore.un({
                beforesync  : this.onResourceStoreBeforeSync,
                write       : this.onResourceStoreWrite,
                scope       : this
            });
        }
        
        this.resourceStore    = resourceStore;
        
        if (resourceStore) {
            resourceStore.on({
                beforesync : this.onResourceStoreBeforeSync,
                write      : this.onResourceStoreWrite,
                scope       : this
            });
        }
    },

    onResourceStoreBeforeSync: function (records, options) {
        var recordsToCreate     = records.create;
        
        if (recordsToCreate) {
            for (var r, i = recordsToCreate.length - 1; i >= 0; i--) {
                r = recordsToCreate[i];
                
                // Save the phantom id to be able to replace the task phantom task id's in the dependency store
                r._phantomId = r.internalId;
            }
        }
    },

    /* 
     * This method will update events that belong to a phantom resource, to make sure they get the 'real' resource id
     */
    onResourceStoreWrite: function (store, operation) {
        if (operation.wasSuccessful()) {
            var me = this,
                rs = operation.getRecords();

            Ext.each(rs, function(resource) {
                if (resource._phantomId && !resource.phantom) {
                    me.each(function (event) {
                        if (event.getResourceId() === resource._phantomId) {
                            event.assign(resource);
                        }
                    });
                }
            });
        }
    },

    /**
    * Checks if a date range is allocated or not for a given resource.
    * @param {Date} start The start date
    * @param {Date} end The end date
    * @param {Sch.model.Event} excludeEvent An event to exclude from the check (or null)
    * @param {Sch.model.Resource} resource The resource
    * @return {Boolean} True if the timespan is available for the resource
    */
    isDateRangeAvailable: function (start, end, excludeEvent, resource) {
        var available = true,
            DATE = Sch.util.Date;

        this.forEachScheduledEvent(function (ev, startDate, endDate) {
            if (DATE.intersectSpans(start, end, startDate, endDate) &&
                resource === ev.getResource() && 
                (!excludeEvent || excludeEvent !== ev)) {
                available = false;
                return false;
            }
        });

        return available;
    },

    /**
    * Returns events between the supplied start and end date
    * @param {Date} start The start date
    * @param {Date} end The end date
    * @param {Boolean} allowPartial false to only include events that start and end inside of the span
    * @return {Ext.util.MixedCollection} the events
    */
    getEventsInTimeSpan: function (start, end, allowPartial) {

        if (allowPartial !== false) {
            var DATE = Sch.util.Date;

            return this.queryBy(function (event) {
                var eventStart = event.getStartDate(),
                    eventEnd = event.getEndDate();

                return eventStart && eventEnd && DATE.intersectSpans(eventStart, eventEnd, start, end);
            });
        } else {
            return this.queryBy(function (event) {
                var eventStart = event.getStartDate(),
                    eventEnd = event.getEndDate();

                return eventStart && eventEnd && (eventStart - start >= 0) && (end - eventEnd >= 0);
            });
        }
    },

    /**
     * Calls the supplied iterator function once for every scheduled event, providing these arguments
     *      - event : the event record
     *      - startDate : the event start date
     *      - endDate : the event end date
     *
     * Returning false cancels the iteration.
     *
     * @param {Function} the iterator function
     * @param {Object} the 'this' object to use for the function
     */
    forEachScheduledEvent : function (fn, scope) {

        this.each(function (event) {
            var eventStart = event.getStartDate(),
                eventEnd = event.getEndDate();

            if (eventStart && eventEnd) {
                return fn.call(scope || this, event, eventStart, eventEnd);
            }
        }, this);
    },

    /**
     * Returns an object defining the earliest start date and the latest end date of all the events in the store.
     * 
     * @return {Object} An object with 'start' and 'end' Date properties (or null values if data is missing).
     */
    getTotalTimeSpan : function() {
        var earliest = new Date(9999,0,1), 
            latest = new Date(0), 
            D = Sch.util.Date;
        
        this.each(function(r) {
            if (r.getStartDate()) {
                earliest = D.min(r.getStartDate(), earliest);
            }
            if (r.getEndDate()) {
                latest = D.max(r.getEndDate(), latest);
            }
        });

        earliest = earliest < new Date(9999,0,1) ? earliest : null;
        latest = latest > new Date(0) ? latest : null;

        return {
            start : earliest || null,
            end : latest || earliest || null
        };
    },

    /**
    * Returns the events associated with a resource
    * @param {Sch.model.Resource} resource
    * @return {Sch.model.Event[]} the events
    */
    getEventsForResource: function (resource) {
        var events = [], 
            ev,   
            id = resource.getId() || resource.internalId;
            
        for (var i = 0, l = this.getCount(); i < l; i++) {
            ev = this.getAt(i);
            if (ev.data[ev.resourceIdField] == id) {
                events.push(ev);
            }
        }

        return events;
    },

    // This method provides a way for the store to append a new record, and the consuming class has to implement it
    // since Store and TreeStore don't share the add API.
    append : function(record) {
        throw 'Must be implemented by consuming class';
    },

    // Sencha Touch <-> Ext JS normalization
    getModel : function() {
        return this.model;
    }
});
/**

 @class Sch.model.Range
 @extends Sch.model.Customizable

 This class represent a simple date range. It is being used in various subclasses and plugins which operate on date ranges.

 Its a subclass of the {@link Sch.model.Customizable}, which is in turn subclass of {@link Ext.data.Model}.
 Please refer to documentation of those classes to become familar with the base interface of this class.

 A range has the following fields:

 - `StartDate`   - start date of the task in the ISO 8601 format
 - `EndDate`     - end date of the task in the ISO 8601 format (not inclusive)
 - `Name`        - an optional name of the range
 - `Cls`         - an optional CSS class to be associated with the range.

 The name of any field can be customized in the subclass. Please refer to {@link Sch.model.Customizable} for details.

 */
Ext.define('Sch.model.Range', {
    extend      : 'Sch.model.Customizable',

    requires    : [
        'Sch.util.Date'
    ],

    idProperty  : 'Id',

    // For Sencha Touch
    config : {
        idProperty  : 'Id'
    },

    /**
     * @cfg {String} startDateField The name of the field that defines the range start date. Defaults to "StartDate".
     */
    startDateField  : 'StartDate',

    /**
     * @cfg {String} endDateField The name of the field that defines the range end date. Defaults to "EndDate".
     */
    endDateField    : 'EndDate',

    /**
     * @cfg {String} nameField The name of the field that defines the range name. Defaults to "Name".
     */
    nameField       : 'Name',

    /**
     * @cfg {String} clsField The name of the field that holds the range "class" value (usually corresponds to a CSS class). Defaults to "Cls".
     */
    clsField        : 'Cls',

    customizableFields : [
        /**
         * @method getStartDate
         *
         * Returns the range start date
         *
         * @return {Date} The start date
         */
        { name      : 'StartDate',  type    : 'date', dateFormat : 'c' },

        /**
         * @method getEndDate
         *
         * Returns the range end date
         *
         * @return {Date} The end date
         */
        { name      : 'EndDate',    type    : 'date', dateFormat : 'c' },

        /**
         * @method getCls
         *
         * Gets the "class" of the range
         *
         * @return {String} cls The "class" of the range
         */
        /**
         * @method setCls
         *
         * Sets the "class" of the range
         *
         * @param {String} cls The new class of the range
         */
        {
            name            : 'Cls', type    : 'string'
        },

        /**
         * @method getName
         *
         * Gets the name of the range
         *
         * @return {String} name The "name" of the range
         */
        /**
         * @method setName
         *
         * Sets the "name" of the range
         *
         * @param {String} name The new name of the range
         */
        {
            name            : 'Name', type    : 'string'
        }
    ],

    /**
     * @method setStartDate
     *
     * Sets the range start date
     *
     * @param {Date} date The new start date
     * @param {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the event), `false` to change the duration ("resize" the event).
     * Defaults to `false`
     */
    setStartDate : function(date, keepDuration) {
        var endDate = this.getEndDate();
        var oldStart = this.getStartDate();

        this.set(this.startDateField, date);

        if (keepDuration === true && endDate && oldStart) {
            this.setEndDate(Sch.util.Date.add(date, Sch.util.Date.MILLI, endDate - oldStart));
        }
    },

    /**
     * @method setEndDate
     *
     * Sets the range end date
     *
     * @param {Date} date The new end date
     * @param {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the event), `false` to change the duration ("resize" the event).
     * Defaults to `false`
     */
    setEndDate : function(date, keepDuration) {
        var startDate = this.getStartDate();
        var oldEnd = this.getEndDate();

        this.set(this.endDateField, date);

        if (keepDuration === true && startDate && oldEnd) {
            this.setStartDate(Sch.util.Date.add(date, Sch.util.Date.MILLI, -(oldEnd - startDate)));
        }
    },

    /**
     * Sets the event start and end dates
     *
     * @param {Date} start The new start date
     * @param {Date} end The new end date
     */
    setStartEndDate : function(start, end) {
        // wrap with "begineEdit/endEdit" unless already wrapped from outside code
        var needToWrap  = !this.editing; 
        
        needToWrap && this.beginEdit();
        this.set(this.startDateField, start);
        this.set(this.endDateField, end);
        needToWrap && this.endEdit();
    },

    /**
     * Returns an array of dates in this range. If the range starts/ends not at the beginning of day, the whole day will be included.
     * @return {Array[Date]}
     */
    getDates : function () {
        var dates   = [],
            endDate = this.getEndDate();

        for (var date = Ext.Date.clearTime(this.getStartDate(), true); date < endDate; date = Sch.util.Date.add(date, Sch.util.Date.DAY, 1)) {

            dates.push(date);
        }

        return dates;
    },


    /**
     * Iterates over the results from {@link #getDates}
     * @param {Function} func The function to call for each date
     * @param {Object} scope The scope to use for the function call
     */
    forEachDate : function (func, scope) {
        return Ext.each(this.getDates(), func, scope);
    },

    // Simple check if end date is greater than start date
    isValid : function() {
        var valid = this.callParent(arguments);

        if (valid) {
            var start = this.getStartDate(),
                end = this.getEndDate();

            valid = !start || !end || (end - start >= 0);
        }

        return valid;
    },

    /**
     * Shift the dates for the date range by the passed amount and unit
     * @param {String} unit The unit to shift by (e.g. range.shift(Sch.util.Date.DAY, 2); ) to bump the range 2 days forward
     * @param {Int} amount The amount to shift
     */
    shift : function(unit, amount) {
        this.setStartEndDate(
            Sch.util.Date.add(this.getStartDate(), unit, amount),
            Sch.util.Date.add(this.getEndDate(), unit, amount)
        );
    }
});
/*
 * @class Sch.model.TimeAxisTick
 * @extends Sch.model.Range
 *
 * A simple model with a start/end date interval defining a 'tick' on the time axis.
 */
Ext.define('Sch.model.TimeAxisTick', {
    extend          : 'Sch.model.Range',

    startDateField  : 'start',
    endDateField    : 'end'
});

/**

 @class Sch.model.Resource
 @extends Sch.model.Customizable

 This class represent a single Resource in the scheduler chart. Its a subclass of the {@link Sch.model.Customizable}, which is in turn subclass of {@link Ext.data.Model}.
 Please refer to documentation of those classes to become familar with the base interface of the resource.

 A Resource has only 2 mandatory fields - `Id` and `Name`. If you want to add more fields with meta data describing your resources then you should subclass this class:

 Ext.define('MyProject.model.Resource', {
        extend      : 'Sch.model.Resource',
        
        fields      : [
            // `Id` and `Name` fields are already provided by the superclass
            { name: 'Company',          type : 'string' }
        ],
        
        getCompany : function () {
            return this.get('Company');
        },
        ...
    });

 If you want to use other names for the Id and Name fields you can configure them as seen below:

 Ext.define('MyProject.model.Resource', {
        extend      : 'Sch.model.Resource',
        
        nameField   : 'UserName',
        ...
    });

 Please refer to {@link Sch.model.Customizable} for details.

 */

// Don't redefine the class, which will screw up instanceof checks etc
if (!Ext.ClassManager.get("Sch.model.Resource")) {

    Ext.define('Sch.model.Resource', {
        extend : 'Sch.model.Customizable',

        idProperty : 'Id',
        config     : { idProperty : 'Id' },

        /**
         * @cfg {String} nameField The name of the field that holds the resource name. Defaults to "Name".
         */
        nameField : 'Name',

        customizableFields : [
            'Id',

        /**
         * @method getName
         *
         * Returns the resource name
         *
         * @return {String} The name of the resource
         */
        /**
         * @method setName
         *
         * Sets the resource name
         *
         * @param {String} The new name of the resource
         */
            { name : 'Name', type : 'string' }
        ],

        getEventStore : function () {
            return this.stores[0] && this.stores[0].eventStore || this.parentNode && this.parentNode.getEventStore();
        },


        /**
         * Returns an array of events, associated with this resource
         * @param {Sch.data.EventStore} eventStore (optional) The event store to get events for (if a resource is bound to multiple stores)
         * @return {Array[Sch.model.Event]}
         */
        getEvents : function (eventStore) {
            var events = [],
                ev,
                id = this.getId() || this.internalId;

            eventStore = eventStore || this.getEventStore();

            for (var i = 0, l = eventStore.getCount(); i < l; i++) {
                ev = eventStore.getAt(i);
                if (ev.data[ev.resourceIdField] === id) {
                    events.push(ev);
                }
            }

            return events;
        }
    });
}
/**
 * @class Sch.data.mixin.ResourceStore
 * This is a mixin for the ResourceStore functionality. It is consumed by the {@link Sch.data.ResourceStore} class ("usual" store) and {@link Sch.data.ResourceTreeStore} - tree store.
 * 
 */
Ext.define("Sch.data.mixin.ResourceStore", {

    // Sencha Touch <-> Ext JS normalization
    getModel : function() {
        return this.model;
    }
});
Ext.define("Sch.data.FilterableNodeStore", {
    extend          : 'Ext.data.NodeStore',
    
    // @OVERRIDE
    onNodeExpand : function (parent, records, suppressEvent) {
        var visibleRecords      = [];
        
        for (var i = 0; i < records.length; i++) {
            var record      = records[ i ];
            
            if (!(record.isHidden && record.isHidden() || record.hidden || record.data.hidden)) visibleRecords[ visibleRecords.length ] = record;
        }
        
        return this.callParent([ parent, visibleRecords, suppressEvent ]);
    },
    
    
    onNodeCollapse: function (parent, records, suppressEvent, callback, scope) {
        var data                = this.data;
        var prevContains        = data.contains;
        
        data.contains           = function () {
            for (var i = 0; i < records.length; i++) 
                if (!records[ i ].hidden && prevContains.call(this, records[ i ])) return true;
            
            return false;
        };
        
        this.callParent(arguments);
        
        data.contains           = prevContains;
    }
});
/**
@class Sch.data.mixin.FilterableTreeStore

This is a mixin for the Ext.data.TreeStore providing filtering functionality. Please note, that Ext JS does not support filtering of tree stores,
and the functionality of this mixin is not related to the standard Ext JS store filtering (which utilizes Ext.util.Filter etc). This implementation should however be flexible
enough to cover all common uses cases.

The functionality of this class can be divided into two sections:

Filtering
=========

Filtering of a tree store is different from filtering flat stores. In a flat store, all nodes (items) are of the same type and on the same hieararchy level.
Filtering can hide any of nodes that does not match some criteria.

On the other hand, in tree stores some of the nodes represent parent nodes with child nodes ("parent", "folder", "group" etc) and other nodes are "leaves".
And usually a "leaf" node can't be sufficiently identified w/o its parents - i.e. it is important to know the parents a particular leaf node belongs to. So when filtering
tree stores, we need to show all parent nodes of the filtered nodes.

Moreover, filtering is usually being used for searching and thus should ignore the "expanded/collapsed" state of tree nodes (we need to search among all nodes,
including collapsed ones). Because of that and the underlying Ext JS implementation **expanding/collapsing/adding/removing nodes when the tree store is filtered is not supported.** This limitation
could be removed in future releases.

Filtering can be activated with the {@link #filterTreeBy} method and cleared with {@link #clearTreeFilter}.

Hiding/Showing nodes
====================

Sometimes we want to keep some nodes in the tree, but remove them from the visual presentation and hide them. This can be done with {@link #hideNodesBy} method and {@link #showAllNodes} can be
used to restore the previous state. When a node is hidden all its child nodes are hidden too.

"Hidden" nodes will never appear in filtered results - consider them removed from the tree store completely. They will, however, appear in a data package for a `store.sync()` operation
(you can override the the "filterUpdated" method to exclude them from there if needed).

Note, that it is possible to filter the store with hidden nodes, but not the other way around (hide some nodes of the filtered store).

*/
Ext.define("Sch.data.mixin.FilterableTreeStore", {
    
    requires : [
        'Sch.data.FilterableNodeStore'
    ],
    
    
    nodeStoreClassName      : 'Sch.data.FilterableNodeStore',
    
    nodeStore               : null,
    
    isFilteredFlag          : false,

    // ref to the last filter applied
    lastTreeFilter          : null,
    
    /**
     * Should be called in the constructor of the consuming class, to activate the filtering functionality.
     */
    initTreeFiltering : function () {
        if (!this.nodeStore) this.nodeStore = this.createNodeStore(this);
        
        this.addEvents(
            'filter-set',
            'filter-clear',
            'nodestore-datachange-start',
            'nodestore-datachange-end'
        );
    },
    
    
    createNodeStore : function (treeStore) {
        return Ext.create(this.nodeStoreClassName, {
            treeStore       : treeStore,
            recursive       : true,
            rootVisible     : this.rootVisible
        });
    },
    
    
    /**
     * Clears current filter (if any).
     * 
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     */
    clearTreeFilter : function () {
        if (!this.isTreeFiltered()) return;
        
        this.refreshNodeStoreContent();
        
        this.isFilteredFlag     = false;
        this.lastTreeFilter     = null;
        this.fireEvent('filter-clear', this);
    },
    
    
    refreshNodeStoreContent : function (skipUIRefresh) {
        var root            = this.getRootNode(),
            linearNodes     = [];
            
        var rootVisible     = this.rootVisible;
        
        var collectNodes    = function (node) {
            if (node.isHidden && node.isHidden() || node.hidden || node.data.hidden) return;
            
            if (rootVisible || node != root) linearNodes[ linearNodes.length ] = node;
            
            if (!node.data.leaf && node.isExpanded()) {
                var childNodes  = node.childNodes,
                    length      = childNodes.length;
                
                for (var k = 0; k < length; k++) collectNodes(childNodes[ k ]);
            }
        };
        
        collectNodes(root);
        
        this.fireEvent('nodestore-datachange-start', this);
        
        var nodeStore       = this.nodeStore;
        
        // "loadDataInNodeStore" is a special hook for buffered case
        // in buffered case, instead of "loadRecords" we need to use "cachePage"
        if (!this.loadDataInNodeStore || !this.loadDataInNodeStore(linearNodes)) nodeStore.loadRecords(linearNodes);
        
        // HACK - forcing view to refresh, the usual "refresh" event is blocked by the tree view (see `blockRefresh` property)
        if (!skipUIRefresh) nodeStore.fireEvent('clear', nodeStore);
        
        this.fireEvent('nodestore-datachange-end', this);
    },
    
    
    getIndexInTotalDataset : function (record) {
        var root            = this.getRootNode(),
            index           = -1;
            
        var rootVisible     = this.rootVisible;
        
        if (!rootVisible && record == root) return -1;
        
        var collectNodes    = function (node) {
            if (node.isHidden && node.isHidden() || node.hidden || node.data.hidden)
                // stop scanning if record we are looking for is hidden
                if (node == record) return false;
            
            if (rootVisible || node != root) index++;
                
            // stop scanning if we found the record
            if (node == record) return false;
            
            if (!node.data.leaf && node.isExpanded()) {
                var childNodes  = node.childNodes,
                    length      = childNodes.length;
                
                for (var k = 0; k < length; k++) 
                    if (collectNodes(childNodes[ k ]) === false) return false;
            }
        };
        
        collectNodes(root);
        
        return index;
    },
    
    
    
    /**
     * Returns the boolean, indicating whether this store is currently filtered
     * 
     * @return {Boolean}
     */
    isTreeFiltered : function () {
        return this.isFilteredFlag;
    },    
    
    
    /**
     * This method filters the tree store. It accepts an object with the following properties:
     * 
     * - `filter` - a function to check if the node should be included in the result. It will be called for each **leaf** node in tree and will receive the current node as the first argument.
     * It should return `true` if the node should remain visible, `false` otherwise. The result will also contain all parents nodes of all matching leafs. Results will not include
     * parent nodes, which do not have at least one matching child.
     * To call this method for parent nodes too, pass an additional parameter - `checkParents` (see below).
     * - `scope` - a scope to call the filter with (optional)
     * - `checkParents` - when set to `true` will also call the `filter` function for each parent node. If the function returns `false` for some parent node,
     * it still could be included in filter results if some of its children matches the `filter` (see also "shallow" option below). If the function returns `true` for a parent node, it will be
     * included in the filtering results even if it does not have any matching child nodes. 
     * - `shallow` - implies `checkParents`. When set to `true`, it will stop checking child nodes if the `filter` function return `false` for a parent node. The whole sub-tree, starting
     * from a non-matching parent, will be excluded from the result in such case.
     * - `onlyParents` - alternative for `checkParents`. When set to `true` it will only call the provided `filter` function for parent tasks. If
     * the filter returns `true`, the parent and all its direct child leaf nodes will be included in the results. If the `filter` returns `false`, a parent node still can
     * be included in the results (w/o direct children leafs), if some of its child nodes matches the filter.
     * - `fullMatchingParents` - implies `onlyParents`. In this mode, if a parent node matches the filter, then not only its direct children
     * will be included in the results, but the whole sub-tree, starting from the matching node.
     * 
     * Repeated calls to this method will clear previous filters.
     * 
     * This function can be also called with 2 arguments, which should be the `filter` function and `scope` in such case.
     * 
     * For example:

    treeStore.filterTreeBy({
        filter          : function (node) { return node.get('name').match(/some regexp/) },
        checkParents    : true
    })
    
    // or, if you don't need to set any options:
    treeStore.filterTreeBy(function (node) { return node.get('name').match(/some regexp/) })

     * 
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     * 
     * @param {Object} params
     */
    filterTreeBy : function (params, scope) {
        var filter;
        
        if (arguments.length == 1 && Ext.isObject(arguments[ 0 ])) {
            scope       = params.scope;
            filter      = params.filter;
        } else {
            filter      = params;
            params      = { filter : filter };
        }
        
        this.fireEvent('nodestore-datachange-start', this);
        
        params                      = params || {};
        
        var shallowScan             = params.shallow;
        var checkParents            = params.checkParents || shallowScan;
        var fullMathchingParents    = params.fullMathchingParents;
        var onlyParents             = params.onlyParents || fullMathchingParents;
        var rootVisible             = this.rootVisible;
        
        if (onlyParents && checkParents) throw new Error("Can't combine `onlyParents` and `checkParents` options");
        
        var keepTheseParents    = {};
        
        var root                = this.getRootNode(),
            linearNodes         = [];
        
        var includeParentNodesInResults = function (node) {
            var parent  = node.parentNode;
            
            while (parent && !keepTheseParents[ parent.internalId ]) {
                keepTheseParents[ parent.internalId ] = true;
                
                parent = parent.parentNode;
            }
        };
        
        var collectNodes    = function (node) {
            if (node.isHidden && node.isHidden() || node.hidden || node.data.hidden) return;
            
            var nodeMatches, childNodes, length, k;
            
            // `collectNodes` should not be called for leafs at all
            if (node.data.leaf) {
                if (filter.call(scope, node, keepTheseParents)) {
                    linearNodes[ linearNodes.length ] = node;
                    
                    includeParentNodesInResults(node);
                }
            } else {
                // include _all_ parent nodes in intermediate result set originally, except the root one
                // intermediate result set will be filtered
                if (rootVisible || node != root) linearNodes[ linearNodes.length ] = node;
                
                if (onlyParents) {
                    nodeMatches     = filter.call(scope, node);

                    childNodes      = node.childNodes;
                    length          = childNodes.length;
                        
                    if (nodeMatches) {
                        keepTheseParents[ node.internalId ] = true;
                        
                        includeParentNodesInResults(node);
                        
                        if (fullMathchingParents) {
                            node.cascadeBy(function (currentNode) {
                                if (currentNode != node) {
                                    linearNodes[ linearNodes.length ] = currentNode;
                                    
                                    if (!currentNode.data.leaf) keepTheseParents[ currentNode.internalId ] = true;
                                }
                            });
                            
                            return;
                        }
                    }
                    
                    // at this point nodeMatches and fullMathchingParents can't be both true
                    for (k = 0; k < length; k++)
                        if (nodeMatches && childNodes[ k ].data.leaf) 
                            linearNodes[ linearNodes.length ] = childNodes[ k ];
                        else if (!childNodes[ k ].data.leaf)
                            collectNodes(childNodes[ k ]);
                        
                } else {
                    // mark matching nodes to be kept in results
                    if (checkParents) {
                        nodeMatches = filter.call(scope, node, keepTheseParents);
                        
                        if (nodeMatches) {
                            keepTheseParents[ node.internalId ] = true;
                            
                            includeParentNodesInResults(node);
                        }
                    }
                    
                    // recurse if
                    // - we don't check parents
                    // - shallow scan is not enabled
                    // - shallow scan is enabled and parent node matches the filter or it does not, but its and invisible root, so we don't care
                    if (!checkParents || !shallowScan || shallowScan && (nodeMatches || node == root && !rootVisible)) {
                        childNodes      = node.childNodes;
                        length          = childNodes.length;
                        
                        for (k = 0; k < length; k++) collectNodes(childNodes[ k ]);
                    }
                }
            }
        };
        
        collectNodes(root);
        
        // additional filtering of the result set
        // removes the parent nodes which do not match filter themselves and have no macthing children  
        var nodesToKeep = [];
            
        for (var i = 0, len = linearNodes.length; i < len; i++) {
            var node    = linearNodes[ i ];
            
            if (node.data.leaf || keepTheseParents[ node.internalId ]) nodesToKeep[ nodesToKeep.length ] = node;
        }
        
        var nodeStore   = this.nodeStore;
        
        // "loadDataInNodeStore" is a special hook for buffered case
        // in buffered case, instead of "loadRecords" we need to use "cachePage"
        if (!this.loadDataInNodeStore || !this.loadDataInNodeStore(nodesToKeep)) { 
            nodeStore.loadRecords(nodesToKeep, false);
        
            // HACK - forcing view to refresh, the usual "refresh" event is blocked by the tree view (see `blockRefresh` property)
            nodeStore.fireEvent('clear', nodeStore);
        }
        
        this.isFilteredFlag     = true;
        this.lastTreeFilter     = params;
        this.fireEvent('nodestore-datachange-end', this);
        
        this.fireEvent('filter-set', this);
    },
    
    
    /**
     * Hide nodes from the tree store visual presentation (they still remain in the store).
     * 
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     * 
     * @param {Function} filter - A filtering function. Will be called for each node in the tree store and receive the current node as the 1st argument. Should return `true` to **hide** the node
     * and `false`, to **keep it visible**.
     * @param {Object} scope (optional).
     */
    hideNodesBy : function (filter, scope) {
        if (this.isFiltered()) throw new Error("Can't hide nodes of the filtered tree store");
        
        var me      = this;
        scope       = scope || this;
        
        this.getRootNode().cascadeBy(function (node) {
            node.hidden = filter.call(scope, node, me);
        });
        
        this.refreshNodeStoreContent();
    },
    
    
    /**
     * Shows all nodes, previously hidden with {@link #hideNodesBy}
     * 
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     */
    showAllNodes : function () {
        this.getRootNode().cascadeBy(function (node) {
            node.hidden = node.data.hidden = false;
        });
        
        this.refreshNodeStoreContent();
    },
    
    
    inheritables : function () {
        return {
            // the NodeStore does not fire a neither "clear" event when root.removeAll() method is called
            // nor "refresh" event when new nodes are loaded
            // meanwhile, the buffered renderer plugin relies on that event (at least one of them)
            // to clear some internal state, so we fire that event manually
            // the "clear" event seems to be safer to fire, because "refresh" may cause an extra view refresh
            // ("clear" will do too, but the view will be empty)
            load : function() {
                var root        = this.getRootNode();
                
                if (root) {
                    var nodeStore       = this.nodeStore;
                    var prevRemoveAll   = root.removeAll;
                    
                    root.removeAll  = function () {
                        prevRemoveAll.apply(this, arguments);
                        
                        nodeStore && nodeStore.fireEvent('clear', nodeStore);
                        
                        delete root.removeAll;
                    };
                }
        
                this.callParent(arguments);
                
                if (root) delete root.removeAll;
            }
            // eof load
        };
        // eof object returned from inheritables
    }
    // eof inheritables
});
/**
@class Sch.data.ResourceStore
 
This is a class holding the collection the {@link Sch.model.Resource resources} to be rendered into a {@link Sch.panel.SchedulerGrid scheduler panel}. 
Its a subclass of "Ext.data.Store" - a store with linear data presentation.

*/
Ext.define("Sch.data.ResourceStore", {
    extend  : 'Ext.data.Store',
    model   : 'Sch.model.Resource',
    config : { model : 'Sch.model.Resource' },
    
    mixins  : [
        'Sch.data.mixin.ResourceStore'
    ],

    constructor : function() {
        this.callParent(arguments);

        var newC = function () {};
        newC.prototype = Ext.ModelManager.getModel(this.getModel()).prototype;

        if (!(new newC() instanceof Sch.model.Resource)) {
            throw 'The model for the ResourceStore must subclass Sch.model.Resource';
        }
    }
});
/**
@class Sch.data.TimeAxis
@extends Ext.data.JsonStore

A class representing the time axis of the scheduler. The scheduler timescale is based on the ticks generated by this class.
This is a pure "data" (model) representation of the time axis and has no UI elements.
 
The time axis can be {@link #continuous} or not. In continuos mode, each timespan starts where the previous ended, and in non-continuous mode
 there can be gaps between the ticks.
A non-continuous time axis can be used when want to filter out certain periods of time (like weekends) from the time axis.

To create a non-continuos time axis you have 2 options. First, you can create a time axis containing only the time spans of interest.
To do that, subclass this class and override the {@link #generateTicks} method. See the `noncontinuous-timeaxis` example in the Ext Scheduler SDK for guidance.

The other alternative is to call the {@link #filterBy} method, passing a function to it which should return `false` if the time tick should be filtered out.
Calling the {@link #clearFilter} method will return you to full time axis.
 
*/
Ext.define("Sch.data.TimeAxis", {
    extend      : "Ext.data.JsonStore",
    
    requires    : [
        'Sch.util.Date',
        // this "require" is needed for Sencha Touch
        'Sch.model.TimeAxisTick'
    ],

    model : 'Sch.model.TimeAxisTick',

    /**
    * @cfg {Boolean} continuous
    * Set to false if the timeline is not continuous, e.g. the next timespan does not start where the previous ended (for example skipping weekends etc).
    */
    continuous : true,

    /**
    * @cfg {Boolean} autoAdjust
    * Automatically adjust the timespan when generating ticks with {@link #generateTicks} according to the `viewPreset` configuration. Setting this to false
    * may lead to shifting time/date of ticks.
    */    
    autoAdjust : true,


    // TODO should be removed from this class
    preset              : null,

    unit                : null,
    increment           : null,
    resolutionUnit      : null,
    resolutionIncrement : null,

    weekStartDay        : null,

    mainUnit            : null,
    shiftUnit           : null,

    headerConfig        : null,
    shiftIncrement      : 1,
    defaultSpan         : 1,

    // private
    constructor : function(config) {
        var me = this;

        // For Sencha Touch, config system
        if (me.setModel) {
            me.setModel(me.model);
        }

        me.originalContinuous = me.continuous;

        me.callParent(arguments);

        me.addEvents(
            /**
            * @event beforereconfigure
            * Fires before the timeaxis is about to be reconfigured (e.g. new start/end date or unit/increment). Return false to abort the operation.
            * @param {Sch.data.TimeAxis} timeAxis The time axis instance
            * @param {Date} startDate The new time axis start date
            * @param {Date} endDate The new time axis end date
            */
            'beforereconfigure',

            /**
            * @event reconfigure
            * Fires when the timeaxis has been reconfigured (e.g. new start/end date or unit/increment)
            * @param {Sch.data.TimeAxis} timeAxis The time axis instance
            */
            'reconfigure'
        );

        me.on(Ext.versions.touch ? 'refresh' : 'datachanged', function(ta, newPreset) {
            me.fireEvent('reconfigure', me, newPreset);
        });

        if (config && me.start) {
            me.reconfigure(config);
        }
    },

    /**
    * Reconfigures the time axis based on the config object supplied and generates the new 'ticks'.
    * @param {Object} config
    * @private
    */
    reconfigure : function(config) {
        Ext.apply(this, config); 
        var ticks = this.generateTicks(this.start, this.end, this.unit, this.increment || 1, this.mainUnit);
        
        if (this.fireEvent('beforereconfigure', this, this.start, this.end) !== false) {
            // Distinguish between altering the properties of the timeAxis as opposed to
            // traversing it, changing the start/end dates
            var nbrConfigKeys = Ext.Object.getKeys(config).length;
            var presetNotChanged = (nbrConfigKeys === 1 && "start" in config) ||
                                   (nbrConfigKeys === 2 && "start" in config && "end" in config);

            // Suspending to be able to detect an invalid filter
            this.removeAll(true);
            this.suspendEvents();
            this.add(ticks);
        
            if (this.getCount() === 0) {
                Ext.Error.raise('Invalid time axis configuration or filter, please check your input data.');
            }
            this.resumeEvents();

            this.fireEvent('datachanged', this, !presetNotChanged);
            this.fireEvent('refresh', this, !presetNotChanged);
        }
    },

    /**
    * Changes the time axis timespan to the supplied start and end dates.
    * @param {Date} start The new start date
    * @param {Date} end The new end date
    */
    setTimeSpan : function(start, end) {
        var adjusted = this.getAdjustedDates(start, end);

        if (this.getStart() - adjusted.start !== 0 || this.getEnd() - adjusted.end !== 0) {
            this.reconfigure({
                start   : start,
                end     : end
            });
        }
    },

    /**
     * [Experimental] Filter the time axis by a function. The passed function will be called with each tick in time axis. 
     * If the function returns true, the 'tick' is included otherwise it is filtered.
     * @param {Function} fn The function to be called, it will receive an object with start/end properties, and 'index' of the tick.
     * @param {Object} scope (optional) The scope (`this` reference) in which the function is executed. 
     */
    filterBy : function(fn, scope) {
        this.continuous = false;
        scope = scope || this;
        
        this.clearFilter(true);
        // Suspending to be able to detect an invalid filter
        this.suspendEvents(true);
        this.filter([{
            filterFn : function(t, index) {
                return fn.call(scope, t.data, index);
            }
        }]);

        if (this.getCount() === 0) {
            this.clearFilter();
            this.resumeEvents();
            Ext.Error.raise('Invalid time axis filter - no ticks passed through the filter. Please check your filter method.');
        }
        this.resumeEvents();
    },

    /**
     * Returns `true` if the time axis is continuos (will return `false` when filtered)
     * @return {Boolean}
     */
    isContinuous : function() {
        return this.continuous && !this.isFiltered();
    },

    /**
     * Clear the current filter of the time axis
     */
    clearFilter : function() {
        this.continuous = this.originalContinuous;
        this.callParent(arguments);
    },

    /**
     * Method generating the ticks for this time axis. Should return an array of ticks. Each tick is an object of the following structure:
        {
            start       : ..., // start date
            end         : ...  // end date
        }
     *
     * Take notice, that this function either has to be called with `start`/`end` parameters, or create those variables.
     * 
     * @param {Date} startDate The start date of the interval
     * @param {Date} endDate The end date of the interval
     * @param {String} unit The unit of the time axis
     * @param {Mixed} increment The increment for the unit specified.
     * @return {Array} ticks The ticks representing the time axis
     */
    generateTicks : function(start, end, unit, increment) {
        var ticks           = [],
            intervalEnd,
            DATE            = Sch.util.Date,
            dstDiff         = 0;

        unit                = unit || this.unit;
        increment           = increment || this.increment;
        
        if (this.autoAdjust) {
            var adjusted    = this.getAdjustedDates(start, end);
            start           = adjusted.start;
            end             = adjusted.end;
        }
       
        while (start < end) {
            intervalEnd     = this.getNext(start, unit, increment);
            
            if (!this.autoAdjust && intervalEnd > end) intervalEnd = end;
            
            // Handle hourly increments crossing DST boundaries to keep the timescale looking correct
            // Only do this for HOUR resolution currently, and only handle it once per tick generation.
            if (unit === DATE.HOUR && increment > 1 && ticks.length > 0 && dstDiff === 0) {
                var prev    = ticks[ ticks.length - 1 ];
                
                dstDiff     = ((prev.start.getHours() + increment) % 24) - prev.end.getHours();

                if (dstDiff !== 0) {
                    // A DST boundary was crossed in previous tick, adjust this tick to keep timeaxis "symmetric".
                    intervalEnd = DATE.add(intervalEnd, DATE.HOUR, dstDiff);
                }
            }

            ticks.push({
                start   : start,
                end     : intervalEnd
            });
            start           = intervalEnd;
        }
        
        return ticks;
    },

    getAdjustedDates : function(start, end) {
        if (this.autoAdjust) {
            start = this.floorDate(start || this.getStart(), false);
            end = this.ceilDate(end || Sch.util.Date.add(start, this.mainUnit, this.defaultSpan), false);
        }
        return { start : start, end : end };
    },

    /**
    * Gets a tick "coordinate" representing the date position on the time scale. Returns -1 if the date is not part of the time axis.
    * @param {Date} date the date
    * @return {Float} the tick position on the scale or -1 if the date is not part of the time axis
    */
    getTickFromDate : function(date) {
        
        if (this.getStart() > date || this.getEnd() < date) {
            return -1;
        } 

        var ticks = this.getRange(),
            tickStart, tickEnd, i, l;

        for (i = 0, l = ticks.length; i < l; i++) {
            tickEnd = ticks[i].data.end;
            if (date <= tickEnd) {
                tickStart = ticks[i].data.start;
                    
                return i + (date > tickStart ? (date - tickStart)/(tickEnd - tickStart) : 0);
            } 
        }
        
        return -1;
    },

    /**
    * Gets the time represented by a tick "coordinate".
    * @param {Float} tick the tick "coordinate"
    * @param {String} roundingMethod The rounding method to use
    * @return {Date} The date to represented by the tick "coordinate", or null if invalid.
    */
    getDateFromTick : function(tick, roundingMethod) {
        var count = this.getCount();
        
        if (tick === count){
            return this.getEnd();
        }

        var wholeTick = Math.floor(tick),
            fraction = tick - wholeTick,
            t = this.getAt(wholeTick);

        if (!t) {
            return null;
        }

        var tickData = t.data;
        var date = Sch.util.Date.add(tickData.start, Sch.util.Date.MILLI, fraction * (tickData.end - tickData.start));

        if (roundingMethod) {
            date = this[roundingMethod + 'Date'](date);
        }

        return date;
    },

    /**
    * Returns the ticks of the timeaxis in an array of objects with a "start" and "end" date.
    * @return {Array[Object]} the ticks on the scale
    */
    getTicks : function() {
        var ticks = [];
        
        this.each(function(r) { ticks.push(r.data); });
        return ticks;
    },

    /**
    * Method to get the current start date of the time axis
    * @return {Date} The start date
    */
    getStart : function() {
        var first = this.first();
        
        if (first) {
            return Ext.Date.clone(first.data.start);
        }
        return null;
    },

    /**
    * Method to get a the current end date of the time axis
    * @return {Date} The end date
    */
    getEnd : function() {
        var last = this.last();
        
        if (last) {
            return Ext.Date.clone(last.data.end);
        }
        return null;
    },

    // Floors a date and optionally snaps it to one of the following resolutions:
    // 1. 'resolutionUnit'. If param 'resolutionUnit' is passed, the date will simply be floored to this unit.
    // 2. If resolutionUnit is not passed: If date should be snapped relative to the timeaxis start date, the resolutionUnit of the timeAxis will be used, or the timeAxis 'mainUnit' will be used to snap the date
    //
    // returns a copy of the original date
    // private
    floorDate : function(date, relativeToStart, resolutionUnit) {
        relativeToStart = relativeToStart !== false;
        
        var dt = Ext.Date.clone(date),
            relativeTo = relativeToStart ? this.getStart() : null,
            increment = this.resolutionIncrement,
            unit;

        if (resolutionUnit) {
            unit = resolutionUnit;
        } else {
            unit = relativeToStart ? this.resolutionUnit : this.mainUnit;
        }

        switch(unit) {
            case Sch.util.Date.MILLI:    
                if (relativeToStart) {
                    var milliseconds = Sch.util.Date.getDurationInMilliseconds(relativeTo, dt),
                        snappedMilliseconds = Math.floor(milliseconds / increment) * increment;
                    dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MILLI, snappedMilliseconds);
                }
                break;

            case Sch.util.Date.SECOND:
                if (relativeToStart) {
                    var seconds = Sch.util.Date.getDurationInSeconds(relativeTo, dt),
                        snappedSeconds = Math.floor(seconds / increment) * increment;
                    dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MILLI, snappedSeconds * 1000);
                } else {
                    dt.setMilliseconds(0);
                }
                break;

            case Sch.util.Date.MINUTE:
                if (relativeToStart) {
                    var minutes = Sch.util.Date.getDurationInMinutes(relativeTo, dt),
                        snappedMinutes = Math.floor(minutes / increment) * increment;
                    dt = Sch.util.Date.add(relativeTo, Sch.util.Date.SECOND, snappedMinutes * 60);
                } else {
                    dt.setSeconds(0);
                    dt.setMilliseconds(0);
                }
                break; 

            case Sch.util.Date.HOUR:
                if (relativeToStart) {
                    var nbrHours = Sch.util.Date.getDurationInHours(this.getStart(), dt),
                        snappedHours = Math.floor(nbrHours / increment) * increment;
                    dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MINUTE, snappedHours * 60);
                } else {
                    dt.setMinutes(0);
                    dt.setSeconds(0);
                    dt.setMilliseconds(0);
                }
                break;

            case Sch.util.Date.DAY:
                if (relativeToStart) {
                    var nbrDays = Sch.util.Date.getDurationInDays(relativeTo, dt),
                        snappedDays = Math.floor(nbrDays / increment) * increment;
                    dt = Sch.util.Date.add(relativeTo, Sch.util.Date.DAY, snappedDays);
                } else {
                    Ext.Date.clearTime(dt);
                }
                break;

            case Sch.util.Date.WEEK:
                var day = dt.getDay();
                Ext.Date.clearTime(dt);
                if (day !== this.weekStartDay) {
                    dt = Sch.util.Date.add(dt, Sch.util.Date.DAY, -(day > this.weekStartDay ? (day - this.weekStartDay) : (7 - day - this.weekStartDay)));
                }
                break;

            case Sch.util.Date.MONTH:
                if (relativeToStart) {
                    var nbrMonths = Sch.util.Date.getDurationInMonths(relativeTo, dt),
                        snappedMonths = Math.floor(nbrMonths / increment) * increment;
                    dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MONTH, snappedMonths);
                } else {
                    Ext.Date.clearTime(dt);
                    dt.setDate(1);
                }
                break;

            case Sch.util.Date.QUARTER:
                Ext.Date.clearTime(dt);
                dt.setDate(1);
                dt = Sch.util.Date.add(dt, Sch.util.Date.MONTH, -(dt.getMonth() % 3));
                break;

            case Sch.util.Date.YEAR:
                if (relativeToStart) {
                    var nbrYears = Sch.util.Date.getDurationInYears(relativeTo, dt),
                        snappedYears = Math.floor(nbrYears / increment) * increment;
                    dt = Sch.util.Date.add(relativeTo, Sch.util.Date.YEAR, snappedYears);
                } else {
                    dt = new Date(date.getFullYear(), 0, 1);
                }
                break;

        }
        return dt;
    },


    // Rounds the date to nearest minute increment
    // private
    roundDate : function(date) {
        var dt = Ext.Date.clone(date),
            relativeTo = this.getStart(),
            increment = this.resolutionIncrement;

        switch(this.resolutionUnit) {
            case Sch.util.Date.MILLI:
                var milliseconds = Sch.util.Date.getDurationInMilliseconds(relativeTo, dt),
                    snappedMilliseconds = Math.round(milliseconds / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MILLI, snappedMilliseconds);
                break;

            case Sch.util.Date.SECOND:
                var seconds = Sch.util.Date.getDurationInSeconds(relativeTo, dt),
                    snappedSeconds = Math.round(seconds / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MILLI, snappedSeconds * 1000);
                break;

            case Sch.util.Date.MINUTE:
                var minutes = Sch.util.Date.getDurationInMinutes(relativeTo, dt),
                    snappedMinutes = Math.round(minutes / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.SECOND, snappedMinutes * 60);
                break;

            case Sch.util.Date.HOUR:
                var nbrHours = Sch.util.Date.getDurationInHours(this.getStart(), dt),
                    snappedHours = Math.round(nbrHours / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MINUTE, snappedHours * 60);
                break;

            case Sch.util.Date.DAY:
                var nbrDays = Sch.util.Date.getDurationInDays(relativeTo, dt),
                    snappedDays = Math.round(nbrDays / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.DAY, snappedDays);
                break;

            case Sch.util.Date.WEEK:
                Ext.Date.clearTime(dt);

                var distanceToWeekStartDay = dt.getDay() - this.weekStartDay,
                    toAdd;

                if (distanceToWeekStartDay < 0) {
                    distanceToWeekStartDay = 7 + distanceToWeekStartDay;
                }

                if (Math.round(distanceToWeekStartDay/7) === 1) {
                    toAdd = 7 - distanceToWeekStartDay;
                } else {
                    toAdd = -distanceToWeekStartDay;
                }

                dt = Sch.util.Date.add(dt, Sch.util.Date.DAY, toAdd);
                break;

            case Sch.util.Date.MONTH:
                var nbrMonths = Sch.util.Date.getDurationInMonths(relativeTo, dt) + (dt.getDate() / Ext.Date.getDaysInMonth(dt)),
                    snappedMonths = Math.round(nbrMonths / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MONTH, snappedMonths);
                break;

            case Sch.util.Date.QUARTER:
                Ext.Date.clearTime(dt);
                dt.setDate(1);
                dt = Sch.util.Date.add(dt, Sch.util.Date.MONTH, 3 - (dt.getMonth() % 3));
                break;

            case Sch.util.Date.YEAR:
                var nbrYears = Sch.util.Date.getDurationInYears(relativeTo, dt),
                    snappedYears = Math.round(nbrYears / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.YEAR, snappedYears);
                break;

        }
        return dt;
    },

    // private
    ceilDate : function(date, relativeToStart, resolutionUnit) {
        var dt = Ext.Date.clone(date);
        relativeToStart = relativeToStart !== false;
        
        var increment = relativeToStart ? this.resolutionIncrement : 1,
            doCall = false,
            unit;

        if (resolutionUnit){
            unit = resolutionUnit;
        } else {
            unit = relativeToStart ? this.resolutionUnit : this.mainUnit;
        }

        switch (unit) {
            case Sch.util.Date.HOUR:
                if (dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.DAY:
                if (dt.getHours() > 0 || dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.WEEK: 
                Ext.Date.clearTime(dt);
                if (dt.getDay() !== this.weekStartDay) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.MONTH: 
                Ext.Date.clearTime(dt);
                if(dt.getDate() !== 1) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.QUARTER:
                Ext.Date.clearTime(dt);
                if(dt.getMonth() % 3 !== 0) {
                    doCall = true;
                }
            break;
            
            case Sch.util.Date.YEAR:
                Ext.Date.clearTime(dt);
                if(dt.getMonth() !== 0 || dt.getDate() !== 1) {
                    doCall = true;
                }
            break;

            default:
            break;
        }

        if (doCall) {
            return this.getNext(dt, unit, increment);
        } else {
            return dt;
        }
    },

    // private
    getNext : function(date, unit, increment) {
        return Sch.util.Date.getNext(date, unit, increment, this.weekStartDay);
    },

    // private
    getResolution : function() {
        return {
            unit : this.resolutionUnit,
            increment : this.resolutionIncrement
        };
    },

    // private
    setResolution : function(unit, increment) {
        this.resolutionUnit = unit;
        this.resolutionIncrement = increment || 1;
    },

    /**
     * Moves the time axis by the passed amount and unit.
     * @param {Int} amount The number of units to jump
     * @param {String} unit The unit (Day, Week etc)
     */
    shift: function (amount, unit) {
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },

    /**
    * Moves the time axis forward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement` 
    * config of the current view preset.
    * @param {Int} amount (optional) The number of units to jump forward
    */
    shiftNext: function (amount) {
        amount = amount || this.getShiftIncrement();
        var unit = this.getShiftUnit();
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },

    /**
    * Moves the time axis backward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement` config of the current view preset.
    * @param {Int} amount (optional) The number of units to jump backward
    */
    shiftPrevious: function (amount) {
        amount = -(amount || this.getShiftIncrement());
        var unit = this.getShiftUnit();
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },

    getShiftUnit: function () {
        return this.shiftUnit || this.getMainUnit();
    },
    
    // private
    getShiftIncrement: function () {
        return this.shiftIncrement || 1;
    },
    
    // private
    getUnit: function () {
        return this.unit;
    },

    // private
    getIncrement: function () {
        return this.increment;
    },

    /**
    * Returns true if the passed date is inside the span of the current time axis.
    * @param {Date} date The date to query for
    * @return {Boolean} true if the date is part of the timeaxis
    */
    dateInAxis: function(date) {
        return Sch.util.Date.betweenLesser(date, this.getStart(), this.getEnd());
    },

    /**
    * Returns true if the passed timespan is part of the current time axis (in whole or partially).
    * @param {Date} start The start date
    * @param {Date} end The end date
    * @return {boolean} true if the timespan is part of the timeaxis
    */
    timeSpanInAxis: function(start, end) {
        if (this.isContinuous()) {
            return Sch.util.Date.intersectSpans(start, end, this.getStart(), this.getEnd());
        } else {
            return (start < this.getStart() && end > this.getEnd()) || 
                   this.getTickFromDate(start) !== this.getTickFromDate(end);
        }
    },

    /**
    * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
    * Return false to break the iteration.
    * @param {String} position 'main' (middle), 'top' or 'bottom'
    * @param {Function} iteratorFn The function to call, will be called with start date, end date and "tick index"
    * @param {Object} scope (optional) The "this" object to use for the function call
    */
    forEachInterval : function(position, iteratorFn, scope) {
        scope = scope || this;

        if (!this.headerConfig) return;     // Not initialized

        if (position === 'top' || (position === 'middle' && this.headerConfig.bottom)) {
            this.forEachAuxInterval(position, iteratorFn, scope);
        } else {
            // This is the lowest header row, which should be fed the data in the tickStore
            this.each(function(r, index) { 
                return iteratorFn.call(scope, r.data.start, r.data.end, index);
            });
        }
    },

    /**
    * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
    * Return false to break the iteration.
    * @protected
    * @param {Function} iteratorFn The function to call
    * @param {Object} scope (optional) The "this" object to use for the function call
    */
    forEachMainInterval : function(iteratorFn, scope) {
        this.forEachInterval('middle', iteratorFn, scope);
    },

    /**
    * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
    * @protected
    * @param {Function} iteratorFn The function to call
    * @param {Object} scope (optional) The "this" object to use for the function call
    */
    forEachAuxInterval : function(position, iteratorFn, scope) {
        scope = scope || this;

        var end             = this.getEnd(),
            dt              = this.getStart(),
            i               = 0,
            intervalEnd;

        if (dt > end) throw 'Invalid time axis configuration';

        while (dt < end) {
            intervalEnd =  Sch.util.Date.min(this.getNext(dt, this.headerConfig[position].unit, this.headerConfig[position].increment || 1), end);
            iteratorFn.call(scope, dt, intervalEnd, i);
            dt = intervalEnd;
            i++;
        }
    }
});
/**
@class Sch.preset.ViewPreset
Not used directly, but the properties below are rather provided inline as seen in the source of {@link Sch.preset.Manager}. This class is just provided for documentation purposes.

A sample preset looks like:

        hourAndDay : {
            timeColumnWidth         : 60,       // Time column width (used for rowHeight in vertical mode)
            rowHeight               : 24,       // Only used in horizontal orientation
            resourceColumnWidth     : 100,      // Only used in vertical orientation
            
            displayDateFormat       : 'G:i',    // Controls how dates will be displayed in tooltips etc
            
            shiftIncrement          : 1,        // Controls how much time to skip when calling shiftNext and shiftPrevious.
            shiftUnit               : "DAY",    // Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
            defaultSpan             : 12,       // By default, if no end date is supplied to a view it will show 12 hours
            
            timeResolution          : {         // Dates will be snapped to this resolution
                unit        : "MINUTE",         // Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
                increment   : 15
            },
            
            headerConfig            : {         // This defines your header, you must include a "middle" object, and top/bottom are optional. 
                middle      : {                 // For each row you can define "unit", "increment", "dateFormat", "renderer", "align", and "scope"
                    unit        : "HOUR",
                    dateFormat  : 'G:i'
                },
                top         : {
                    unit        : "DAY",
                    dateFormat  : 'D d/m'
                }
            }
        },

See the {@link Sch.preset.Manager} for the list of available presets.
 
*/
Ext.define("Sch.preset.ViewPreset", {
    
    columnWidth         : null,
    rowHeight           : null,
    
    /**
     * @cfg {Int} timeAxisColumnWidth The width of the time axis column in the vertical orientation 
     */
    timeAxisColumnWidth : null,
    
    /**
    * @cfg {String} dateFormat Defines how dates will be formatted in tooltips etc
    */
    displayDateFormat   : 'G:i',
    
    /**
    * @cfg {String} shiftUnit The unit to shift when calling shiftNext/shiftPrevious to navigate in the chart. 
    * Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
    */
    shiftUnit           : "HOUR",
    
    /**
    * @cfg {Int} shiftIncrement The amount to shift (in shiftUnits)
    */
    shiftIncrement      : 1,
    
    /**
    * @cfg {Int} defaultSpan The amount of time to show by default in a view (in the unit defined by the middle header)
    */
    defaultSpan         : 12,
    
    /**
    * @cfg {Object} timeResolution An object containing a unit identifier and an increment variable. Example:
    * 
        timeResolution : {
            unit        : "HOUR",  //Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
            increment   : 1
        }
    * 
    */
    timeResolution      : null,

    /**
    * @cfg {Object} headerConfig An object containing one or more {@link Sch.preset.ViewPresetHeaderRow} rows defining how your headers shall be composed. 
    * Your 'main' unit should be the middle header unit. This object can contain "bottom", "middle" and "top" header definitions. The 'middle' header is mandatory.
    */
    headerConfig        : null,
    
    
    headers             : null,
    mainHeader          : 0,
    
    
    constructor : function (config) {
        Ext.apply(this, config);
    },

    getHeaders : function () {
        if (this.headers) return this.headers;
        
        var headerConfig        = this.headerConfig;
        
        this.mainHeader         = headerConfig.top ? 1 : 0;
        
        return this.headers     = [].concat(headerConfig.top || [], headerConfig.middle || [], headerConfig.bottom || []);
    },
    
    
    getMainHeader : function () {
        return this.getHeaders()[ this.mainHeader ];
    },
    
    
    getBottomHeader : function () {
        var headers     = this.getHeaders();
        
        return headers[ headers.length - 1 ];
    },
    
    
    getTimeAxisConfig : function () {
        return {
            mainUnit                : this.getMainHeader().unit,
            
            unit                    : this.getBottomHeader().unit,
            increment               : this.getBottomHeader().increment,
            
            shiftUnit               : this.shiftUnit,
            shiftIncrement          : this.shiftIncrement,
            
            defaultSpan             : this.defaultSpan,
            
            resolutionUnit          : this.timeResolution.unit,
            resolutionIncrement     : this.timeResolution.increment
        };
    },
    
    
    clone : function () {
        var config      = {};
        var me          = this;
        
        Ext.each([
            'columnWidth',
            'rowHeight',
            'timeAxisColumnWidth',
            'dateFormat',
            'shiftUnit',
            'shiftIncrement',
            'defaultSpan',
            'timeResolution',
            'headerConfig'
        ], function (name) {
            config[ name ] = me[ name ];
        });
        
        return new this.self(Ext.clone(config));
    }    
});

/**
@class Sch.preset.Manager
@singleton

Provides a registry of the possible view presets that any instance of a Panel with {@link Sch.mixin.SchedulerPanel} mixin can use.

See the {@link Sch.preset.ViewPreset} and {@link Sch.preset.ViewPresetHeaderRow} classes for a description of the view preset properties.

Available presets are:

- `minuteAndHour` - creates 2 level headers - hour and minutes within it
- `hourAndDay` - creates 2 level headers - day and hours within it: {@img scheduler/images/hourAndDay.png}
- `dayAndWeek` - creates 2 level headers - week and days within it: {@img scheduler/images/dayAndWeek.png}
- `weekAndDay` - just like `dayAndWeek` but with different formatting: {@img scheduler/images/weekAndDay.png}
- `weekAndMonth` - creates 2 level headers - month and weeks within it: {@img scheduler/images/weekAndMonth.png}

- `monthAndYear` - creates 2 level headers - year and months within it: {@img scheduler/images/monthAndYear.png}
- `year` - creates 2 level headers - year and quarters within it: {@img scheduler/images/year-preset.png}
- `weekAndDayLetter` - creates a 2 level header - with weeks and day letters within it.
- `weekDateAndMonth` - creates 2 level headers - month and weeks within it (weeks shown by first day only): {@img scheduler/images/weekDateAndMonth.png}

You can register your own preset with the {@link #registerPreset} call

*/

Ext.define('Sch.preset.Manager', {
    extend: 'Ext.util.MixedCollection',
    requires: [
        'Sch.util.Date',
        'Sch.preset.ViewPreset'
    ],
    mixins: ['Sch.mixin.Localizable'],

    singleton: true,

    constructor : function() {
        this.callParent(arguments);
        this.registerDefaults();
    },

    /**
    * Registers a new view preset to be used by any scheduler grid or tree on the page.
    * @param {String} name The unique name identifying this preset
    * @param {Object} config The configuration properties of the view preset (see {@link Sch.preset.ViewPreset} for more information)
    */
    registerPreset : function(name, cfg) {
        if (cfg) {
            var headerConfig    = cfg.headerConfig;
            var DATE            = Sch.util.Date;

            // Make sure date "unit" constant specified in the preset are resolved
            for (var o in headerConfig) {
                if (headerConfig.hasOwnProperty(o)) {
                    if (DATE[headerConfig[o].unit]) {
                        headerConfig[o].unit = DATE[headerConfig[o].unit.toUpperCase()];
                    }
                }
            }

            if (!cfg.timeColumnWidth) {
                cfg.timeColumnWidth = 50;
            }

            // Resolve date units
            if (cfg.timeResolution && DATE[cfg.timeResolution.unit]) {
                cfg.timeResolution.unit = DATE[cfg.timeResolution.unit.toUpperCase()];
            }

            // Resolve date units
            if (cfg.shiftUnit && DATE[cfg.shiftUnit]) {
                cfg.shiftUnit = DATE[cfg.shiftUnit.toUpperCase()];
            }
        }

        if (this.isValidPreset(cfg)) {
            if (this.containsKey(name)){
                this.removeAtKey(name);
            }
            this.add(name, new Sch.preset.ViewPreset(cfg));
        } else {
            throw 'Invalid preset, please check your configuration';
        }
    },

    isValidPreset : function(cfg) {
        var D = Sch.util.Date,
            valid = true,
            validUnits = Sch.util.Date.units;

        // Make sure all date "unit" constants are valid
        for (var o in cfg.headerConfig) {
            if (cfg.headerConfig.hasOwnProperty(o)) {
                valid = valid && Ext.Array.indexOf(validUnits, cfg.headerConfig[o].unit) >= 0;
            }
        }

        if (cfg.timeResolution) {
            valid = valid && Ext.Array.indexOf(validUnits, cfg.timeResolution.unit) >= 0;
        }

        if (cfg.shiftUnit) {
            valid = valid && Ext.Array.indexOf(validUnits, cfg.shiftUnit) >= 0;
        }

        return valid;
    },

    /**
    * Fetches a view preset from the global cache
    * @param {String} name The name of the preset
    * @return {Object} The view preset, see {@link Sch.preset.ViewPreset} for more information
    */
    getPreset : function(name) {
        return this.get(name);
    },

    /**
    * Deletes a view preset
    * @param {String} name The name of the preset
    */
    deletePreset : function(name) {
        this.removeAtKey(name);
    },

    registerDefaults : function() {
        var pm = this,
            vp = this.defaultPresets;

        for (var p in vp) {
            pm.registerPreset(p, vp[p]);
        }
    },

    defaultPresets : {
        secondAndMinute : {
            timeColumnWidth     : 30,   // Time column width (used for rowHeight in vertical mode)
            rowHeight           : 24,    // Only used in horizontal orientation
            resourceColumnWidth : 100,   // Only used in vertical orientation
            displayDateFormat   : 'G:i:s', // Controls how dates will be displayed in tooltips etc
            shiftIncrement      : 10,     // Controls how much time to skip when calling shiftNext and shiftPrevious.
            shiftUnit           : "MINUTE",// Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
            defaultSpan         : 24,    // By default, if no end date is supplied to a view it will show 24 hours
            timeResolution      : {      // Dates will be snapped to this resolution
                unit        : "SECOND",  // Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
                increment   : 5
            },
            headerConfig        : {      // This defines your header, you must include a "middle" object, top/bottom are optional. For each row you can define "unit", "increment", "dateFormat", "renderer", "align", and "scope"
                middle  : {
                    unit        : "SECOND",
                    increment   : 10,
                    align       : 'center',
                    dateFormat  : 's'
                },
                top     : {
                    unit        : "MINUTE",
                    align       : 'center',
                    dateFormat  : 'D, d g:iA'
                }
            }
        },
        minuteAndHour : {
            timeColumnWidth     : 100,   // Time column width (used for rowHeight in vertical mode)
            rowHeight           : 24,    // Only used in horizontal orientation
            resourceColumnWidth : 100,   // Only used in vertical orientation
            displayDateFormat   : 'G:i', // Controls how dates will be displayed in tooltips etc
            shiftIncrement      : 1,     // Controls how much time to skip when calling shiftNext and shiftPrevious.
            shiftUnit           : "HOUR",// Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
            defaultSpan         : 24,    // By default, if no end date is supplied to a view it will show 24 hours
            timeResolution      : {      // Dates will be snapped to this resolution
                unit        : "MINUTE",  // Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
                increment   : 30
            },
            headerConfig        : {      // This defines your header, you must include a "middle" object, top/bottom are optional. For each row you can define "unit", "increment", "dateFormat", "renderer", "align", and "scope"
                middle  : {
                    unit        : "MINUTE",
                    increment   : '30',
                    align       : 'center',
                    dateFormat  : 'i'
                },
                top     : {
                    unit        : "HOUR",
                    align       : 'center',
                    dateFormat  : 'D, gA/d'
                }
            }
        },
        hourAndDay : {
            timeColumnWidth     : 60,
            rowHeight           : 24,
            resourceColumnWidth : 100,
            displayDateFormat   : 'G:i',
            shiftIncrement      : 1,
            shiftUnit           : "DAY",
            defaultSpan         : 24,
            timeResolution      : {
                unit        : "MINUTE",
                increment   : 30
            },
            headerConfig        : {
                middle      : {
                    unit        : "HOUR",
                    align       : 'center',
                    dateFormat  : 'G:i'
                },
                top         : {
                    unit        : "DAY",
                    align       : 'center',
                    dateFormat  : 'D d/m'
                }
            }
        },
        dayAndWeek : {
            timeColumnWidth     : 100,
            rowHeight           : 24,
            resourceColumnWidth : 100,
            displayDateFormat   : 'Y-m-d G:i',
            shiftUnit           : "DAY",
            shiftIncrement      : 1,
            defaultSpan         : 5,
            timeResolution      : {
                unit        : "HOUR",
                increment   : 1
            },
            headerConfig        : {
                middle      : {
                    unit        : "DAY",
                    align       : 'center',
                    dateFormat  : 'D d M'
                },
                top : {
                    unit        : "WEEK",
                    align       : 'center',
                    renderer    : function(start, end, cfg) {
                        return Sch.util.Date.getShortNameOfUnit("WEEK") + '.' + Ext.Date.format(start, 'W M Y');
                    }
                }
            }
        },

        weekAndDay : {
            timeColumnWidth     : 100,
            rowHeight           : 24,
            resourceColumnWidth : 100,
            displayDateFormat   : 'Y-m-d',
            shiftUnit           : "WEEK",
            shiftIncrement      : 1,
            defaultSpan         : 1,
            timeResolution      : {
                unit        : "DAY",
                increment   : 1
            },
            headerConfig        : {
                bottom : {
                    unit        : "DAY",
                    align       : 'center',
                    increment   : 1,
                    dateFormat  : 'd/m'
                },
                middle : {
                    unit        : "WEEK",
                    dateFormat  : 'D d M'
                }
            }
        },

        weekAndMonth : {
            timeColumnWidth     : 100,
            rowHeight           : 24,
            resourceColumnWidth : 100,
            displayDateFormat   : 'Y-m-d',
            shiftUnit           : "WEEK",
            shiftIncrement      : 5,
            defaultSpan         : 6,
            timeResolution      : {
                unit        : "DAY",
                increment   : 1
            },
            headerConfig        : {
                middle      : {
                    unit    : "WEEK",
                    renderer: function(start, end, cfg) {
                        return Ext.Date.format(start, 'd M');
                    }
                },
                top         : {
                    unit        : "MONTH",
                    align       : 'center',
                    dateFormat  : 'M Y'
                }
            }
        },

        monthAndYear : {
            timeColumnWidth     : 110,
            rowHeight           : 24,
            resourceColumnWidth : 100,
            displayDateFormat   : 'Y-m-d',
            shiftIncrement      : 3,
            shiftUnit           : "MONTH",
            defaultSpan         : 12,
            timeResolution      : {
                unit        : "DAY",
                increment   : 1
            },
            headerConfig        : {
                middle      : {
                    unit        : "MONTH",
                    align       : 'center',
                    dateFormat  : 'M Y'
                },
                top         : {
                    unit        : "YEAR",
                    align       : 'center',
                    dateFormat  : 'Y'
                }
            }
        },
        year : {
            timeColumnWidth     : 100,
            rowHeight           : 24,
            resourceColumnWidth : 100,
            displayDateFormat   : 'Y-m-d',
            shiftUnit           : "YEAR",
            shiftIncrement      : 1,
            defaultSpan         : 1,
            timeResolution      : {
                unit        : "MONTH",
                increment   : 1
            },
            headerConfig        : {
                middle      : {
                    unit        : "QUARTER",
                    align       : 'center',
                    renderer    : function(start, end, cfg) {
                        return Ext.String.format(Sch.util.Date.getShortNameOfUnit("QUARTER").toUpperCase() + '{0}', Math.floor(start.getMonth() / 3) + 1);
                    }
                },
                top         : {
                    unit        : "YEAR",
                    align       : 'center',
                    dateFormat  : 'Y'
                }
            }
        },
        manyYears : {
            timeColumnWidth     : 50,
            rowHeight           : 24,
            resourceColumnWidth : 100,
            displayDateFormat   : 'Y-m-d',
            shiftUnit           : "YEAR",
            shiftIncrement      : 1,
            defaultSpan         : 1,
            timeResolution      : {
                unit        : "YEAR",
                increment   : 1
            },
            headerConfig        : {
                middle      : {
                    unit        : "YEAR",
                    align       : 'center',
                    dateFormat  : 'Y'
                }
            }
        },
        weekAndDayLetter : {
            timeColumnWidth     : 20,
            rowHeight           : 24,
            resourceColumnWidth : 100,
            displayDateFormat   : 'Y-m-d',
            shiftUnit           : "WEEK",
            shiftIncrement      : 1,
            defaultSpan         : 10,
            timeResolution      : {
                unit        : "DAY",
                increment   : 1
            },
            headerConfig        : {
                bottom  : {
                    unit        : "DAY",
                    align       : 'center',
                    renderer    : function(start) {
                        return Ext.Date.dayNames[start.getDay()].substring(0, 1);
                    }
                },
                middle          : {
                    unit        : "WEEK",
                    dateFormat  : 'D d M Y'
                }
            }
        },
        weekDateAndMonth : {
            timeColumnWidth     : 30,
            rowHeight           : 24,
            resourceColumnWidth : 100,
            displayDateFormat   : 'Y-m-d',
            shiftUnit           : "WEEK",
            shiftIncrement      : 1,
            defaultSpan         : 10,
            timeResolution      : {
                unit        : "DAY",
                increment   : 1
            },
            headerConfig : {
                middle      : {
                    unit        : "WEEK",
                    align       : 'center',
                    dateFormat  : 'd'
                },
                top         : {
                    unit        : "MONTH",
                    dateFormat  : 'Y F'
                }
            }
        }
    }
});

/**
@class Sch.feature.AbstractTimeSpan
@extends Ext.util.Observable

Plugin for visualizing "global" time span in the scheduler grid, these can by styled easily using just CSS. This is an abstract class not intended for direct use.

*/
Ext.define("Sch.feature.AbstractTimeSpan", {
    extend              : 'Ext.AbstractPlugin',
    lockableScope       : 'top',
    
    schedulerView       : null,
    timeAxis            : null,
    containerEl         : null,
    
    // If lines/zones should stretch to fill the whole view container element in case the table does not fill it
    expandToFitView     : false,
    
    disabled            : false,
    
    /**
     * @property {String} cls An internal css class which is added to each rendered timespan element
     * @private
     */
    cls                 : null,
    
    /**
     * @cfg {String} clsField Name of field  
     */
    clsField            : 'Cls',
    
    /**
     * @cfg {Ext.XTemplate} template Template to render the timespan elements  
     */
    template            : null,
    
    /**
     * @cfg {Ext.data.Store/String} store A store with timespan data, or a string identifying a store.
     */
    store               : null,
    
    renderElementsBuffered      : false,
    
    /**
     * @cfg {Int} renderDelay Delay the zones rendering by this amount (in ms) to speed up the default rendering of rows and events.
     */
    renderDelay                 : 15,

    // true to refresh the sizes of the rendered elements when an item in the bound view changes
    // false to do a full refresh instead
    refreshSizeOnItemUpdate     : true,

    _resizeTimer                : null,
    _renderTimer                : null,
    
    /**
     * @cfg {Boolean} showHeaderElements Set this to `true` to show indicators in the timeline header area.
     * 
     * Header indicators are placed right above the corresponding element of the scheduling view. You can customize the HTML markup
     * for these indicators with the {@link #headerTemplate} config. Note that the indicators are rendered as a regular div element,
     * which will be styled differently in modern vs legacy browsers.
     *
     */
    showHeaderElements          : false,
    
    /**
     * @private
     * @cfg {Ext.XTemplate} template Template to render the elements at header 
     */
    headerTemplate              : null,
    
    
    /**
     * @cfg {String/Ext.XTemplate} innerHeaderTpl A template providing additional markup to render into each timespan header element
     */
    innerHeaderTpl            : null,
    
    headerContainerCls          : 'sch-header-secondary-canvas',
    headerContainerEl           : null,

    constructor : function(cfg) {
        // unique css class to be able to identify only the zones belonging to this plugin instance
        this.uniqueCls = this.uniqueCls || ('sch-timespangroup-' + Ext.id());
        
        Ext.apply(this, cfg);

        this.callParent(arguments);
    },

    
    /**
     * @param {Boolean} disabled Pass `true` to disable the plugin and remove all rendered elements.
     */
    setDisabled : function(disabled) {
        if (disabled) {
            this.removeElements();
        }
        
        this.disabled = disabled;
    },

    
    removeElements : function () {
        this.removeBodyElements();
        
        if (this.showHeaderElements) {
            this.removeHeaderElements();
        }
    },
    
    //Returns the currently rendered DOM elements of this plugin (if any), as a {@link Ext.CompositeElementLite} collection.
    getBodyElements : function() {
        if (this.containerEl) {
            return this.containerEl.select('.' + this.uniqueCls);
        }

        return null;
    },
    
    /**
     * Returns container to render header elements.
     * 
     * @return {Ext.dom.Element}
     */
    getHeaderContainerEl : function() {
        var containerEl = this.headerContainerEl,
            prefix = Ext.baseCSSPrefix,
            parent;
            
        if (!containerEl || !containerEl.dom) {
            if (this.schedulerView.isHorizontal()) {
                parent = this.panel.getTimeAxisColumn().headerView.containerEl;
            } else {
                parent = this.panel.el.down('.' + prefix + 'grid-inner-locked' +
                    ' .' + prefix + 'panel-body' +
                    ' .' + prefix + 'grid-view');
            }
            
            if (parent) {
                containerEl = parent.down('.' + this.headerContainerCls);
                
                if (!containerEl) {
                    containerEl = parent.appendChild({
                        cls : this.headerContainerCls
                    });
                }
                
                this.headerContainerEl = containerEl;
            }
        }

        return containerEl;
    },
    
    
    getHeaderElements : function() {
        var containerEl = this.getHeaderContainerEl();
        
        if (containerEl) {
            return containerEl.select('.' + this.uniqueCls);
        }

        return null;
    },
    
    
    // private
    removeBodyElements : function() {
        var els = this.getBodyElements();
        
        if (els) {
            els.each(function(el) { el.destroy(); });
        }
    },
    
    
    removeHeaderElements : function() {
        var els = this.getHeaderElements();
        
        if (els) {
            els.each(function(el) { el.destroy(); });
        }
    },
    
    /**
     * Returns id of element for data record.
     * 
     * @param {Ext.data.Model} record
     * 
     * @retrun {String}
     */
    getElementId : function(record) {
        return this.uniqueCls + '-' + record.internalId;
    },
    
    /**
     * Returns id of header element for data record.
     * 
     * @param {Ext.data.Model} record
     * 
     * @retrun {String}
     */
    getHeaderElementId : function(record) {
        return this.uniqueCls + '-header-' + record.internalId;
    },
    
    /**
     * Returns template data to render elements.
     * 
     * @param {Ext.data.Model} record
     * 
     * @return {Object}
     */
    getTemplateData : function(record) {
        return this.prepareTemplateData ? this.prepareTemplateData(record) : record.data;
    },
    
    
    /**
     * Return element class for a record.
     * 
     * @param {Ext.data.Model} record Data record
     * @param {Object} data Template data
     * 
     * @return {String}
     */
    getElementCls : function(record, data) {
        var clsField = record.clsField || this.clsField;
            
        if (!data) {
            data = this.getTemplateData(record);
        }
        
        return this.cls + ' ' + this.uniqueCls + ' ' + (data[clsField] || '');
    },
    
    
    /**
     * Return header element class for data record.
     * 
     * @param {Ext.data.Model} record Data record
     * @param {Object} data
     * 
     * @return {String}
     */
    getHeaderElementCls : function(record, data) {
        var clsField = record.clsField || this.clsField;
            
        if (!data) {
            data = this.getTemplateData(record);
        }

        return 'sch-header-indicator ' + this.uniqueCls + ' ' + (data[clsField] || '');
    },
    
    
    init:function(scheduler) {
        // TODO COMMENT
        if (Ext.versions.touch && !scheduler.isReady()) {
            scheduler.on('viewready', function() { this.init(scheduler); }, this);
            return;
        }
        
        if (Ext.isString(this.innerHeaderTpl)) {
            this.innerHeaderTpl = new Ext.XTemplate(this.innerHeaderTpl);
        }
        
        var innerHeaderTpl = this.innerHeaderTpl;
        
        if (!this.headerTemplate) {
            this.headerTemplate = new Ext.XTemplate(
                '<tpl for=".">',
                    '<div id="{id}" class="{cls}" style="{side}:{position}px;">' +
                    (innerHeaderTpl ? '{[this.renderInner(values)]}' : '') +
                    '</div>',
                '</tpl>',
                {
                    renderInner : function(values) {
                        return innerHeaderTpl.apply(values);
                    }
                }
            );
        }

        this.schedulerView = scheduler.getSchedulingView(); 
        this.panel = scheduler;
        this.timeAxis = scheduler.getTimeAxis();

        this.store = Ext.StoreManager.lookup(this.store);

        if (!this.store) {
            Ext.Error.raise("Error: You must define a store for this plugin");
        }

        if (!this.schedulerView.getEl()) {
            this.schedulerView.on({
                afterrender : this.onAfterRender, 
                scope       : this
            });
        } else {
            this.onAfterRender();
        }

        this.schedulerView.on({
            destroy     : this.onDestroy, 
            scope       : this
        });
    },
    
    
    onAfterRender : function (scheduler) {
        var view            = this.schedulerView;
        this.containerEl    = view.getSecondaryCanvasEl();

        this.storeListeners = {
            load            : this.renderElements,
            datachanged     : this.renderElements, 
            clear           : this.renderElements,
            
            // Ext JS
            add             : this.refreshSingle, 
            remove          : this.renderElements, 
            update          : this.refreshSingle, 
            
            // Sencha Touch
            addrecords      : this.refreshSingle,
            removerecords   : this.renderElements,
            updaterecord    : this.refreshSingle,

            scope           : this
        };

        this.store.on(this.storeListeners);

        if (Ext.data.NodeStore && view.store instanceof Ext.data.NodeStore) {
            // if the view is animated, then update the elements in "after*" events (when the animation has completed)
            if (view.animate) {
                // NOT YET SUPPORTED
//                view.on({
//                    afterexpand     : this.renderElements, 
//                    aftercollapse   : this.renderElements,
//                    
//                    scope           : this
//                });
            } else {
                view.mon(view.store, {
                    expand      : this.renderElements, 
                    collapse    : this.renderElements,
                    
                    scope       : this
                });
            }
        }
        
        view.on({
            bufferedrefresh     : this.renderElements,
            refresh             : this.renderElements,
            itemadd             : this.refreshSizeOnItemUpdate ? this.refreshSizes : this.renderElements,
            itemremove          : this.refreshSizeOnItemUpdate ? this.refreshSizes : this.renderElements,
            itemupdate          : this.refreshSizeOnItemUpdate ? this.refreshSizes : this.renderElements,

            // start grouping events
            groupexpand         : this.renderElements, 
            groupcollapse       : this.renderElements,
            
            columnwidthchange   : this.renderElements,
            resize              : this.renderElements,

            scope               : this
        });

        if (view.headerCt) {
            view.headerCt.on({
                add         : this.renderElements,
                remove      : this.renderElements,
                scope       : this
            });
        }

        this.panel.on({
            viewchange          : this.renderElements,
            show                : this.refreshSizes,
            orientationchange   : this.forceNewRenderingTimeout,
            
            scope               : this
        });

        var rowContainer = view.getRowContainerEl();

        if (rowContainer && rowContainer.down('.sch-timetd')) {
            this.renderElements();
        }
    },
    
    
    forceNewRenderingTimeout : function () {
        this.renderElementsBuffered = false;
        
        clearTimeout(this._renderTimer);
        clearTimeout(this._resizeTimer);

        this.renderElements();
    },

    
    refreshSizesInternal : function() {
        // This can only be called in Horizontal mode
        if (!this.schedulerView.isDestroyed && this.schedulerView.isHorizontal()) {
    
            // Date here is irrelevant, we just want a fresh height value
            var region = this.schedulerView.getTimeSpanRegion(new Date(), null, this.expandToFitView);
            this.getBodyElements().setHeight(region.bottom - region.top);
        }
    },
    
    refreshSizes : function() {
        clearTimeout(this._resizeTimer);

        this._resizeTimer = Ext.Function.defer(this.refreshSizesInternal, this.renderDelay, this);
    },

    
    renderElements : function() {
        if (this.renderElementsBuffered || this.disabled) return;

        this.renderElementsBuffered = true;

        clearTimeout(this._renderTimer);
        
        // Defer to make sure rendering is not delayed by this plugin
        // deferring on 15 because the cascade delay is 10 (cascading will trigger a view refresh)
        this._renderTimer = Ext.Function.defer(this.renderElementsInternal, this.renderDelay, this);
    },
    
    
    /**
     * Sets element X-coordinate relative direction (rtl or ltr).
     * 
     * @param {Ext.Element} el
     * @param {Number} x
     */
    setElementX : function(el, x) {
        if (this.panel.rtl) {
            el.setRight(x);
        } else {
            el.setLeft(x);
        }
    },

    /**
     * Returns position of header element by date.
     * 
     * @param {Date} date
     * 
     * @return {Number}
     */
    getHeaderElementPosition : function(date) {
        var viewModel = this.schedulerView.getTimeAxisViewModel();
        
        return Math.round(viewModel.getPositionFromDate(date));
    },
    
    
    renderBodyElementsInternal : function (records) {
        Ext.DomHelper.append(this.containerEl, this.generateMarkup(false, records));
    },
    
    
    getHeaderElementData : function(records, isPrint) {
        throw 'Abstract method call';
    },
    
    
    renderHeaderElementsInternal : function (records) {
        var containerEl = this.getHeaderContainerEl();
        
        if (containerEl) {
            Ext.DomHelper.append(containerEl, this.generateHeaderMarkup(false, records));
        }
    },
    
 
    renderElementsInternal : function() {
        this.renderElementsBuffered = false;

        // component could be destroyed during the buffering time frame
        if (this.disabled || this.schedulerView.isDestroyed) return;

        if (Ext.versions.extjs && !this.schedulerView.el.down('table')) return;

        this.removeElements();
        
        this.renderBodyElementsInternal();
        
        if (this.showHeaderElements) {
            this.headerContainerEl = null;
            this.renderHeaderElementsInternal();
        }
    },

    
    /**
     * Generates markup for elements.
     * 
     * @param {Boolean} isPrint
     * @param {Array} records
     *  
     * @return {String}
     */
    generateMarkup : function(isPrint, records) {
        var start       = this.timeAxis.getStart(),
            end         = this.timeAxis.getEnd(),
            data        = this.getElementData(start, end, records, isPrint);

        return this.template.apply(data);
    },
    
    
    /**
     * Generates markup for headers elements.
     * 
     * @param {Boolean} isPrint
     * @param {Array} records
     *  
     * @return {String}
     */
    generateHeaderMarkup : function (isPrint, records) {
        var data = this.getHeaderElementData(records, isPrint);

        return this.headerTemplate.apply(data);
    },


    getElementData : function (viewStart, viewEnd, records, isPrint) {
        throw 'Abstract method call';
    },
    
    
    updateBodyElement : function (record) {
        var el = Ext.get(this.getElementId(record));
        
        if (el) {
            var start       = this.timeAxis.getStart(), 
                end         = this.timeAxis.getEnd(),
                data        = this.getElementData(start, end, [record])[0];

            if (data) {
                // Reapply CSS classes
                el.dom.className = data.$cls;

                el.setTop(data.top);
                this.setElementX(el, data.left);
                
                el.setSize(data.width, data.height);
            } else {
                Ext.destroy(el);
            }
        } else {
            // if element is not found, then its probably a newly added record in the store
            // in this case `renderBodyElementsInternal` will only add markup for that record
            this.renderBodyElementsInternal([ record ]);
        }
    },
    
    
    updateHeaderElement : function (record) {
        var el = Ext.get(this.getHeaderElementId(record));
        
        if (el) {
            var data = this.getHeaderElementData([record])[0];

            if (data) {
                // Reapply CSS classes
                el.dom.className = data.cls;

                if (this.schedulerView.isHorizontal()) {
                    this.setElementX(el, data.position);
                    el.setWidth(data.size);
                } else {
                    el.setTop(data.position);
                    el.setHeight(data.size);
                }
            } else {
                Ext.destroy(el);
            }
        } else {
            // if element is not found, then its probably a newly added record in the store
            // in this case `renderHeaderElementsInternal` will only add markup for that record
            this.renderHeaderElementsInternal([record]);
        }
    },
    
    
    onDestroy : function() {
        clearTimeout(this._renderTimer);
        clearTimeout(this._resizeTimer);

        if (this.store.autoDestroy) {
            this.store.destroy();
        }

        this.store.un(this.storeListeners);
    },
    

    refreshSingle : function(store, record) {
        Ext.each(record, this.updateBodyElement, this);
        
        if (this.showHeaderElements) {
            Ext.each(record, this.updateHeaderElement, this);
        }
    }
}); 

/**
@class Sch.plugin.Lines
@extends Sch.feature.AbstractTimeSpan

Plugin (ptype = 'scheduler_lines') for showing "global" time lines in the scheduler grid. It uses a store to populate itself, records in this store should have the following fields:

- `Date` The date of the line. This date is formatted based on what's configured in the {@link Sch.preset.ViewPreset#displayDateFormat} option of the current "viewPreset".
- `Text` The Text to show when hovering over the line (optional)
- `Cls`  A CSS class to add to the line (optional)

To add this plugin to scheduler:

        var dayStore    = new Ext.data.Store({
            fields  : [ 'Date', 'Text', 'Cls' ],

            data    : [
                {
                    Date        : new Date(2011, 06, 19),
                    Text        : 'Some important day'
                }
            ]
        });


        var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
            ...

            resourceStore   : resourceStore,
            eventStore      : eventStore,

            plugins         : [
                Ext.create('Sch.plugin.Lines', { store : dayStore })
            ]
        });


*/
Ext.define("Sch.plugin.Lines", {
    extend      : "Sch.feature.AbstractTimeSpan",
    alias       : 'plugin.scheduler_lines',

    cls : 'sch-timeline',

    /**
     * @cfg {Boolean} showTip 'true' to include a native browser tooltip when hovering over the line.
     */
    showTip : true,

    /**
     * @cfg {String/Ext.XTemplate} innerTpl A template providing additional markup to render into each timespan element
     */
    innerTpl            : null,
    

    prepareTemplateData : null,
    side : null,

    init : function(scheduler) {
        if (Ext.isString(this.innerTpl)) {
            this.innerTpl = new Ext.XTemplate(this.innerTpl);
        }

        this.side = scheduler.rtl ? 'right' : 'left';

        var innerTpl = this.innerTpl;

        if (!this.template) {
            this.template = new Ext.XTemplate(
                '<tpl for=".">',
                    '<div id="{id}" ' + (this.showTip ? 'title="{[this.getTipText(values)]}" ' : '') + 'class="{$cls}" style="' + this.side + ':{left}px;top:{top}px;height:{height}px;width:{width}px">' +
                    (innerTpl ? '{[this.renderInner(values)]}' : '') +
                    '</div>',
                '</tpl>',
                {
                    getTipText : function (values) {
                        return scheduler.getSchedulingView().getFormattedDate(values.Date) + ' ' + (values.Text || "");
                    },

                    renderInner : function(values) {
                        return innerTpl.apply(values);
                    }
                }
            );
        }
        
        this.callParent(arguments);
    },


    getElementData : function(viewStart, viewEnd, records) {
        var s = this.store,
            scheduler = this.schedulerView,
            isHorizontal = scheduler.isHorizontal(),
            rs = records || s.getRange(),
            data = [],
            height,
            width,
            region = scheduler.getTimeSpanRegion(viewStart, null, this.expandToFitView),
            record, date, templateData;

        if (Ext.versions.touch){
            height = '100%';
        } else {
            height = isHorizontal ? region.bottom - region.top : 1;
        }

        width = isHorizontal ? 1 : region.right - region.left;

        for (var i = 0, l = rs.length; i < l; i++) {
            record = rs[i];
            date = record.get('Date');

            if (date && Sch.util.Date.betweenLesser(date, viewStart, viewEnd)) {
                var pos = scheduler.getCoordinateFromDate(date);

                templateData = Ext.apply({}, this.getTemplateData(record));
                templateData.id = this.getElementId(record);
                // using $cls to avoid possible conflict with "Cls" field in the record
                // `getElementCls` will append the "Cls" field value to the class
                templateData.$cls = this.getElementCls(record, templateData);

                templateData.width = width;
                templateData.height = height;

                if (isHorizontal) {
                    templateData.left = pos;
                } else{
                    templateData.top = pos;
                }
                data.push(templateData);
            }
        }
        
        return data;
    },
    
    
    getHeaderElementData : function(records) {
        var startDate = this.timeAxis.getStart(),
            endDate = this.timeAxis.getEnd(),
            isHorizontal = this.schedulerView.isHorizontal(),
            data = [],
            record, date, position, templateData;

        records = records || this.store.getRange();

        for (var i = 0, l = records.length; i < l; i++) {
            record = records[i];
            date = record.get('Date');
            
            if (date && Sch.util.Date.betweenLesser(date, startDate, endDate)) {
                position = this.getHeaderElementPosition(date);
                templateData = this.getTemplateData(record);
                
                data.push(Ext.apply({
                    id       : this.getHeaderElementId(record),
                    side     : isHorizontal ? this.side : 'top',
                    cls      : this.getHeaderElementCls(record, templateData),
                    position : position
                }, templateData));
            }
        }
        
        return data;
    }
    
});

/**
@class Sch.plugin.Zones
@extends Sch.feature.AbstractTimeSpan

Plugin (ptype = 'scheduler_zones') for showing "global" zones in the scheduler grid, these can by styled easily using just CSS.
To populate this plugin you need to pass it a store having `Sch.model.Range` as the model.

{@img scheduler/images/scheduler-grid-horizontal.png}

To add this plugin to scheduler:

        var zonesStore = Ext.create('Ext.data.Store', {
            model   : 'Sch.model.Range',
            data    : [
                {
                    StartDate   : new Date(2011, 0, 6),
                    EndDate     : new Date(2011, 0, 7),
                    Cls         : 'myZoneStyle'
                }
            ]
        });

        var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
            ...
    
            resourceStore   : resourceStore,
            eventStore      : eventStore,
            
            plugins         : [
                Ext.create('Sch.plugin.Zones', { store : zonesStore })
            ]
        });


*/
Ext.define("Sch.plugin.Zones", {
    extend      : "Sch.feature.AbstractTimeSpan",
    alias       : "plugin.scheduler_zones",

    requires    : [
        'Sch.model.Range'
    ],

    /**
     * @cfg {String/Ext.XTemplate} innerTpl A template providing additional markup to render into each timespan element
     */
    innerTpl            : null,

    cls                 : 'sch-zone',
    side                : null,

    
    init : function (scheduler) {
        if (Ext.isString(this.innerTpl)) {
            this.innerTpl = new Ext.XTemplate(this.innerTpl);
        }

        this.side = scheduler.rtl ? 'right' : 'left';

        var innerTpl = this.innerTpl;

        if (!this.template) {
            this.template = new Ext.XTemplate(
                '<tpl for=".">' +
                    '<div id="{id}" class="{$cls}" style="' + this.side + ':{left}px;top:{top}px;height:{height}px;width:{width}px;{style}">' +
                    (innerTpl ? '{[this.renderInner(values)]}' : '') + 
                    '</div>' +
                '</tpl>',
                {
                    renderInner : function(values) {
                        return innerTpl.apply(values);
                    }
                }
            );
        }
        
        
        if (Ext.isString(this.innerHeaderTpl)) {
            this.innerHeaderTpl = new Ext.XTemplate(this.innerHeaderTpl);
        }
        
        this.callParent(arguments);
    },

    
    getElementData : function(viewStart, viewEnd, records, isPrint) {
        var schedulerView   = this.schedulerView,
            data            = [],
            region          = schedulerView.getTimeSpanRegion(viewStart, viewEnd, this.expandToFitView),
            isHorizontal    = this.schedulerView.isHorizontal(),
            record, spanStart, spanEnd, zoneData, width, templateData;
        
        records             = records || this.store.getRange();
            
        for (var i = 0, l = records.length; i < l; i++) {
            record       = records[i];
            spanStart    = record.getStartDate();
            spanEnd      = record.getEndDate();
            templateData = this.getTemplateData(record);
            
            if (spanStart && spanEnd && Sch.util.Date.intersectSpans(spanStart, spanEnd, viewStart, viewEnd)) {
                var startPos = schedulerView.getCoordinateFromDate(Sch.util.Date.max(spanStart, viewStart));
                var endPos = schedulerView.getCoordinateFromDate(Sch.util.Date.min(spanEnd, viewEnd));

                zoneData = Ext.apply({}, templateData);

                zoneData.id = this.getElementId(record);
                // using $cls to avoid possible conflict with "Cls" field in the record
                // `getElementCls` will append the "Cls" field value to the class
                zoneData.$cls = this.getElementCls(record, templateData);

                if (isHorizontal) {
                    zoneData.left = startPos;
                    zoneData.top = region.top;

                    zoneData.width = isPrint ? 0 : endPos - startPos;
                    zoneData.height = region.bottom - region.top;

                    zoneData.style = isPrint ? ('border-left-width:' + (endPos - startPos) + 'px') : "";
                } else {
                    zoneData.left = region.left;
                    zoneData.top = startPos;

                    zoneData.height = isPrint ? 0 : endPos - startPos;
                    zoneData.width = region.right - region.left;

                    zoneData.style = isPrint ? ('border-top-width:' + (endPos - startPos) + 'px') : "";
                }

                data.push(zoneData);
            }
        }
        return data;
    },
    
        
    getHeaderElementId : function(record, isStart) {
        return this.callParent([record]) + (isStart ? '-start' : '-end');
    },
    
    
    /**
     * Return header element class for data record.
     * 
     * @param {Sch.model.Range} record Data record
     * @param {Object} data
     * @param {Boolean} isStart
     * 
     * @return {String}
     */
    getHeaderElementCls : function(record, data, isStart) {
        var clsField = record.clsField || this.clsField;
            
        if (!data) {
            data = this.getTemplateData(record);
        }
        
        return 'sch-header-indicator sch-header-indicator-' + (isStart ? 'start ' : 'end ') +
            this.uniqueCls + ' ' + (data[clsField] || '');
    },
    
    
    getZoneHeaderElementData : function(startDate, endDate, record, isStart) {
        var date = isStart ? record.getStartDate() : record.getEndDate(),
            data = null,
            position, isHorizontal, templateData;
            
        if (date && Sch.util.Date.betweenLesser(date, startDate, endDate)) {
            position     = this.getHeaderElementPosition(date);
            isHorizontal = this.schedulerView.isHorizontal();
            templateData = this.getTemplateData(record);
            
            data = Ext.apply({
                id       : this.getHeaderElementId(record, isStart),
                cls      : this.getHeaderElementCls(record, templateData, isStart),
                isStart  : isStart,
                
                side     : isHorizontal ? this.side : 'top',
                position : position
            }, templateData);
        }
        
        return data;
    },
    
    
    getHeaderElementData : function(records) {
        var startDate = this.timeAxis.getStart(),
            endDate = this.timeAxis.getEnd(),
            data = [],
            record, startData, endData;
            
        records = records || this.store.getRange();
        
        for (var i = 0, l = records.length; i < l; i++) {
            record = records[i];
            
            startData = this.getZoneHeaderElementData(startDate, endDate, record, true);
            if (startData) {
                data.push(startData);
            }
            
            endData = this.getZoneHeaderElementData(startDate, endDate, record, false);
            if (endData) {
                data.push(endData);
            }
            
        }

        return data;
    },
    
    
    updateZoneHeaderElement : function(el, data) {
        // Reapply CSS classes
        el.dom.className = data.cls;

        if (this.schedulerView.isHorizontal()) {
            this.setElementX(el, data.position);
        } else {
            el.setTop(data.position);
        }
    },
    
    
    updateHeaderElement : function(record) {
        var startDate = this.timeAxis.getStart(),
            endDate = this.timeAxis.getEnd(),
            startEl = Ext.get(this.getHeaderElementId(record, true)),
            endEl   = Ext.get(this.getHeaderElementId(record, false)),
            startData = this.getZoneHeaderElementData(startDate, endDate, record, true),
            endData   = this.getZoneHeaderElementData(startDate, endDate, record, false);
            
        if (!(startEl && endData) || !(endEl && endData)) {
            Ext.destroy(startEl, endEl);
            this.renderHeaderElementsInternal([record]);
        } else {
            if (startEl) {
                if (!startData) {
                    Ext.destroy(startEl);
                } else {
                    this.updateZoneHeaderElement(startEl, startData);
                }
            }
            
            if (endEl) {
                if (!endData) {
                    Ext.destroy(endEl);
                } else {
                    this.updateZoneHeaderElement(endEl, endData);
                }
            }
        }
    }
    
}); 

/**
@class Sch.plugin.Pan

A plugin (ptype = 'scheduler_pan') enabling panning by clicking and dragging in a scheduling view.

To add this plugin to your scheduler or gantt view:

        var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
            ...

            resourceStore   : resourceStore,
            eventStore      : eventStore,

            plugins         : [
                Ext.create('Sch.plugin.Pan', { enableVerticalPan : true })
            ]
        });
*/
Ext.define("Sch.plugin.Pan", {
    extend        : 'Ext.AbstractPlugin',
    alias         : 'plugin.scheduler_pan',
    lockableScope : 'top',

    /**
     * @cfg {Boolean} enableVerticalPan
     * True to allow vertical panning
     */
    enableVerticalPan : true,

    statics : {
        /**
         * @cfg {Number} KEY_SHIFT Constant for shift key
         */
        KEY_SHIFT : 1,

        /**
         * @cfg {Number} KEY_CTRL Constant for ctrl / meta key
         */
        KEY_CTRL  : 2,

        /**
         * @cfg {Number} KEY_ALT Constant for alt key
         */
        KEY_ALT   : 4,

        /**
         * @cfg {Number} KEY_ALL Constant for all modifier keys (shift, ctrl / meta, alt)
         */
        KEY_ALL   : 7
    },

    /**
     * @cfg {Number} disableOnKey Specifies which key should be pressed to disable panning.
     * See {@link #KEY_SHIFT}, {@link #KEY_CTRL}, {@link #KEY_ALT}, {@link #KEY_ALL}.
     * For example to disable panning when shift or ctrl is pressed:

        Ext.create('Sch.plugin.Pan', {
            disableOnKey : Sch.plugin.Pan.KEY_SHIFT + Sch.plugin.Pan.KEY_CTRL
        })

     */
    disableOnKey : 0,

    panel : null,

    constructor : function (config) {
        Ext.apply(this, config);
    },

    init : function (pnl) {
        this.panel = pnl.normalGrid || pnl;
        this.view = pnl.getSchedulingView();

        this.view.on('afterrender', this.onRender, this);
    },

    onRender : function (s) {
        this.view.el.on('mousedown', this.onMouseDown, this);
    },

    onMouseDown : function (e, t) {
        var self = this.self,
            disableOnKey = this.disableOnKey;

        // Ignore event if #disableOnKey is specified and at least one of the
        // functional keys is pressed
        if ((e.shiftKey && (disableOnKey & self.KEY_SHIFT)) ||
            (e.ctrlKey && (disableOnKey & self.KEY_CTRL)) ||
            (e.altKey && (disableOnKey & self.KEY_ALT))) {
            return;
        }

        // ignore clicks on tasks and events
        if (e.getTarget('.' + this.view.timeCellCls, 10) && !e.getTarget(this.view.eventSelector)) {
            this.mouseX = e.getPageX();
            this.mouseY = e.getPageY();
            Ext.getBody().on('mousemove', this.onMouseMove, this);
            Ext.getDoc().on('mouseup', this.onMouseUp, this);

            // For IE (and FF if using frames), if you move mouse onto the browser chrome and release mouse button
            // we won't know about it. Next time mouse enters the body, cancel any ongoing pan activity as a fallback.
            if (Ext.isIE || Ext.isGecko) {
                Ext.getBody().on('mouseenter', this.onMouseUp, this);
            }

            // required for some weird chrome bug/behavior, when whole panel was scrolled-out
            e.stopEvent();
        }
    },

    onMouseMove : function (e) {
        e.stopEvent();

        var x = e.getPageX(),
            y = e.getPageY(),
            xDelta = x - this.mouseX,
            yDelta = y - this.mouseY;

        this.panel.scrollByDeltaX(-xDelta);
        this.mouseX = x;
        this.mouseY = y;

        if (this.enableVerticalPan) {
            this.panel.scrollByDeltaY(-yDelta);
        }
    },

    onMouseUp : function (e) {
        Ext.getBody().un('mousemove', this.onMouseMove, this);
        Ext.getDoc().un('mouseup', this.onMouseUp, this);

        if (Ext.isIE || Ext.isGecko) {
            Ext.getBody().un('mouseenter', this.onMouseUp, this);
        }
    }
});

/**
 * @class Sch.tooltip.ClockTemplate
 * @private
 * Template showing a clock, accepts an object containing a 'date' and a 'text' property to its apply method.
 * @constructor
 * @param {Object} config The object containing the configuration of this model.
 **/
Ext.define("Sch.tooltip.ClockTemplate", {

    constructor : function() {
        var toRad = Math.PI / 180,
            cos = Math.cos,
            sin = Math.sin,
            minuteHeight = 7,
            minuteTop = 2,
            minuteLeft = 10,
            hourHeight = 6,
            hourTop = 3,
            hourLeft = 10,
            isLegacyIE = Ext.isIE && (Ext.ieVersion < 9 || Ext.isIEQuirks);

        function getHourStyleIE(degrees) {
            var rad = degrees * toRad,
                cosV = cos(rad),
                sinV = sin(rad),
                y = hourHeight * sin((90-degrees)*toRad),
                x =hourHeight * cos((90-degrees)*toRad),
                topAdjust = Math.min(hourHeight, hourHeight - y),
                leftAdjust = degrees > 180 ? x : 0,
                matrixString = "progid:DXImageTransform.Microsoft.Matrix(sizingMethod='auto expand', M11 = " + cosV + ", M12 = " + (-sinV) + ", M21 = " + sinV + ", M22 = " + cosV + ")";
        
            return Ext.String.format("filter:{0};-ms-filter:{0};top:{1}px;left:{2}px;", matrixString, topAdjust+hourTop, leftAdjust+hourLeft);
        }

        function getMinuteStyleIE(degrees) {
            var rad = degrees * toRad,
                cosV = cos(rad),
                sinV = sin(rad),
                y = minuteHeight * sin((90-degrees)*toRad),
                x = minuteHeight * cos((90-degrees)*toRad),
                topAdjust = Math.min(minuteHeight, minuteHeight - y),
                leftAdjust = degrees > 180 ? x : 0,
                matrixString = "progid:DXImageTransform.Microsoft.Matrix(sizingMethod='auto expand', M11 = " + cosV + ", M12 = " + (-sinV) + ", M21 = " + sinV + ", M22 = " + cosV + ")";
        
            return Ext.String.format("filter:{0};-ms-filter:{0};top:{1}px;left:{2}px;", matrixString, topAdjust+minuteTop, leftAdjust+minuteLeft);
        }

        function getStyle(degrees) {
            return Ext.String.format("transform:rotate({0}deg);-ms-transform:rotate({0}deg);-moz-transform: rotate({0}deg);-webkit-transform: rotate({0}deg);-o-transform:rotate({0}deg);", degrees);
        }

        return new Ext.XTemplate(
            '<div class="sch-clockwrap {cls}">' +
                '<div class="sch-clock">' +
                    '<div class="sch-hourIndicator" style="{[this.getHourStyle((values.date.getHours()%12) * 30)]}">{[Ext.Date.monthNames[values.date.getMonth()].substr(0,3)]}</div>' +
                    '<div class="sch-minuteIndicator" style="{[this.getMinuteStyle(values.date.getMinutes() * 6)]}">{[values.date.getDate()]}</div>' +
                '</div>' +
                '<span class="sch-clock-text">{text}</span>' +
            '</div>',
            {
                compiled : true,
                disableFormats : true,

                getMinuteStyle : isLegacyIE ? getMinuteStyleIE : getStyle,
                getHourStyle : isLegacyIE ? getHourStyleIE : getStyle
            }
        );
    } 
});

/**
@class "Sch.tooltip.Tooltip"
@extends Ext.ToolTip
@private

Internal plugin showing a tooltip with event start/end information.
*/
Ext.define("Sch.tooltip.Tooltip", {
    extend : "Ext.tip.ToolTip",
    requires : [
        'Sch.tooltip.ClockTemplate'
    ],
    autoHide            : false,
    anchor              : 'b',
    padding             : '0 3 0 0',
    showDelay           : 0,
    hideDelay           : 0,
    quickShowInterval   : 0,
    dismissDelay        : 0,
    trackMouse          : false,
    valid               : true,
    anchorOffset        : 5,
    shadow              : false,
    frame               : false,

    constructor : function(config) {
        var clockTpl = Ext.create("Sch.tooltip.ClockTemplate");
        this.renderTo = document.body;
        this.startDate = this.endDate = new Date();

        if (!this.template) {
            this.template = Ext.create("Ext.XTemplate",
                '<div class="{[values.valid ? "sch-tip-ok" : "sch-tip-notok"]}">',
                   '{[this.renderClock(values.startDate, values.startText, "sch-tooltip-startdate")]}',
                   '{[this.renderClock(values.endDate, values.endText, "sch-tooltip-enddate")]}',
                '</div>',
                {
                    compiled : true,
                    disableFormats : true,

                    renderClock : function(date, text, cls) {
                        return clockTpl.apply({
                            date : date, 
                            text : text,
                            cls : cls
                        });
                    }
                }
            );
        }

        this.callParent(arguments);
    },

    update : function(startDate, endDate, valid) {

        if (this.startDate - startDate !== 0 ||
            this.endDate - endDate !== 0 ||
            this.valid !== valid) {
            
            // This will be called a lot so cache the values
            this.startDate = startDate;
            this.endDate = endDate;
            this.valid = valid;
            var startText = this.schedulerView.getFormattedDate(startDate),
                endText = this.schedulerView.getFormattedEndDate(endDate, startDate);

            // If resolution is day or greater, and end date is greater then start date
            if (this.mode === 'calendar' && endDate.getHours() === 0 && endDate.getMinutes() === 0 && 
                !(endDate.getYear() === startDate.getYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() === startDate.getDate())) {
                endDate = Sch.util.Date.add(endDate, Sch.util.Date.DAY, -1);
            }
        
            this.callParent([
                this.template.apply({
                    valid       : valid,
                    startDate   : startDate,
                    endDate     : endDate,
                    startText   : startText,
                    endText     : endText
                })
            ]);
        }
    },
     
    show : function(el, xOffset) {
        if (!el) {
            return;
        }

        if (Sch.util.Date.compareUnits(this.schedulerView.getTimeResolution().unit, Sch.util.Date.DAY) >= 0) {
            this.mode = 'calendar';
            this.addCls('sch-day-resolution');
        } else {
            this.mode = 'clock';
            this.removeCls('sch-day-resolution');
        }
        this.mouseOffsets = [xOffset - 18, -7];
        
        this.setTarget(el);
        this.callParent();
        this.alignTo(el, 'bl-tl', this.mouseOffsets);

        this.mon(Ext.getDoc(), 'mousemove', this.onMyMouseMove, this);
        this.mon(Ext.getDoc(), 'mouseup', this.onMyMouseUp, this, { single : true });
    },

    onMyMouseMove : function() {
        this.el.alignTo(this.target, 'bl-tl', this.mouseOffsets);
    },

    onMyMouseUp : function() {
        this.mun(Ext.getDoc(), 'mousemove', this.onMyMouseMove, this);
    },

    afterRender : function() {
        this.callParent(arguments);

        // In slower browsers, the mouse pointer may end up over the tooltip interfering with drag drop etc
        this.el.on('mouseenter', this.onElMouseEnter, this);
    },

    onElMouseEnter : function() {
        this.alignTo(this.target, 'bl-tl', this.mouseOffsets);
    }
}); 

/**
* @class Sch.view.model.TimeAxis
* @extends Ext.util.Observable
* @private
*
* This class is an internal view model class, describing the visual representation of a {@link Sch.data.TimeAxis timeaxis}.
* The config for the header rows is described in the {@link Sch.preset.ViewPreset#headerConfig headerConfig}.
* To calculate the widths of each cell in the time axis, this class requires:
*     * availableWidth  - The total width available for the rendering
*     * tickWidth     - The fixed width of each cell in the lowest header row. This value is normally read from the 
*                         {@link Sch.preset.ViewPreset viewPreset} but this can also be updated programmatically using {@link #setTickWidth}
*
* Normally you should not interact with this class directly.
*/
Ext.define("Sch.view.model.TimeAxis", {
    extend: 'Ext.util.Observable',

    requires: [
        'Ext.Date',
        'Sch.util.Date'
    ],

    /**
     * @cfg {Sch.data.TimeAxis} timeAxis
     * The time axis providing the underlying data to be visualized
     */
    timeAxis        : null,

    /**
     * @cfg {Int} availableWidth
     * The available width, this is normally not known by the consuming UI component using this model class until it has been fully rendered.
     * The consumer of this model should call {@link setAvailableWidth} when its width has changed.
     */
    availableWidth  : 0,

    /**
     * @cfg {Int} tickWidth
     * The "tick width" to use for the cells in the bottom most header row.
     * This value is normally read from the {@link Sch.preset.ViewPreset viewPreset}
     */
    tickWidth     : 100,

    /**
     * @cfg {Boolean} snapToIncrement
     * true if there is a requirement to be able to snap events to a certain view resolution.
     * This has implications of the {@link #tickWidth} that can be used, since all widths must be in even pixels.
     */
    snapToIncrement : false,
    
    /**
     * @cfg {Boolean} forceFit
     * true if cells in the bottom-most row should be fitted to the {@link #availableWidth available width}.
     */
    forceFit        : false,

    //used for Exporting. Make sure the tick columns are not recalculated when resizing.
    suppressFit : false,

    // Since this model may be shared by multiple synced timelinePanels, we need to keep count of usage to know when we can destroy the view model.
    refCount     : 0,

    // cache of the config currently used.
    columnConfig    : {},

    constructor: function (config) {
        var me = this;
        Ext.apply(this, config);

        me.addEvents(
            /**
            * @event update
            * Fires after the model has been updated.
            * @param {Sch.view.model.TimeAxis} model The model instance
            */
            'update'
        );
        
        if (me.timeAxis.preset) {
            // Time axis already configured, initialize using its values
            me.tickWidth = me.timeAxis.preset.timeColumnWidth;
        }

        // When time axis is changed, reconfigure the model
        me.timeAxis.on('reconfigure', me.onTimeAxisReconfigure, me);

        this.callParent(arguments);
    },

    destroy : function() {
        this.timeAxis.un('reconfigure', this.onTimeAxisReconfigure, this);
    },

    onTimeAxisReconfigure: function (timeAxis, presetChanged) {

        if (presetChanged) {
            this.setTickWidth(timeAxis.preset.timeColumnWidth);
        } else {
            this.update();
        }
    },

    /**
    *  Returns a model object of the current timeAxis, containing an array representing the cells for each level in the header. 
    *  This object will always contain a 'middle' array, and depending on the {@link Sch.preset.ViewPreset#headerConfig} it can also contain a 'top' and 'bottom' property.
    *  @return {Object} The model representing each cell (with start date and end date) in the timeline representation.
    */
    getColumnConfig : function() {
        return this.columnConfig;
    },

    /**
    *  Updates the view model current timeAxis configuration and available width.
    *  @param {Int} availableWidth The available width for the rendering of the axis (used in forceFit mode)
    */
    update: function (availableWidth, suppressEvent) {
        var timeAxis = this.timeAxis,
            headerConfig = timeAxis.headerConfig;

        this.availableWidth = Math.max(availableWidth || this.availableWidth, 0);

        if (this.forceFit && this.availableWidth <= 0) {
            // No point in continuing
            return;
        }

        this.columnConfig = {};
        
        // Generate the underlying date ranges for each header row, which will provide input to the cell rendering
        for (var pos in headerConfig) {
            if (headerConfig[pos].cellGenerator) {
                this.columnConfig[pos] = headerConfig[pos].cellGenerator.call(this, this.timeAxis.getStart(), this.timeAxis.getEnd());
            } else {
                this.columnConfig[pos] = this.createHeaderRow(pos, headerConfig[pos]);
            }
        }
        
        var lowestHeader = this.columnConfig.bottom || this.columnConfig.middle;

        // The "column width" is considered to be the width of each tick in the lowest header row and this width 
        // has to be same for all cells in the lowest row.
        this.tickWidth = this.calculateTickWidth(this.getTickWidth());
        
        if (!Ext.isNumber(this.availableWidth) || this.availableWidth < 0) {
            throw 'Invalid available width provided to Sch.view.model.TimeAxis';
        }

        if (!Ext.isNumber(this.tickWidth) || this.tickWidth <= 0) {
            throw 'Invalid column width calculated in Sch.view.model.TimeAxis';
        }

        if (!suppressEvent) {
            this.fireEvent('update', this);
        }
    },

    // private
    createHeaderRow: function (position, headerConfig) {
        var cells   = [],
            me      = this,
            colConfig,
            align   = headerConfig.align,
            today   = Ext.Date.clearTime(new Date());

        me.timeAxis.forEachInterval(position, function (start, end, i) {
            colConfig = {
                align       : align,
                start       : start,
                end         : end,
                headerCls   : ''
            };

            if (headerConfig.renderer) {
                colConfig.header = headerConfig.renderer.call(headerConfig.scope || me, start, end, colConfig, i);
            } else {
                colConfig.header = Ext.Date.format(start, headerConfig.dateFormat);
            }

            // To be able to style individual day cells, weekends or other important days
            if (headerConfig.unit === Sch.util.Date.DAY && (!headerConfig.increment || headerConfig.increment === 1)) {
                colConfig.headerCls += ' sch-dayheadercell-' + start.getDay();

                if (Ext.Date.clearTime(start, true) - today === 0) {
                    colConfig.headerCls += ' sch-dayheadercell-today';
                }
            }

            cells.push(colConfig);
        });

        return cells;
    },

    /**
    *  Returns the distance for a timespan with the given start and end date.
    *  @return {Int} The width of the time span
    */
    getDistanceBetweenDates: function (start, end) {
        var baseUnit = this.timeAxis.unit,
            width,
            measuringUnit = Sch.util.Date.getMeasuringUnit(baseUnit),
            durationInMeasuringUnit = Sch.util.Date.getDurationInUnit(start, end, measuringUnit);

        if (this.timeAxis.isContinuous()) {
            width = durationInMeasuringUnit * this.getSingleUnitInPixels(measuringUnit);
        } else {
            width = this.getPositionFromDate(end) - this.getPositionFromDate(start);
        }

        return width;
    },

    /**
     *  Gets the position of a date on the projected time axis or -1 if the date is not in the timeAxis.
     *  @param {Date} date, the date to query for.
     *  @returns {Int} the coordinate representing the date
     */
    getPositionFromDate: function (date) {
        var pos = -1,
            tick = this.timeAxis.getTickFromDate(date);

        if (tick >= 0) {
            pos = this.tickWidth * tick;
        }

        return pos;
    },

    /**
     * Gets the date for a position on the time axis
     * @param {Int} position The page X or Y coordinate
     * @param {String} roundingMethod The rounding method to use
     * @returns {Date} the Date corresponding to the xy coordinate
     */
    getDateFromPosition: function (position, roundingMethod) {
        var tick = position / this.getTickWidth(),
            nbrTicks = this.timeAxis.getCount();

        if (tick < 0 || tick > nbrTicks) {
            return null;
        }

        return this.timeAxis.getDateFromTick(tick, roundingMethod);
    },

    /**
    * Returns the amount of pixels for a single unit
    * @private
    * @return {String} The unit in pixel
    */
    getSingleUnitInPixels: function (unit) {
        return Sch.util.Date.getUnitToBaseUnitRatio(this.timeAxis.getUnit(), unit) * this.tickWidth / this.timeAxis.increment;
    },

    /**
     * [Experimental] Returns the pixel increment for the current view resolution.
     * @return {Int} The width increment
     */
    getSnapPixelAmount: function () {
        if (this.snapToIncrement) {
            var resolution = this.timeAxis.getResolution();
            return (resolution.increment || 1) * this.getSingleUnitInPixels(resolution.unit);
        } else {
            return 1;
        }
    },

    /**
    * Returns the current time column width (the width of a cell in the lowest header row)
    * @return {Int} The width
    */
    getTickWidth: function () {
        return this.tickWidth;
    },

    /**
    * Sets a new tick width (the width of a time cell in the bottom-most time axis row)
    * @param {Int} width The width
    */
    setTickWidth: function (width, suppressEvent) {
        this.tickWidth = width;

        this.update(null, suppressEvent);
    },

    /**
    * Returns the total width of the time axis representation.
    * @return {Int} The width
    */
    getTotalWidth: function () {
        return this.tickWidth * this.timeAxis.getCount();
    },

    // Calculates the time column width based on the value defined viewPreset "timeColumnWidth". It also checks for the forceFit view option
    // and the snapToIncrement, both of which impose constraints on the time column width configuration.
    calculateTickWidth: function (proposedWidth) {
        var forceFit = this.forceFit;
        
        var width = 0,
            timelineUnit = this.timeAxis.getUnit(),
            nbrTimeColumns = this.timeAxis.getCount(),
            ratio = Number.MAX_VALUE,
            measuringUnit, fittingWidth;

        if (this.snapToIncrement) {
            var res = this.timeAxis.getResolution(),
                unit = res.unit,
                resIncr = res.increment;

            ratio = Sch.util.Date.getUnitToBaseUnitRatio(timelineUnit, unit) * resIncr;
        }

        measuringUnit = Sch.util.Date.getMeasuringUnit(timelineUnit);

        ratio = Math.min(ratio, Sch.util.Date.getUnitToBaseUnitRatio(timelineUnit, measuringUnit));

        fittingWidth = Math[forceFit ? 'floor' : 'round'](this.getAvailableWidth() / this.timeAxis.getCount());

        if (!this.suppressFit){
            width = (forceFit || proposedWidth < fittingWidth) ? fittingWidth : proposedWidth;
            
            if (ratio > 0 && (!forceFit || ratio < 1)) {
                width = Math.round(Math.max(1, Math[forceFit ? 'floor' : 'round'](ratio * width)) / ratio);
            }
        } else {
            width = proposedWidth;
        }

        return width;
    },

    /**
    * Returns the available width for the time axis representation.
    * @return {Int} The available width
    */
    getAvailableWidth: function () {
        return this.availableWidth;
    },

    /**
    * Sets the available width for the model, which (if changed) will cause it to update its contents and fire the {@link #update} event.
    * @param {Int} width The width
    */
    setAvailableWidth: function (width) {
        this.availableWidth = Math.max(0, width);

        var newTickWidth = this.calculateTickWidth(this.tickWidth);

        if (newTickWidth !== this.tickWidth) {
            this.setTickWidth(newTickWidth);
        }
    },

    /**
     * This function fits the time columns into the available space in the time axis column.
     * @param {Boolean} suppressEvent `true` to skip firing the 'update' event.
     */
    fitToAvailableWidth: function (suppressEvent) {
        var proposedWidth   = Math.floor(this.availableWidth / this.timeAxis.getCount());

        this.setTickWidth(proposedWidth, suppressEvent);
    },

    /**
    * Sets the forceFit value for the model, which will cause it to update its contents and fire the {@link #update} event.
    * @param {Boolean} value 
    */
    setForceFit: function (value) {
        if (value !== this.forceFit) {
            this.forceFit = value;
            this.update();
        }
    },

    /**
    * Sets the snapToIncrement value for the model, which will cause it to update its contents and fire the {@link #update} event.
    * @param {Boolean} value 
    */
    setSnapToIncrement: function (value) {
        if (value !== this.snapToIncrement) {
            this.snapToIncrement = value;
            this.update();
        }
    }
});



/**
* @class Sch.view.HorizontalTimeAxis
* @extends Ext.util.Observable
* @private
*
* A visual representation of the time axis described in the {@link Sch.preset.ViewPreset#headerConfig headerConfig}. 
* Normally you should not interact with this class directly.
*/
Ext.define("Sch.view.HorizontalTimeAxis", {
    extend: 'Ext.util.Observable',

    requires: [
        'Ext.XTemplate'
    ],

    /**
    * @cfg {Boolean} trackHeaderOver `true` to highlight each header cell when the mouse is moved over it. 
    */
    trackHeaderOver: true,

    /**
    * @cfg {Int} compactCellWidthThreshold The minimum width for a bottom row header cell to be considered 'compact', which adds a special CSS class to the row (for special styling). 
    *            Defaults to 15px.
    */
    compactCellWidthThreshold: 15,

    baseCls : 'sch-column-header',
    tableCls : 'sch-header-row',

    // a 2nd template for the 2nd mode, w/o `containerEl`
    headerHtmlRowTpl:
        '<table border="0" cellspacing="0" cellpadding="0" style="width: {totalWidth}px; {tstyle}" class="{{tableCls}} sch-header-row-{position} {cls}">' +
            '<thead>' +
                '<tr>' +
                    '<tpl for="cells">' +
                        '<td class="{{baseCls}} {headerCls}" style="position : static; text-align: {align}; width: {width}px; {style}" tabIndex="0"' +
                            'headerPosition="{parent.position}" headerIndex="{[xindex-1]}">' +
                                '<div class="sch-simple-timeheader">{header}</div>' +
                        '</td>' +
                    '</tpl>' +
                '</tr>' +
            '</thead>' +
        '</table>',
        
    // TODO DOCS
    model           : null,

    // TODO DOCS
    hoverCls        : '',
    
    // optional
    // this view class will work in 2 modes - one with provided `containerEl` and one w/o it
    containerEl     : null,

    // Only used for IE10 in Touch Scheduler since display:box is too buggy in IE.
    height : null,

    constructor: function (config) {
        var me = this;
        var isTouch = !!Ext.versions.touch;
        var clickEventName = isTouch ? 'tap' : 'click';

        Ext.apply(this, config);
        me.callParent(arguments);

        me.model.on({
            update  : me.onModelUpdate,
            scope   : me
        });

        this.addEvents(
            /** 
            * @event refresh
            * Fires after the view has been updated, (after the time axis has been reconfigured,
            * or as a result of time column width change or available schedule width change).
            * @param {Sch.view.HorizontalTimeAxis} timeAxisView The time axis view
            */
            'refresh'
        );

        me.containerEl = Ext.get(me.containerEl);

        if (!(me.headerHtmlRowTpl instanceof Ext.Template)) {
            me.headerHtmlRowTpl = me.headerHtmlRowTpl.replace('{{baseCls}}', this.baseCls).replace('{{tableCls}}', this.tableCls);
            me.headerHtmlRowTpl = new Ext.XTemplate(me.headerHtmlRowTpl);
        }

        if (me.trackHeaderOver && me.hoverCls) {
            me.containerEl.on({
                mousemove   : me.highlightCell,
                delegate    : '.sch-column-header',
                scope       : me
            });

            me.containerEl.on({
                mouseleave  : me.clearHighlight,
                scope       : me
            });
        }

        var listenerCfg = {
            scope       : this, 
            delegate    : '.sch-column-header'
        };

        if (isTouch) {
            listenerCfg.tap = this.onElClick('tap');
            listenerCfg.doubletap = this.onElClick('doubletap');
            this.addEvents(
                'timeheadertap',
                'timeheaderdoubletap'
            );
        } else {
            listenerCfg.click = this.onElClick('click');
            listenerCfg.dblclick = this.onElClick('dblclick');

            this.addEvents(
                'timeheaderclick',
                'timeheaderdblclick'
            );
        }

        me._listenerCfg = listenerCfg;
        if (me.containerEl) me.containerEl.on(listenerCfg);
    },

    destroy : function() {
        var me = this;
        
        if (me.containerEl) { 
            me.containerEl.un(me._listenerCfg);
            
            me.containerEl.un({
                mousemove: me.highlightCell,
                delegate: '.sch-simple-timeheader',
                scope: me
            });
    
            me.containerEl.un({
                mouseleave: me.clearHighlight,
                scope: me
            });
        }

        me.model.un({
            update  : me.onModelUpdate,
            scope   : me
        });
    },

    onModelUpdate: function () {
        this.render();
    },
    
    
    getHTML : function (header, meta, column) {
        var columnConfig        = this.model.getColumnConfig();
        var totalWidth          = this.model.getTotalWidth();
        var nbrRows             = Ext.Object.getKeys(columnConfig).length;
        var rowHeight           = this.height ? this.height / nbrRows : 0;
        var html                = '';
        
        var currentCellWidth;
        
        if (columnConfig.top) {
            this.embedCellWidths(columnConfig.top);
            
            html                += this.headerHtmlRowTpl.apply({
                totalWidth      : totalWidth,
                cells           : columnConfig.top,
                position        : 'top',
                tstyle          : 'border-top : 0;' + (rowHeight ?  'height:' + rowHeight + 'px' : '')
            });
        }
        
        if (columnConfig.middle) {
            this.embedCellWidths(columnConfig.middle);

            html                += this.headerHtmlRowTpl.apply({
                totalWidth      : totalWidth,
                cells           : columnConfig.middle,
                position        : 'middle',
                tstyle          : (columnConfig.top ? '' : 'border-top : 0;') + (rowHeight ?  'height:' + rowHeight + 'px' : ''),
                cls             : !columnConfig.bottom && this.model.getTickWidth() <= this.compactCellWidthThreshold ? 'sch-header-row-compact' : ''
            });
        }
        
        if (columnConfig.bottom) {
            this.embedCellWidths(columnConfig.bottom);
            
            html                += this.headerHtmlRowTpl.apply({
                totalWidth      : totalWidth,
                cells           : columnConfig.bottom,
                position        : 'bottom',
                tstyle          : (rowHeight ? 'height:' + rowHeight + 'px' : ''),
                cls             : this.model.getTickWidth() <= this.compactCellWidthThreshold ? 'sch-header-row-compact' : ''
            });
        }

        return html + '<div class="sch-header-secondary-canvas"></div>';
    },
    

    // Outputs the tables and cells based on the header row config in the active viewPreset
    render: function () {
        if (!this.containerEl) return;
        
        var innerCt     = this.containerEl,
            ctDom       = innerCt.dom,
            oldDisplay  = ctDom.style.display,
            columnConfig = this.model.getColumnConfig(),
            parent      = ctDom.parentNode;

        ctDom.style.display = 'none';
        parent.removeChild(ctDom);

        var renderData = this.getHTML();

        ctDom.innerHTML = renderData;

        if (!columnConfig.top && !columnConfig.middle) {
            this.containerEl.addCls('sch-header-single-row');
        } else {
            this.containerEl.removeCls('sch-header-single-row');
        }

        parent && parent.appendChild(ctDom);
        ctDom.style.display = oldDisplay;
        
        this.fireEvent('refresh', this);
    },

    embedCellWidths : function (cells) {
        // For desktop only, flags such as Ext.isSafari only exist in Ext JS (in touch it's set in Ext.os)
        var widthAdjust     = (Ext.isIE7 || Ext.isSafari) ? 1 : 0;

        for (var i = 0; i < cells.length; i++) {
            var cell        = cells[ i ];
            var width       = this.model.getDistanceBetweenDates(cell.start, cell.end);
            
            if (width) {
                cell.width  = width - (i ? widthAdjust : 0);
            } else {
                cell.width  = 0;
                cell.style  = 'display: none';
            }
        }
    },
    

    // private
    onElClick: function(eventName) {
        return function (event, target) { 
            // Normalize ST vs Ext JS (Ext passes the delegated target as the target argument, ST passes the clicked DOM node)
            target = event.delegatedTarget || target;
            
            var position        = Ext.fly(target).getAttribute('headerPosition'),
                index           = Ext.fly(target).getAttribute('headerIndex'),
                headerConfig    = this.model.getColumnConfig()[position][index];
        
            this.fireEvent('timeheader' + eventName, this, headerConfig.start, headerConfig.end, event);
        };
    },


    highlightCell: function (e, cell) {
        var me = this;

        if (cell !== me.highlightedCell) {
            me.clearHighlight();
            me.highlightedCell = cell;
            Ext.fly(cell).addCls(me.hoverCls);
        }
    },

    clearHighlight: function () {
        var me = this,
            highlighted = me.highlightedCell;

        if (highlighted) {
            Ext.fly(highlighted).removeCls(me.hoverCls);
            delete me.highlightedCell;
        }
    }
    /* EOF Proxied model methods */
});



/*
 * @class Sch.column.timeAxis.Horizontal
 * @extends Ext.grid.column.Column
 * @private
 *
 * A simple grid column providing a visual representation of the time axis. This class does not produce any real Ext JS grid columns, instead it just renders a Sch.view.HorizontalTimeAxis inside its element.
 * This class can represent up to three different axes, that are defined in the view preset config object. 
 */
Ext.define("Sch.column.timeAxis.Horizontal", {
    extend          : 'Ext.grid.column.Column',
    alias           : 'widget.timeaxiscolumn',
    
    draggable       : false,
    groupable       : false,
    hideable        : false,
    sortable        : false,
    fixed           : true,
    menuDisabled    : true,
    cls             : 'sch-simple-timeaxis',
    tdCls           : 'sch-timetd',
    enableLocking   : false,

    requires        : [
        'Sch.view.HorizontalTimeAxis'
    ],


    timeAxisViewModel           : null,
    headerView      : null,
    hoverCls : 'sch-column-header-over',

    /**
     * @cfg {Boolean} trackHeaderOver `true` to highlight each header cell when the mouse is moved over it. 
     */
    trackHeaderOver         : true,

    /**
     * @cfg {Int} compactCellWidthThreshold The minimum width for a bottom row header cell to be considered 'compact', which adds a special CSS class     *            to the row. 
     *            Defaults to 15px.
     */
    compactCellWidthThreshold : 20,

    initComponent : function() {
        // Keep this and use for our own cell hover functionality.
        this.ownHoverCls = this.hoverCls;

        // We do not want the default hover cls to be added to container column TD.
        this.hoverCls = '';

        this.callParent(arguments);
    },


    afterRender : function() {
        var me = this;

        me.headerView = new Sch.view.HorizontalTimeAxis({
            model                       : me.timeAxisViewModel,
            containerEl                 : me.titleEl,
            hoverCls                    : me.ownHoverCls,
            trackHeaderOver             : me.trackHeaderOver,
            compactCellWidthThreshold   : me.compactCellWidthThreshold
        });

        me.headerView.on('refresh', me.onTimeAxisViewRefresh, me);
        
        me.ownerCt.on('afterlayout', function() {
            // If the container of this column changes size, we need to re-evaluate the size for the
            // time axis view
            me.mon(me.ownerCt, "resize", me.onHeaderContainerResize, me );

            if (this.getWidth() > 0) {
                me.timeAxisViewModel.update(me.getAvailableWidthForSchedule());
                me.setWidth(me.timeAxisViewModel.getTotalWidth());
            }
        }, null, { single : true });

        this.enableBubble('timeheaderclick', 'timeheaderdblclick');

        me.relayEvents(me.headerView, [
            'timeheaderclick',
            'timeheaderdblclick'
        ]);
        
        me.callParent(arguments);
    },

    initRenderData: function() {
        var me = this;
        me.renderData.headerCls = me.renderData.headerCls || me.headerCls;
        return me.callParent(arguments);
    },

    destroy : function() {
        if (this.headerView) {
            this.headerView.destroy();
        }
        this.callParent(arguments);
    },

    onTimeAxisViewRefresh : function() {
        // Make sure we don't create an infinite loop
        this.headerView.un('refresh', this.onTimeAxisViewRefresh, this);

        this.setWidth(this.timeAxisViewModel.getTotalWidth());

        this.headerView.on('refresh', this.onTimeAxisViewRefresh, this);
    },

    getAvailableWidthForSchedule : function() {
        var available   = this.ownerCt.getWidth();
        var items       = this.ownerCt.items;
        
        // substracting the widths of all columns starting from 2nd ("right" columns)
        for (var i = 1; i < items.length; i++) {
            available -= items.get(i).getWidth();
        }
            
        return available - Ext.getScrollbarSize().width - 1;
    },

    onResize: function () {
        this.callParent(arguments);
        this.timeAxisViewModel.setAvailableWidth(this.getAvailableWidthForSchedule());
    },

    onHeaderContainerResize: function () {
        this.timeAxisViewModel.setAvailableWidth(this.getAvailableWidthForSchedule());
        this.headerView.render();
    }
});



/**
 * @class Sch.mixin.Lockable
 * @extends Ext.grid.locking.Lockable.
 * @private
 * This is a private class for internal use.
 */
Ext.define('Sch.mixin.Lockable', {
    extend                      : 'Ext.grid.locking.Lockable',
    
    useSpacer                   : true,

    syncRowHeight               : false,
    
    horizontalScrollForced      : false,

    // overridden
    // @OVERRIDE
    injectLockable: function () {

        var me          = this;
        var isTree      = Ext.data.TreeStore && me.store instanceof Ext.data.TreeStore;

        var eventSelModel = me.getEventSelectionModel ? me.getEventSelectionModel() : me.getSelectionModel();

        // Make local copies of these configs in case someone puts them on the prototype of a subclass.
        me.lockedGridConfig = Ext.apply({}, me.lockedGridConfig || {});
        me.normalGridConfig = Ext.apply({}, me.schedulerConfig || me.normalGridConfig || {});

        if (me.lockedXType) {
            me.lockedGridConfig.xtype = me.lockedXType;
        }

        if (me.normalXType) {
            me.normalGridConfig.xtype = me.normalXType;
        }

        var lockedGrid = me.lockedGridConfig,
            normalGrid = me.normalGridConfig;

        // Configure the child grids
        Ext.applyIf(me.lockedGridConfig, {
            useArrows           : true,
            trackMouseOver      : false,
            split               : true,
            animCollapse        : false,
            collapseDirection   : 'left',
            region              : 'west'
        });

        Ext.applyIf(me.normalGridConfig, {
            viewType            : me.viewType,

            layout              : 'fit',

            sortableColumns     : false,
            enableColumnMove    : false,
            enableColumnResize  : false,
            enableColumnHide    : false,

            /* @COMPAT 2.2 */
            getSchedulingView   : function() {
                var con = typeof console !== "undefined" ? console : false;

                if (con && con.log) con.log('getSchedulingView is deprecated on the inner grid panel. Instead use getView on the "normal" subgrid.');

                return this.getView();
            },

            selModel            : eventSelModel,

            collapseDirection   : 'right',
            animCollapse        : false,
            region              : 'center'
        });

        if (me.orientation === 'vertical') {
            lockedGrid.store = normalGrid.store = me.timeAxis;
        }

        if (lockedGrid.width) {
            // User has specified a fixed width for the locked section, disable the syncLockedWidth method
            me.syncLockedWidth = Ext.emptyFn;
            // Enable scrollbars for locked section
            lockedGrid.scroll = 'horizontal';
            lockedGrid.scrollerOwner = true;
        }

        var lockedViewConfig    = me.lockedViewConfig = me.lockedViewConfig || {};
        var normalViewConfig    = me.normalViewConfig = me.normalViewConfig || {};

        if (isTree) {
            // HACK, speeding up by preventing an edit to cause a massive relayout
            var oldOnUpdate = Ext.tree.View.prototype.onUpdate;
            lockedViewConfig.onUpdate = function() {
                // truncated version of original "refreshSize" which does not do any layouts, but which however still
                // should update the reference of the "body" element
                this.refreshSize = function () {
                    var me = this,
                        bodySelector = me.getBodySelector();

                    // On every update of the layout system due to data update, capture the view's main element in our private flyweight.
                    // IF there *is* a main element. Some TplFactories emit naked rows.
                    if (bodySelector) {
                        me.body.attach(me.el.child(bodySelector, true));
                    }
                };
                Ext.suspendLayouts();
                oldOnUpdate.apply(this, arguments);
                Ext.resumeLayouts();
                this.refreshSize = Ext.tree.View.prototype.refreshSize;
            };

            // need to use the NodeStore instance, created in the FilterableTreeStore mixin for both views
            lockedViewConfig.store  = normalViewConfig.store = me.store.nodeStore;
        }

        var origLayout = me.layout;
        var lockedWidth = lockedGrid.width;

        this.callParent(arguments);

        // HACK, no sane way of getting rid of these it seems (as of 4.2.1).
        // Grouping view overwrites showMenuBy property
        // http://www.sencha.com/forum/showthread.php?269612-Config-to-get-rid-of-Lock-Unlock-column-options&p=987653#post987653
        this.on('afterrender', function() {
            var showMenuBy = this.lockedGrid.headerCt.showMenuBy;

            this.lockedGrid.headerCt.showMenuBy = function() {
                showMenuBy.apply(this, arguments);

                me.showMenuBy.apply(this, arguments);
            };
        });

        // At this point, the 2 child grids are created

        var lockedView = me.lockedGrid.getView();
        var normalView = me.normalGrid.getView();

        this.patchViews();

        // Now post processing, changing and overriding some things that Ext.grid.Lockable sets up
        if (lockedWidth || origLayout === 'border') {
            if (lockedWidth) {
                me.lockedGrid.setWidth(lockedWidth);
            }

            // Force horizontal scrollbar to be shown to keep spacerEl magic working when scrolling to bottom
            normalView.addCls('sch-timeline-horizontal-scroll');
            lockedView.addCls('sch-locked-horizontal-scroll');
            
            me.horizontalScrollForced   = true;
        }

        if (me.normalGrid.collapsed) {
            // Need to workaround this, child grids cannot be collapsed initially
            me.normalGrid.collapsed = false;

            // Note, for the case of buffered view/store we need to wait for the view box to be ready before collapsing
            // since the paging scrollbar reads the view height during setup. When collapsing too soon, its viewSize will be 0.
            normalView.on('boxready', function(){
                me.normalGrid.collapse();
            }, me, { delay : 10 });
        }

        if (me.lockedGrid.collapsed) {
            if (lockedView.bufferedRenderer) lockedView.bufferedRenderer.disabled = true;
        }

        // Without this fix, scrolling on Mac Chrome does not work in locked grid
        if (Ext.getScrollbarSize().width === 0) {
            // https://www.assembla.com/spaces/bryntum/support/tickets/252
            lockedView.addCls('sch-ganttpanel-force-locked-scroll');
        }

        if (isTree) {
            this.setupLockableTree();
        }

        if (me.useSpacer) {
            normalView.on('refresh', me.updateSpacer, me);
            lockedView.on('refresh', me.updateSpacer, me);
        }

        if (origLayout !== 'fit') {
            me.layout = origLayout;
        }

        // Sanity check to make sure grids were setup correctly
        if (lockedView.store !== normalView.store) {
            Ext.Error.raise('Sch.mixin.Lockable setup failed, not sharing store between the two views');
        }

        // @OVERRIDE using some private methods to sync the top scroll position for a locked grid which is initially collapsed
        if (normalView.bufferedRenderer) {
            // Need to sync vertical position after child gridpanel expand
            this.lockedGrid.on('expand', function() {
                lockedView.el.dom.scrollTop     = normalView.el.dom.scrollTop;
            });

            this.patchSubGrid(this.lockedGrid, true);
            this.patchSubGrid(this.normalGrid, false);

            this.patchBufferedRenderingPlugin(normalView.bufferedRenderer);
            this.patchBufferedRenderingPlugin(lockedView.bufferedRenderer);
        }


        // Patch syncHorizontalScroll to solve header scroll issue
        this.patchSyncHorizontalScroll(this.lockedGrid);
        this.patchSyncHorizontalScroll(this.normalGrid);
        
        this.delayReordererPlugin(this.lockedGrid);
        this.delayReordererPlugin(this.normalGrid);
    },


    setupLockableTree: function () {
        var me              = this;
        var lockedView      = me.lockedGrid.getView();

        // enable filtering support for trees
        var filterableProto = Sch.mixin.FilterableTreeView.prototype;

        lockedView.initTreeFiltering        = filterableProto.initTreeFiltering;
        lockedView.onFilterChangeStart      = filterableProto.onFilterChangeStart;
        lockedView.onFilterChangeEnd        = filterableProto.onFilterChangeEnd;
        lockedView.onFilterCleared          = filterableProto.onFilterCleared;
        lockedView.onFilterSet              = filterableProto.onFilterSet;

        lockedView.initTreeFiltering();
    },

    
    patchSyncHorizontalScroll : function(grid) {
        // Override scrollTask
        grid.scrollTask = new Ext.util.DelayedTask(function (left, setBody) {
            // Patched method, always get scroll left position from dom, not from args
            // http://www.sencha.com/forum/showthread.php?273464-Grid-panel-header-scrolls-incorrectly-after-column-resizing
            // test: header/318_header_scroll_bug.t.js
            var target = this.getScrollTarget().el;

            if (target) this.syncHorizontalScroll(target.dom.scrollLeft, setBody);
        }, grid);
    },
    
    
    // the columns re-orderer plugin is being initialized synchronously, after rendering the header container
    // but before layouts
    // its initializing involves creation of drag/drop zones which performs "verifyEl" call on the headerCt element
    // which, in turn, tries to access "el.offsetParent" - that slows down rendering for no reason.
    // the initilization of the column reoderer can be delayed.
    // for 700 tasks / 300 dependencies project this optimization brings rendering time down from 3s to 2.5s in Chrome
    // (for other browsers speed up is less significant)
    delayReordererPlugin : function (grid) {
        var headerCt                = grid.headerCt;
        var reorderer               = headerCt.reorderer;
        
        if (reorderer) {
            headerCt.un('render', reorderer.onHeaderCtRender, reorderer);
            headerCt.on('render', function () {
                if (!headerCt.isDestroyed) reorderer.onHeaderCtRender(); 
            }, reorderer, { single : true, delay : 10 });
        }
    },

    
    updateSpacer : function() {

        var lockedView = this.lockedGrid.getView();
        var normalView = this.normalGrid.getView();

        if (lockedView.rendered && normalView.rendered && lockedView.el.child('table')) {
            var me   = this,
            // This affects scrolling all the way to the bottom of a locked grid
            // additional test, sort a column and make sure it synchronizes
                lockedViewEl   = lockedView.el,
                normalViewEl = normalView.el.dom,
                spacerId = lockedViewEl.dom.id + '-spacer',
                spacerHeight = (normalViewEl.offsetHeight - normalViewEl.clientHeight) + 'px';

            me.spacerEl = Ext.getDom(spacerId);

            // HACK ie 6-7 and 8 in quirks mode fail to set style of hidden elements, so we must remove it manually
            if (Ext.isIE6 || Ext.isIE7 || (Ext.isIEQuirks && Ext.isIE8) && me.spacerEl) {

                Ext.removeNode(me.spacerEl);
                me.spacerEl = null;
            }

            if (me.spacerEl) {
                me.spacerEl.style.height = spacerHeight;
            } else {
                // put the spacer inside of stretcher with special css class (see below), which will cause the
                // stretcher to increase its height on the height of spacer
                var spacerParent = lockedViewEl;

                Ext.core.DomHelper.append(spacerParent, {
                    id      : spacerId,
//                    cls     : this.store.buffered ? 'sch-locked-buffered-spacer' : '',
                    style   : 'height: ' + spacerHeight
                });
            }
        }
    },


    // TODO remove after dropping support for 4.2.0?
    onLockedViewScroll: function() {
        this.callParent(arguments);

        var lockedBufferedRenderer  = this.lockedGrid.getView().bufferedRenderer;

        if (lockedBufferedRenderer) lockedBufferedRenderer.onViewScroll();
    },

    // TODO remove after dropping support for 4.2.0?
    onNormalViewScroll: function() {
        this.callParent(arguments);

        var normalBufferedRenderer  = this.normalGrid.getView().bufferedRenderer;

        if (normalBufferedRenderer) normalBufferedRenderer.onViewScroll();
    },


    // we need to disabled the plugin when grid is collapsed
    patchSubGrid : function (grid, isLocked) {
        var view                    = grid.getView();
        var bufferedRenderer        = view.bufferedRenderer;

        grid.on({
            collapse        : function () { bufferedRenderer.disabled = true; },
            expand          : function () { bufferedRenderer.disabled = false; }
        });
        
        // bug in ExtJS: http://www.sencha.com/forum/showthread.php?276800-4.2.2-Buffered-rendering-plugin-issues&p=1013797#post1013797
        // the `tableStyle` misses "px" at the end
        var prevCollectData         = view.collectData;
        
        view.collectData            = function () {
            var result              = prevCollectData.apply(this, arguments);
            var tableStyle          = result.tableStyle;
            
            // checking if `tableStyle` ends with "px" (trying to do it fast)
            if (tableStyle && tableStyle[ tableStyle.length - 1 ] != 'x') result.tableStyle += 'px';
            
            return result;
        };
        // eof bug
        
        // onRemove patch
        // in case of tree, normal and locked views have different types - locked view is a tree view and normal view is a regular
        // grid view. This causes the buffered rendererers, attached to the views,  behave differently, because of 
        // Ext.grid.plugin.BufferedRendererTreeView override.
        // When some node is collapsed for example, the locked view is fully refreshed (not sure why the full refresh is needed)
        // after refresh the "onViewRefresh" method of the buffered renderer is called for the locked view
        // and it updates the stretcher size among other things
        // but, this method is not called for normal grid, because its a regular grid view, w/o Ext.grid.plugin.BufferedRendererTreeView
        // so we call that method manually
        var isTree                  = Ext.data.TreeStore && this.store instanceof Ext.data.TreeStore;
        
        if (isLocked && isTree) {
            var prevOnRemove        = view.onRemove;
            
            view.onRemove           = function () {
                prevOnRemove.apply(this, arguments);
                
                this.lockingPartner.bufferedRenderer.onViewRefresh();
            };
            
            // we will need re-bind the store, that will happen at the bottom of the method
        }
        // eof onRemove patch
        
        // The buffered renderer plugin includes 2 overrides for grid view: Ext.grid.plugin.BufferedRendererTableView and 
        // Ext.grid.plugin.BufferedRendererTreeView.
        // Seems the buffered renderer behavior is completely broken when doing CRUD with the store (nodes are inserted in
        // random places in the view), that is why Ext.grid.plugin.BufferedRendererTreeView modestly does a full refresh 
        // for a "onRemove" handler. We will do the same for "onAdd" and for regular table as well.
        var prevOnAdd               = view.onAdd;
        
        view.onAdd                  = function () {
            var me = this;
            // Using buffered rendering - removal (eg folder node collapse)
            // Has to refresh the view
            if (me.rendered && me.bufferedRenderer) {
                me.refreshView();
            }
            // No BufferedRenderer preent
            else {
                prevOnAdd.apply(this, arguments);
            }
        };
        
        // re-bind the store, so that new versions of `onRemove` and `onAdd` methods will be bound instead of default ones
        view.bindStore(null);
        view.bindStore(isTree ? this.store.nodeStore : this.resourceStore);
    },
    
    
    afterLockedViewLayout : function () {
        // do nothing if horizontal scrolling has been forced
        // this method performs some bottom border with adjustment
        // which we don't need in case of forced scrolling
        if (!this.horizontalScrollForced) return this.callParent(arguments);
    },


    patchBufferedRenderingPlugin : function (plugin) {
        plugin.variableRowHeight    = true;

        if (Ext.getVersion('extjs').isLessThan('4.2.1.883')) {
            // TODO find more robust way to unsubscribe from "scroll" event of the view
            plugin.view.on('afterrender', function () {
                plugin.view.el.un('scroll', plugin.onViewScroll, plugin);
            }, this, { single : true, delay : 1 });

            var prevStretchView         = plugin.stretchView;

            plugin.stretchView          = function (view, scrollRange) {
                var me              = this,
                    recordCount     = (me.store.buffered ? me.store.getTotalCount() : me.store.getCount());

                if (recordCount && (me.view.all.endIndex === recordCount - 1)) {
                    scrollRange     = me.bodyTop + view.body.dom.offsetHeight;
                }

                prevStretchView.apply(this, [ view, scrollRange ]);
            };
        } else {
            var prevEnable          = plugin.enable;

            plugin.enable           = function () {
                if (plugin.grid.collapsed) return;

                return prevEnable.apply(this, arguments);
            };
        }
    },

    // HACK, no sane way of getting rid of these it seems (as of 4.2.1).
    // http://www.sencha.com/forum/showthread.php?269612-Config-to-get-rid-of-Lock-Unlock-column-options&p=987653#post987653
    showMenuBy: function(t, header) {
        var menu = this.getMenu(),
            unlockItem  = menu.down('#unlockItem'),
            lockItem = menu.down('#lockItem'),
            sep = unlockItem.prev();

        sep.hide();
        unlockItem.hide();
        lockItem.hide();
    },

    // Various ugly overrides to avoid locked grid causing crazy scrolling in IE.
    // REMOVE FOR EXT 5, UNTIL THEN - ENJOY
    patchViews : function() {
        if (Ext.isIE) {
            var selModel    = this.getSelectionModel();
            var me          = this;
            var lockedView  = me.lockedGrid.view;
            var normalView  = me.normalGrid.view;

            //@OVERRIDE to fix https://www.assembla.com/spaces/bryntum/tickets/661
            // https://www.assembla.com/spaces/bryntum/tickets/1095
            var old         = selModel.processSelection;
            
            var eventName   = Ext.getVersion('extjs').isLessThan('4.2.2.1144') ? 'mousedown' : 'click';
            var focusMethod = lockedView.doFocus ? 'doFocus' : 'focus';
            
            selModel.processSelection = function (view, record, item, index, e) {
                var oldScrollRowIntoView, oldFocus;

                if (e.type == eventName) {
                    oldScrollRowIntoView            = lockedView.scrollRowIntoView;
                    oldFocus                        = lockedView[ focusMethod ];

                    lockedView.scrollRowIntoView    = normalView.scrollRowIntoView = Ext.emptyFn;
                    lockedView[ focusMethod ]       = normalView[ focusMethod ] = Ext.emptyFn;
                }

                old.apply(this, arguments);

                if (e.type == eventName) {
                    lockedView.scrollRowIntoView    = normalView.scrollRowIntoView = oldScrollRowIntoView;
                    lockedView[ focusMethod ]       = normalView[ focusMethod ] = oldFocus;
                    
                    lockedView.el.focus();
                }
            };

            //@OVERRIDE to fix https://www.assembla.com/spaces/bryntum/tickets/661
            var oldRF = normalView.onRowFocus;

            normalView.onRowFocus = function (rowIdx, highlight, suppressFocus) {
                oldRF.call(this, rowIdx, highlight, true);
            };
            
//            var oldNormalFocusRow   = normalView.focusRow;
//            normalView.focusRow = function (row, delay) { return oldNormalFocusRow.call(this, row, 0) };
//
//            var oldLockedFocusRow   = lockedView.focusRow;
//            lockedView.focusRow = function (row, delay) { return oldLockedFocusRow.call(this, row, 0) };
            
            if (Ext.tree && Ext.tree.plugin && Ext.tree.plugin.TreeViewDragDrop) {

                lockedView.on('afterrender', function() {
                    Ext.each(lockedView.plugins, function(plug) {

                        if (plug instanceof Ext.tree.plugin.TreeViewDragDrop) {

                            var old = lockedView[ focusMethod ];

                            plug.dragZone.view.un('itemmousedown', plug.dragZone.onItemMouseDown, plug.dragZone);

                            plug.dragZone.view.on('itemmousedown', function() {

                                lockedView[ focusMethod ] = Ext.emptyFn;

                                if (lockedView.editingPlugin) {
                                    lockedView.editingPlugin.completeEdit();
                                }
                                plug.dragZone.onItemMouseDown.apply(plug.dragZone, arguments);

                                lockedView[ focusMethod ] = old;
                            });

                            return false;
                        }
                    });

                }, null, { delay : 100 });
            }
        }
    }
});

/**
@class Sch.plugin.TreeCellEditing
@extends Ext.grid.plugin.CellEditing

A specialized "cell editing" plugin (ptype = 'scheduler_treecellediting'), purposed to correctly work with trees. Add it to your component (scheduler with tree view or gantt)
as usual grid plugin:

    var gantt = Ext.create('Gnt.panel.Gantt', {

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

This class allows us to do 'complex data editing', which is not supported by the regular CellEditing plugin or the Ext.grid.CellEditor which
 assumes a column is always tied to a single field existing on the grid store model (which is not the case for Gantt, dependencies, assignments etc).
*/
Ext.define('Sch.plugin.TreeCellEditing', {
    extend          : 'Ext.grid.plugin.CellEditing',
    alias           : 'plugin.scheduler_treecellediting',

    lockableScope   : 'locked',

    init : function (pnl) {
        this._grid      = pnl;

        // This is used to prevent editing of readonly cells
        this.on('beforeedit', this.checkReadOnly, this);

        this.callParent(arguments);
    },

    bindPositionFixer : function () {
        Ext.on({
            afterlayout : this.fixEditorPosition,

            scope       : this
        });
    },

    unbindPositionFixer : function () {
        Ext.un({
            afterlayout : this.fixEditorPosition,

            scope       : this
        });
    },

    /*
     * Fixes active editor position.
     */
    fixEditorPosition : function (record) {
        // check if we have an active editor
        var editor  = this.getActiveEditor();
        if (editor) {// && (!record || record === this.context.record)) {
            // rebuild editing context
            var editingContext  = this.getEditingContext(this.context.record, this.context.column);
            if (editingContext) {
                // after layout flushing we have references to not exisiting
                // DOM elements for row and for cell, so we update them
                this.context.row        = editingContext.row;
                this.context.rowIdx     = editingContext.rowIdx;
                editor.boundEl          = this.getCell(editingContext.record, editingContext.column);
                editor.realign();

                var lockedView          = this._grid.getView();
                // Since gridview/treeview isn't built to handle a refresh during editing,
                // we help the view by re-setting the focusedRow which is invalid after the refresh
                lockedView.focusedRow = lockedView.getNode(editingContext.rowIdx);
            }
        }
    },

    /*
    * Checks if panel is not locked for editing, and prevents cell edits if needed
    */
    checkReadOnly : function() {
        var pnl = this._grid;

        if (!(pnl instanceof Sch.panel.TimelineTreePanel)) {
            pnl = pnl.up('tablepanel');
        }
        return !pnl.isReadOnly();
    },

    // Preventing a possibly massive relayout on start edit
    startEdit : function(record, columnHeader, context) {
        this._grid.suspendLayouts();

//        TODO this code is probably no longer required, after we have moved the "onBeforeEdit" handler
//        in the TreeCellEditing to the `showEditor` method
//        but need to review all tests
//        var editor   = columnHeader.getEditor && columnHeader.getEditor();
//
//        // if editor has suppress record updating method - call it
//        if (editor && editor.setSuppressTaskUpdate) {
//            editor.setSuppressTaskUpdate(true);
//        }
//
//        // we have to call completeEdit here
//        // since for some reason in parent method
//        // completeEdit starts after 'beforeedit' firing
//        this.completeEdit();

        var val = this.callParent(arguments);

//        // restore suppressing state
//        if (editor && editor.setSuppressTaskUpdate) {
//            editor.setSuppressTaskUpdate(false);
//        }

        this._grid.resumeLayouts();

        return val;
    },

    // @OVERRIDE - model set() method
    onEditComplete : function(ed, value, startValue) {
        var me = this, record, restore;

        // if field instance contains applyChanges() method
        // then we delegate saving to it
        if (ed.field.applyChanges) {
            record      = ed.field.task || me.context.record;
            restore     = true;
            // overwrite original set() method to use applyChanges() instead
            record.set  = function() {
                // restore original method
                delete record.set;
                restore = false;

                ed.field.applyChanges(record);
            };
        }

        this.callParent(arguments);

        // restore original set() method
        if (restore) {
            delete record.set;
        }

        this.unbindPositionFixer();
    },

    // @OVERRIDE - Fixes layout issues during editing in IE
    showEditor : function(ed, context, value) {
        var sm                  = this.grid.getSelectionModel();
        var oldSelect           = sm.selectByPosition;

        // for some reason we are disabling this method
        // could be because it was doing focus, and thus triggering some side effects
        // as of 4.2.2 ExtJS seems to prevent the focus itself, so may be we don't need it anymore
        // in 4.2.2 this disabling breaks the editing when user click the row which is not yet selected (clicksToEdit : 1)
        // (gantt columns/1014_dependency.t.js)
        if (Ext.getVersion('extjs').isLessThan('4.2.2.1144')) {
            sm.selectByPosition = Ext.emptyFn;
        }
        
        var field               = ed.field;

        // if editor has suppress record updating method - call it
        if (field && field.setSuppressTaskUpdate) {
            field.setSuppressTaskUpdate(true);
        }
        
        var prevStartEdit       = ed.startEdit;

        // Sencha can't decide whether this method should be called synchronously or not
        // in some versions it is called synchronously, in others - with 1ms delay
        // so we can't call the "setSuppressTaskUpdate(false)" synchronously after `callParent()` here
        // need to do this only after the `startEdit` of the editor has happened
        ed.startEdit            = function () {
            ed.startEdit        = prevStartEdit;
            
            ed.startEdit.apply(ed, arguments);
            
            // restore suppressing state
            if (field && field.setSuppressTaskUpdate) {
                field.setSuppressTaskUpdate(false);
            }
        };

        // For editing of cells where the data isn't coming from the task model itself, we need to help the
        // editor understand what's going on and set a proper initial value instead of 'undefined'
        if (field) {
            // if it's a field mixed with TaskField mixin
            if (field.setTask) {
                // then after setTask calling field already has correct value
                field.setTask(context.record);
                value = context.value = context.originalValue = field.getValue();

            } else if (!context.column.dataIndex && context.value === undefined) {
                value = context.value = field.getDisplayValue(context.record);
            }
        }

        this.callParent([ed, context, value]);

        if (Ext.getVersion('extjs').isLessThan('4.2.2.1144')) {
            sm.selectByPosition = oldSelect;
        }

        this.bindPositionFixer();
    },

    cancelEdit : function () {
        this.callParent(arguments);

        this.unbindPositionFixer();
    }

});

/**
 * @class Sch.feature.ResizeZone
 * @extends Ext.util.Observable
 * @private
 * Internal classing enabling resizing of rendered events
 * @constructor
 * @param {Sch.panel.SchedulerGrid} scheduler The scheduler instance
 * @param {Object} config The object containing the configuration of this model.
 */


Ext.define("Sch.feature.ResizeZone", {
    extend : "Ext.util.Observable",
    requires : [
        'Ext.resizer.Resizer',
        'Sch.tooltip.Tooltip'
    ],

    /**
      * @cfg showTooltip {Boolean} false to not show a tooltip while resizing
      */
    showTooltip         : true,

    /**
     * An empty function by default, but provided so that you can perform custom validation on
     * the item being resized.
     * @param {Sch.model.Resource} resourceRecord the resource to which the event belongs
     * @param {Sch.model.Event} eventRecord the event being resized
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Ext.EventObject} e The event object
     * @return {Boolean} true if the new duration is valid, else false to signal that it is not.
     */
    validatorFn         : Ext.emptyFn,

    /**
     * @cfg {Object} validatorFnScope
     * The scope for the validatorFn
     */
    validatorFnScope    : null,
    
    schedulerView       : null,

    origEl              : null,
    handlePos           : null,
    eventRec            : null,
    tip                 : null,

    
    constructor : function(config) {
        Ext.apply(this, config);
        var s = this.schedulerView;

        s.on({
            destroy : this.cleanUp,
            scope   : this
        });

        s.mon(s.el, {
            mousedown       : this.onMouseDown,
            mouseup         : this.onMouseUp,
            scope           : this,
            delegate        : '.sch-resizable-handle'
        });
        this.callParent(arguments);
    },

    onMouseDown : function(e, t) {
        var s               = this.schedulerView;
        var eventRec        = this.eventRec = s.resolveEventRecord(t);
        var isResizable     = eventRec.isResizable();

        if (e.button !== 0 || (isResizable === false || typeof isResizable === 'string' && !t.className.match(isResizable))) {
            return;
        }

        this.eventRec       = eventRec;
        this.handlePos      = this.getHandlePosition(t);
        this.origEl         = Ext.get(e.getTarget('.sch-event'));
        
        s.el.on({
            mousemove   : this.onMouseMove,
            scope       : this,
            single      : true
        });
    },

    onMouseUp : function(e, t) {
        var s = this.schedulerView;

        s.el.un({
            mousemove   : this.onMouseMove,
            scope       : this,
            single      : true
        });
    },

     
    onMouseMove : function(e, t) {
        var s           = this.schedulerView;
        var eventRec    = this.eventRec;

        if (!eventRec || s.fireEvent('beforeeventresize', s, eventRec, e) === false) {
            return;
        }
        
        delete this.eventRec;
        e.stopEvent();

        var handlePos   = this.handlePos;
        this.resizer    = this.createResizer(this.origEl, eventRec, handlePos, e, t);

        this.resizer.resizeTracker.onMouseDown(e, this.resizer[handlePos].dom);

        if (this.showTooltip) {
             if (!this.tip) {
                this.tip = Ext.create("Sch.tooltip.Tooltip", {
                    schedulerView   : s,
                    cls             : 'sch-resize-tip'
                });
            }
            this.tip.update(eventRec.getStartDate(), eventRec.getEndDate(), true);
            this.tip.show(this.origEl);
        }
        s.fireEvent('eventresizestart', s, eventRec);
    },

    getHandlePosition : function(node) {
        if (this.schedulerView.getOrientation() === 'horizontal') {
            if (this.schedulerView.rtl) {
                return node.className.match('start') ? 'east' : 'west';
            }
            return node.className.match('start') ? 'west' : 'east';
        } else {
             return node.className.match('start') ? 'north' : 'south';
        }
    },

    // private
    createResizer : function (el, eventRecord, handlePos) {
        var s                   = this.schedulerView,
            resourceRecord      = s.resolveResource(el),
            increment           = s.getSnapPixelAmount(),
            constrainRegion     = s.getScheduleRegion(resourceRecord, eventRecord),
            dateConstraints     = s.getDateConstraints(resourceRecord, eventRecord),
            height              = el.getHeight,
            isStart             = (s.rtl && handlePos[0] === 'e') || (!s.rtl && handlePos[0] === 'w') || handlePos[0] === 'n',

            resizerCfg          = {
                target          : el,
                isStart         : isStart,
                dateConstraints : dateConstraints,
                resourceRecord  : resourceRecord,
                eventRecord     : eventRecord,
                handles         : handlePos[0],
                minHeight       : height,
                constrainTo     : constrainRegion,

                listeners       : {
                    resizedrag  : this.partialResize,
                    resize      : this.afterResize,
                    scope       : this
                }
            };

        // HACK, make it unique to prevent Ext JS from getting the wrong one if multiple events with same Id exist.
        // Remove this when scheduler has assignment store awareness
        var prevId          = el.id;
        var newId           = '_' + prevId;
            
        el.id               = el.dom.id = newId;
        
        // duplicate the cache entry for this element, so Ext.get(newId) or Ext.get(el) will reference the same entry 
        Ext.cache[ newId ]  = Ext.cache[ prevId ];
        // EOF HACK

        // Apply orientation specific configs
        if (s.getOrientation() === 'vertical') {
            if (increment > 0) {
                var w = el.getWidth();

                Ext.apply(resizerCfg, {
                    minHeight       : increment,
                    // To avoid SHIFT causing a ratio preserve
                    minWidth        : w,
                    maxWidth        : w,
                    heightIncrement : increment
                });
            }
        } else {
            if (increment > 0) {

                Ext.apply(resizerCfg, {
                    minWidth        : increment,
                    // To avoid SHIFT causing a ratio preserve
                    maxHeight       : height,
                    widthIncrement  : increment
                });
            }
        }

        var resizer = Ext.create('Ext.resizer.Resizer', resizerCfg);

        if (resizer.resizeTracker && Ext.isWebKit) {
            // Ignore resizing action if dragging outside the scheduler
            // Fixes WebKit issue https://www.assembla.com/spaces/bryntum/tickets/994#/activity/ticket:
            var old = resizer.resizeTracker.updateDimensions;

            resizer.resizeTracker.updateDimensions = function(e) {
                if (e.getTarget('.sch-timelineview')) {
                    old.apply(this, arguments);
                }
            };
        }
        // Make sure the resizing event is on top of other events
        el.setStyle('z-index', parseInt(el.getStyle('z-index'), 10)+1);
        return resizer;
    },

    getStartEndDates : function(xy) {
        var r           = this.resizer,
            rEl         = r.el,
            s           = this.schedulerView,
            isStart     = r.isStart,
            start,
            end;

        if (isStart) {
            end         = r.eventRecord.getEndDate();
            start       = s.getDateFromXY([s.rtl ? rEl.getRight() : rEl.getLeft() + 1, rEl.getTop()], 'round');
        } else {
            start       = r.eventRecord.getStartDate();
            end         = s.getDateFromXY([s.rtl ? rEl.getLeft() : rEl.getRight(), rEl.getBottom()], 'round');
        }

        if (r.dateConstraints) {
            start       = Sch.util.Date.constrain(start, r.dateConstraints.start, r.dateConstraints.end);
            end         = Sch.util.Date.constrain(end, r.dateConstraints.start, r.dateConstraints.end);
        }

        return {
            start   : start,
            end     : end
        };
    },

    // private
    partialResize : function (r, width, height, e) {
        var s = this.schedulerView,
            startEndDates = this.getStartEndDates(e.getXY()),
            start = startEndDates.start,
            end = startEndDates.end;

        if (!start || !end || ((r.start - start === 0) && (r.end - end === 0))) {
            return;
        }

        var valid = this.validatorFn.call(this.validatorFnScope || this, r.resourceRecord, r.eventRecord, start, end) !== false;

        r.end = end;
        r.start = start;

        s.fireEvent('eventpartialresize', s, r.eventRecord, start, end, r.el);

        if (this.showTooltip) {
            this.tip.update(start, end, valid);
        }
    },

    // private
    afterResize : function (r, w, h, e) {
        if (this.showTooltip) {
            this.tip.hide();
        }
        
        // HACK, restore original id
        // removing extra cache entry for this element
        delete Ext.cache[ r.el.id ];
        
        r.el.id = r.el.dom.id = r.el.id.substr(1);
        // EOF HACK

        var me              = this,
            resourceRecord  = r.resourceRecord,
            eventRecord     = r.eventRecord,
            oldStart        = eventRecord.getStartDate(),
            oldEnd          = eventRecord.getEndDate(),
            start           = r.start || oldStart,
            end             = r.end || oldEnd,
            sv              = me.schedulerView,
            modified        = false,
            doFinalize      = true;

        me.resizeContext    = {
            eventRecord     : eventRecord,
            start           : start,
            end             : end,
            finalize        : function() { me.finalize.apply(me, arguments); }
        };

        if (start && end && (end - start > 0) && // Input sanity check
            ((start - oldStart !== 0) || (end - oldEnd !== 0)) && // Make sure start OR end changed
            me.validatorFn.call(me.validatorFnScope || me, resourceRecord, eventRecord, start, end, e) !== false) {


            // Seems to be a valid resize operation, ask outside world if anyone wants to take control over the finalizing,
            // to show a confirm dialog prior to applying the new values.
            doFinalize = sv.fireEvent('beforeeventresizefinalize', me, me.resizeContext, e) !== false;
            modified = true;
        } else {
            sv.repaintEventsForResource(resourceRecord);
        }

        if (doFinalize) {
            me.finalize(modified);
        }
    },

    finalize : function(updateRecord) {
        var sv = this.schedulerView;
        var context = this.resizeContext;

        if (updateRecord) {
            if (this.resizer.isStart) {
                context.eventRecord.setStartDate(context.start, sv.eventStore.skipWeekendsDuringDragDrop);
            } else {
                context.eventRecord.setEndDate(context.end, sv.eventStore.skipWeekendsDuringDragDrop);
            }
        } else {
            sv.repaintEventsForResource(context.eventRecord.getResource());
        }

        // Destroy resizer
        this.resizer.destroy();

        sv.fireEvent('eventresizeend', sv, context.eventRecord);

        this.resizeContext = null;
    },

    cleanUp : function() {
        if (this.tip) {
            this.tip.destroy();
        }
    }
});

/**
@class Sch.feature.ColumnLines
@extends Sch.plugin.Lines

A simple feature adding column lines (to be used when using the SingleTimeAxis column).

*/
Ext.define("Sch.feature.ColumnLines", {
    extend : 'Sch.plugin.Lines',

    cls : 'sch-column-line',
    
    showTip : false,

    requires : [
        'Ext.data.JsonStore'
    ],
    
    init : function (panel) {
        this.timeAxis = panel.getTimeAxis();
        this.panel = panel;

        this.store = new Ext.data.JsonStore({
            fields   : [ 'Date' ]
        });

        // Sencha Touch normalization
        this.store.loadData = this.store.loadData || this.store.setData;

        this.callParent(arguments);

        panel.on({
            orientationchange   : this.populate,
            destroy             : this.onHostDestroy,
            scope               : this
        });

        this.timeAxis.on('reconfigure', this.populate, this);
        
        this.populate();
    },

    onHostDestroy : function() {
        this.timeAxis.un('reconfigure', this.populate, this);
    },

    populate: function() {
        this.store.loadData(this.getData());
    },
    
    getElementData : function() {
        var sv = this.schedulerView;

        if (sv.isHorizontal() && sv.store.getCount() > 0) {
            return this.callParent(arguments);
        }

        return [];
    },

    getData : function() {
        var panel = this.panel,
            ticks = [];

        if (panel.isHorizontal()) {
            this.timeAxis.forEachMainInterval(function(start, end, i) {
                if (i > 0) {
                    ticks.push({ Date : start });
                }
            });
        }

        return ticks;
    }
});
/**
@class Sch.plugin.CurrentTimeLine
@extends Sch.plugin.Lines

Plugin (ptype = 'scheduler_currenttimeline') indicating the current date and time as a line in the schedule.

To add this plugin to scheduler:

        var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
            ...

            resourceStore   : resourceStore,
            eventStore      : eventStore,

            plugins         : [
                Ext.create('Sch.plugin.CurrentTimeLine', { updateInterval : 30000 })
            ]
        });


*/
Ext.define("Sch.plugin.CurrentTimeLine", {
    extend              : "Sch.plugin.Lines",
    alias               : 'plugin.scheduler_currenttimeline',
    mixins              : ['Sch.mixin.Localizable'],

    /**
     * @cfg {String} tooltipText The text to show in the tooltip next to the current time (defaults to 'Current time').
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - tooltipText : 'Current time'
     */

    /**
     * @cfg {Int} updateInterval This value (in ms) defines how often the timeline shall be refreshed. Defaults to every once every minute.
     */
    updateInterval      : 60000,

    showHeaderElements  : true,

    /**
     * @cfg {Boolean} autoUpdate true to automatically update the line position over time. Default value is `true`
     */
    autoUpdate          : true,

    expandToFitView     : true,

    timer               : null,

    init                : function(cmp) {
        var store = Ext.create("Ext.data.JsonStore", {
            fields : ['Date', 'Cls', 'Text'],
            data : [{Date : new Date(), Cls : 'sch-todayLine', Text : this.L('tooltipText')}]
        });

        var record = store.first();

        if (this.autoUpdate) {
            this.timer = setInterval(function() {
                record.set('Date', new Date());
            }, this.updateInterval);
        }

        cmp.on('destroy', this.onHostDestroy, this);

        this.store = store;
        this.callParent(arguments);
    },

    onHostDestroy       : function() {
        if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
        }

        if (this.store.autoDestroy) {
            this.store.destroy();
        }
    }
});

/**
 * @class Sch.view.Horizontal
 * @private
 *
 * An internal view mixin, purposed to be consumed along with {@link Sch.mixin.AbstractTimelineView}.
 * This class is consumed by the scheduling view and provides the horizontal implementation of certain methods.
 */
Ext.define("Sch.view.Horizontal", {
    requires : [
        'Ext.util.Region',
        'Ext.Element',
        'Sch.util.Date'
    ],
    // Provided by creator, in the config object
    view: null,

    constructor: function (config) {
        Ext.apply(this, config);
    },

    translateToScheduleCoordinate: function (x) {
        var view = this.view;

        if (view.rtl) {
            return view.getTimeAxisColumn().getEl().getRight() - x;
        }
        return x - view.getEl().getX() + view.getScroll().left;
    },

    translateToPageCoordinate: function (x) {
        var view = this.view;
        return x + view.getEl().getX() - view.getScroll().left;
    },

    getEventRenderData: function (event, start, end) {
        var eventStart  = start || event.getStartDate(),
            eventEnd    = end || event.getEndDate() || eventStart, // Allow events to be rendered even they are missing an end date
            view        = this.view,
            viewStart   = view.timeAxis.getStart(),
            viewEnd     = view.timeAxis.getEnd(),
            M           = Math,
            startX      = view.getXFromDate(Sch.util.Date.max(eventStart, viewStart)),
            endX        = view.getXFromDate(Sch.util.Date.min(eventEnd, viewEnd)),
            data        = {};

        if (this.view.rtl) {
            data.right = M.min(startX, endX);
        } else {
            data.left = M.min(startX, endX);
        }

        data.width = M.max(1, M.abs(endX - startX)) - view.eventBorderWidth;

        if (view.managedEventSizing) {
            data.top = M.max(0, (view.barMargin - ((Ext.isIE && !Ext.isStrict) ? 0 : view.eventBorderWidth - view.cellTopBorderWidth)));
            data.height = view.rowHeight - (2 * view.barMargin) - view.eventBorderWidth;
        }

        data.start              = eventStart;
        data.end                = eventEnd;
        data.startsOutsideView  = eventStart < viewStart;
        data.endsOutsideView    = eventEnd > viewEnd;
        return data;
    },

    /**
    * Gets the Ext.util.Region, relative to the page, represented by the schedule and optionally only for a single resource. This method will call getDateConstraints to 
    * allow for additional resource/event based constraints. By overriding that method you can constrain events differently for
    * different resources.
    * @param {Sch.model.Resource} resourceRecord (optional) The resource record
    * @param {Sch.model.Event} eventRecord (optional) The event record
    * @return {Ext.util.Region} The region of the schedule
    */
    getScheduleRegion: function (resourceRecord, eventRecord) {
        var getRegionFn     = Ext.Element.prototype.getRegion ? 'getRegion' : 'getPageBox',
            view            = this.view,
            region          = resourceRecord ? Ext.fly(view.getRowNode(resourceRecord))[getRegionFn]() : view.getTableRegion(),
            taStart         = view.timeAxis.getStart(),
            taEnd           = view.timeAxis.getEnd(),
            dateConstraints = view.getDateConstraints(resourceRecord, eventRecord) || { start: taStart, end: taEnd },
            startX          = this.translateToPageCoordinate(view.getXFromDate(dateConstraints.start)),
            endX            = this.translateToPageCoordinate(view.getXFromDate(dateConstraints.end)),
            top             = region.top + view.barMargin,
            bottom          = region.bottom - view.barMargin - view.eventBorderWidth;

        return new Ext.util.Region(top, Math.max(startX, endX), bottom, Math.min(startX, endX));
    },


    /**
    * Gets the Ext.util.Region, relative to the scheduling view element, representing the passed resource and optionally just for a certain date interval.
    * @param {Sch.model.Resource} resourceRecord The resource record
    * @param {Date} startDate A start date constraining the region
    * @param {Date} endDate An end date constraining the region
    * @return {Ext.util.Region} The region of the resource
    */
    getResourceRegion: function (resourceRecord, startDate, endDate) {
        var view        = this.view,
            rowNode     = view.getRowNode(resourceRecord),
            offsets     = Ext.fly(rowNode).getOffsetsTo(view.getEl()),
            taStart     = view.timeAxis.getStart(),
            taEnd       = view.timeAxis.getEnd(),
            start       = startDate ? Sch.util.Date.max(taStart, startDate) : taStart,
            end         = endDate ? Sch.util.Date.min(taEnd, endDate) : taEnd,
            startX      = view.getXFromDate(start),
            endX        = view.getXFromDate(end),
            top         = offsets[1] + view.cellTopBorderWidth,
            bottom      = offsets[1] + Ext.fly(rowNode).getHeight() - view.cellBottomBorderWidth;

        if (!Ext.versions.touch) {
            var ctElScroll  = view.getScroll();
            top += ctElScroll.top;
            bottom += ctElScroll.top;
        }
        return new Ext.util.Region(top, Math.max(startX, endX), bottom, Math.min(startX, endX));
    },


    columnRenderer: function (val, meta, resourceRecord, rowIndex, colIndex) {
        var view            = this.view;
        var resourceEvents  = view.eventStore.getEventsForResource(resourceRecord);

        if (resourceEvents.length === 0) {
            return;
        }

        var ta              = view.timeAxis,
            eventsTplData   = [],
            i, l;

        // Iterate events belonging to current row
        for (i = 0, l = resourceEvents.length; i < l; i++) {
            var event       = resourceEvents[i],
                start       = event.getStartDate(),
                end         = event.getEndDate();

            // Determine if the event should be rendered or not
            if (start && end && ta.timeSpanInAxis(start, end)) {
                eventsTplData[eventsTplData.length] = view.generateTplData(event, resourceRecord, rowIndex);
            }
        }

        // Event data is now gathered, calculate layout properties for each event (if dynamicRowHeight is used)
        if (view.dynamicRowHeight) {
            var layout              = view.eventLayout.horizontal;
            
            layout.applyLayout(eventsTplData, resourceRecord);
            
            meta.rowHeight          = layout.getRowHeight(resourceRecord, resourceEvents);
        }

        return view.eventTpl.apply(eventsTplData);
    },
    
    
    // private
    resolveResource: function (t) {
        var view = this.view;
        var node = view.findRowByChild(t);

        if (node) {
            return view.getRecordForRowNode(node);
        }

        return null;
    },

    /**
    *  Returns the region for a "global" time span in the view. Coordinates are relative to element containing the time columns
    *  @param {Date} startDate The start date of the span
    *  @param {Date} endDate The end date of the span
    *  @return {Ext.util.Region} The region for the time span
    */
    getTimeSpanRegion: function (startDate, endDate, useViewSize) {
        var view    = this.view,
            startX  = view.getXFromDate(startDate),
            endX    = endDate ? view.getXFromDate(endDate) : startX,
            height, region;

        region = view.getTableRegion();
        
        if (useViewSize) {
            height = Math.max(region ? region.bottom - region.top: 0, view.getEl().dom.clientHeight); // fallback in case grid is not rendered (no rows/table)
        } else {
            height = region ? region.bottom - region.top: 0;
        }
        return new Ext.util.Region(0, Math.max(startX, endX), height, Math.min(startX, endX));
    },

    /**
    * Gets the start and end dates for an element Region
    * @param {Region} region The region to map to start and end dates
    * @param {String} roundingMethod The rounding method to use
    * @returns {Object} an object containing start/end properties
    */
    getStartEndDatesFromRegion: function (region, roundingMethod, allowPartial) {
        var view        = this.view;
        var rtl         = view.rtl;
        
        var startDate   = view.getDateFromCoordinate(rtl ? region.right : region.left, roundingMethod),
            endDate     = view.getDateFromCoordinate(rtl ? region.left : region.right, roundingMethod);
            
        if (startDate && endDate || allowPartial && (startDate || endDate)) {
            return {
                start   : startDate,
                end     : endDate
            };
        }
        
        return null;
    },

    // private
    onEventAdd: function (s, events) {
        var view = this.view;
        var affectedResources = {};

        for (var i = 0, l = events.length; i < l; i++) {
            var resources = events[i].getResources();

            for (var j = 0, k = resources.length; j < k; j++) {
                var resource = resources[j];

                affectedResources[resource.getId()] = resource;
            }
        }

        Ext.Object.each(affectedResources, function (id, resource) {
            view.repaintEventsForResource(resource);
        });
    },

    // private
    onEventRemove: function (s, eventRecords) {
        var view = this.view;
        var resourceStore   = this.resourceStore;
        var isTree          = Ext.tree && Ext.tree.View && view instanceof Ext.tree.View;

        if (!Ext.isArray(eventRecords)) {
            eventRecords = [eventRecords];
        }

        var updateResource  = function(resource) {
            if (view.store.indexOf(resource) >= 0) {
                view.repaintEventsForResource(resource);
            }
        };

        for (var i = 0; i < eventRecords.length; i++) {
            var resources = eventRecords[i].getResources();

            if (resources.length > 1) {
                Ext.each(resources, updateResource, this);
            } else {
                var node = view.getEventNodeByRecord(eventRecords[i]);

                if (node) {
                    var resource = view.resolveResource(node);

                    // Note, the methods below should not rely on Ext.get but since Ext.anim.run
                    // doesn't support HTMLElements, and due to this bug:
                    // http://www.sencha.com/forum/showthread.php?248981-4.1.x-fadeOut-fadeIn-etc-not-safe-to-use-with-flyweights&p=911314#post911314
                    // currently we have to live with this

                    if (Ext.Element.prototype.fadeOut) {
                        Ext.get(node).fadeOut({
                            callback: function() { updateResource(resource); }
                        });
                    } else {
                        Ext.Anim.run(Ext.get(node), 'fade', {
                            out         : true,
                            duration    : 500,
                            after       : function() { updateResource(resource); },
                            autoClear   : false
                        });
                    }
                }
            }
        }
    },

    // private
    onEventUpdate: function (store, model, operation) {
        var previous = model.previous;
        var view = this.view;

        if (previous && previous[model.resourceIdField]) {
            // If an event has been moved to a new row, refresh old row first
            var resource = model.getResource(previous[model.resourceIdField]);
            if (resource) {
                view.repaintEventsForResource(resource, true);
            }
        }

        var resources = model.getResources();

        Ext.each(resources, function(resource) {
            view.repaintEventsForResource(resource, true);
        });
    },

    setColumnWidth: function (width, preventRefresh) {
        var view = this.view;

        view.getTimeAxisViewModel().setTickWidth(width, preventRefresh);

        view.fireEvent('columnwidthchange', view, width);
    },

    /**
    * Method to get the currently visible date range in a scheduling view. Please note that it only works when the schedule is rendered.
    * @return {Object} object with `startDate` and `endDate` properties.
    */
    getVisibleDateRange: function () {
        var view = this.view;

        if (!view.getEl()) {
            return null;
        }

        var tableRegion = view.getTableRegion(),
            startDate   = view.timeAxis.getStart(),
            endDate     = view.timeAxis.getEnd(),
            width       = view.getWidth();

        if ((tableRegion.right - tableRegion.left) < width) {
            return { startDate: startDate, endDate: endDate };
        }

        var scroll      = view.getScroll();

        return {
            startDate   : view.getDateFromCoordinate(scroll.left, null, true),
            endDate     : view.getDateFromCoordinate(scroll.left + width, null, true)
        };
    }
}); 

/**
@class Sch.mixin.AbstractTimelineView
@private

 A base mixin for giving to the consuming view "time line" functionality.
This means that the view will be capable to display a list of "events", ordered on the {@link Sch.data.TimeAxis time axis}.

This class should not be used directly.

*/
Ext.define("Sch.mixin.AbstractTimelineView", {
    requires: [
        'Sch.data.TimeAxis',
        'Sch.view.Horizontal'
    ],

    /**
    * @cfg {String} selectedEventCls
    * A CSS class to apply to an event in the view on mouseover (defaults to 'sch-event-selected').
    */
    selectedEventCls : 'sch-event-selected',

    // private
    readOnly            : false,
    horizontalViewClass : 'Sch.view.Horizontal',

    //    can not "declare" it here, because will conflict with the default value from  SchedulerView
    //    verticalViewClass   : null,

    timeCellCls         : 'sch-timetd',
    timeCellSelector    : '.sch-timetd',

    eventBorderWidth        : 1,

    timeAxis            : null,
    timeAxisViewModel   : null,
    
    eventPrefix         : null,
    
    rowHeight           : null,
//    can not "declare" it here, because will conflict with the default value from  SchedulerView
//    barMargin           : null,
    
    orientation         : 'horizontal',

    altColCls : 'sch-col-alt',

    horizontal          : null,
    vertical            : null,
    
    secondaryCanvasEl   : null,
    
    panel               : null,
    
    displayDateFormat   : null,
    
    snapToIncrement     : null,

    // Accessor to the Ext.Element for this view
    el                  : null,    

    _initializeTimelineView         : function() { 
        if (this.horizontalViewClass) {
            this.horizontal = Ext.create(this.horizontalViewClass, { view : this });
        }

        if (this.verticalViewClass) {
            this.vertical = Ext.create(this.verticalViewClass, { view : this });
        }

        this.eventPrefix = (this.eventPrefix || this.getId()) + '-';
    },

    getTimeAxisViewModel : function () {
        return this.timeAxisViewModel;
    },

    /**
    * Method to get a formatted display date
    * @private
    * @param {Date} date The date
    * @return {String} The formatted date
    */
    getFormattedDate: function (date) {
        return Ext.Date.format(date, this.getDisplayDateFormat());
    },

    /**
    * Method to get a formatted end date for a scheduled event, the grid uses the "displayDateFormat" property defined in the current view preset.
    * @private
    * @param {Date} endDate The date to format
    * @param {Date} startDate The start date 
    * @return {String} The formatted date
    */
    getFormattedEndDate: function (endDate, startDate) {
        var format = this.getDisplayDateFormat();

        if (
                // If time is midnight,
                endDate.getHours() === 0 && endDate.getMinutes() === 0 &&

                // and end date is greater then start date
                !(endDate.getYear() === startDate.getYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() === startDate.getDate()) &&

                // and UI display format doesn't contain hour info (in this case we'll just display the exact date)
                !Sch.util.Date.hourInfoRe.test(format.replace(Sch.util.Date.stripEscapeRe, ''))
            )
        {
            // format the date inclusively as 'the whole previous day'.
            endDate = Sch.util.Date.add(endDate, Sch.util.Date.DAY, -1);
        }
                
        return Ext.Date.format(endDate, format);
    },

    // private
    getDisplayDateFormat: function () {
        return this.displayDateFormat;
    },

    // private
    setDisplayDateFormat: function (format) {
        this.displayDateFormat = format;
    },
   

    /**
    * This function fits the schedule area columns into the available space in the grid.
    * @param {Boolean} preventRefresh `true` to prevent a refresh of view
    */ 
    fitColumns: function (preventRefresh) { // TODO test
        if (this.orientation === 'horizontal') {
            this.getTimeAxisViewModel().fitToAvailableWidth(preventRefresh);
        } else {
            var w = Math.floor((this.panel.getWidth() - Ext.getScrollbarSize().width - 1) / this.headerCt.getColumnCount());
            this.setColumnWidth(w, preventRefresh);
        }
    },
    
    /**
    * <p>Returns the Ext Element representing an event record</p> 
    * @param {Sch.model.Event} record The event record
    * @return {Ext.Element} The Ext.Element representing the event record
    */
    getElementFromEventRecord: function (record) {
        return Ext.get(this.eventPrefix + record.internalId);
    },
        
    getEventNodeByRecord: function(record) {
        return document.getElementById(this.eventPrefix + record.internalId);
    },

    getEventNodesByRecord: function(record) {
        return this.el.select("[id=" + this.eventPrefix + record.internalId + "]");
    },

    /**
    * Gets the start and end dates for an element Region
    * @param {Region} region The region to map to start and end dates
    * @param {String} roundingMethod The rounding method to use
    * @returns {Object} an object containing start/end properties
    */
    getStartEndDatesFromRegion: function (region, roundingMethod, allowPartial) {
        return this[this.orientation].getStartEndDatesFromRegion(region, roundingMethod, allowPartial);
    },

    
    /**
    * Returns the current time resolution object, which contains a unit identifier and an increment count.
    * @return {Object} The time resolution object
    */
    getTimeResolution: function () {
        return this.timeAxis.getResolution();
    },

    /**
    * Sets the current time resolution, composed by a unit identifier and an increment count.
    * @return {Object} The time resolution object
    */
    setTimeResolution: function (unit, increment) {
        this.timeAxis.setResolution(unit, increment);

        // View will have to be updated to support snap to increment
        if (this.snapToIncrement) {
            this.refreshKeepingScroll();
        }
    },

    /**
    * <p>Returns the event id for a DOM id </p>
    * @private
    * @param {String} id The id of the DOM node
    * @return {Sch.model.Event} The event record
    */
    getEventIdFromDomNodeId: function (id) {
        return id.substring(this.eventPrefix.length);
    },

     
    /**
    *  Gets the time for a DOM event such as 'mousemove' or 'click'
    *  @param {Ext.EventObject} e, the EventObject instance
    *  @param {String} roundingMethod (optional), 'floor' to floor the value or 'round' to round the value to nearest increment
    *  @returns {Date} The date corresponding to the EventObject x coordinate
    */
    getDateFromDomEvent : function(e, roundingMethod) {
        return this.getDateFromXY(e.getXY(), roundingMethod);
    },

    /**
    * [Experimental] Returns the pixel increment for the current view resolution.
    * @return {Int} The width increment
    */
    getSnapPixelAmount: function () {
        return this.getTimeAxisViewModel().getSnapPixelAmount();
    },

    // @deprecated
    getTimeColumnWidth : function() {
        return this.getTimeAxisViewModel().getTickWidth();
    },

    /**
    * Controls whether the scheduler should snap to the resolution when interacting with it.
    * @param {Boolean} enabled true to enable snapping when interacting with events.
    */
    setSnapEnabled: function (enabled) {
        this.snapToIncrement = enabled;

        if (enabled) {
            this.refreshKeepingScroll();
        }
    },

    /**
    * Sets the readonly state which limits the interactivity (resizing, drag and drop etc).
    * @param {Boolean} readOnly The new readOnly state
    */
    setReadOnly: function (readOnly) {
        this.readOnly = readOnly;
        this[readOnly ? 'addCls' : 'removeCls'](this._cmpCls + '-readonly');
    },

    /**
    * Returns true if the view is currently readOnly.
    * @return {Boolean} readOnly 
    */
    isReadOnly: function () {
        return this.readOnly;
    },

        
    /**
    * Sets the current orientation.
    * 
    * @param {String} orientation Either 'horizontal' or 'vertical'
    */
    setOrientation : function(orientation) {
        this.orientation = orientation; 
    },

    /**
    * Returns the current view orientation
    * @return {String} The view orientation ('horizontal' or 'vertical')
    */
    getOrientation: function () {
        return this.orientation;
    },
    
    isHorizontal : function() {
        return this.getOrientation() === 'horizontal';
    },


    isVertical : function() {
        return !this.isHorizontal();
    },
       
    /**
    * Gets the date for an XY coordinate
    * @param {Array} xy The page X and Y coordinates
    * @param {String} roundingMethod The rounding method to use
    * @param {Boolean} local, true if the coordinate is local to the scheduler view element 
    * @returns {Date} the Date corresponding to the xy coordinate
    */
    getDateFromXY: function (xy, roundingMethod, local) {
        return this.getDateFromCoordinate(this.orientation === 'horizontal' ? xy[0] : xy[1], roundingMethod, local);
    },

    /**
    * Gets the date for an X or Y coordinate, either local to the view element or the page based on the 3rd argument.
    * @param {Int} coordinate The X or Y coordinate
    * @param {String} roundingMethod The rounding method to use
    * @param {Boolean} local, true if the coordinate is local to the scheduler view element 
    * @returns {Date} the Date corresponding to the xy coordinate
    */
    getDateFromCoordinate: function (coord, roundingMethod, local) {
        if (!local) {
            coord = this[this.orientation].translateToScheduleCoordinate(coord);
        }
        return this.timeAxisViewModel.getDateFromPosition(coord, roundingMethod);
    },

    /**
    * Gets the date for the passed X coordinate.
    * If the coordinate is not in the currently rendered view, -1 will be returned.
    * @param {Int} x The X coordinate
    * @param {String} roundingMethod The rounding method to use
    * @returns {Date} the Date corresponding to the x coordinate
    * @abstract
    */
    getDateFromX: function (x, roundingMethod) {
        return this.getDateFromCoordinate(x, roundingMethod);
    },

    /**
    * Gets the date for the passed Y coordinate
    * If the coordinate is not in the currently rendered view, -1 will be returned.
    * @param {Int} y The Y coordinate
    * @param {String} roundingMethod The rounding method to use
    * @returns {Date} the Date corresponding to the y coordinate
    * @abstract
    */
    getDateFromY: function (y, roundingMethod) {
        return this.getDateFromCoordinate(y, roundingMethod);
    },

    /**
    *  Gets the x or y coordinate relative to the scheduling view element, or page coordinate (based on the 'local' flag)
    *  If the coordinate is not in the currently rendered view, -1 will be returned.
    *  @param {Date} date, the date to query for
    *  @param {Boolean} local, true to return a coordinate local to the scheduler view element (defaults to true)
    *  @returns {Int} the x or y position representing the date on the time axis
    */
    getCoordinateFromDate: function (date, local) {
        var pos = this.timeAxisViewModel.getPositionFromDate(date);

        if (local === false) {
            pos = this[this.orientation].translateToPageCoordinate(pos);
        }

        return Math.round(pos);
    },

    /**
    *  Gets the x coordinate relative to the scheduling view element, or page coordinate (based on the 'local' flag)
    *  @param {Date} date, the date to query for
    *  @param {Boolean} local, true to return a coordinate local to the scheduler view element (defaults to false)
    *  @returns {Array} the XY coordinates representing the date
    */
    getXFromDate: function (date, local) {
        return this.getCoordinateFromDate(date, local);
    },

    /**
    *  Gets xy coordinates relative to the scheduling view element, or page coordinates (based on the 'local' flag)
    *  @param {Date} xy, the page X and Y coordinates
    *  @param {Boolean} local, true to return a coordinate local to the scheduler view element 
    *  @returns {Array} the XY coordinates representing the date
    */
    getYFromDate: function (date, local) {
        return this.getCoordinateFromDate(date, local);
    },

    /**
    *  Returns the distance in pixels the for time span in the view.
    *  @param {Date} startDate The start date of the span
    *  @param {Date} endDate The end date of the span
    *  @return {Int} The distance in pixels
    */
    getTimeSpanDistance: function (startDate, endDate) {
        return this.timeAxisViewModel.getDistanceBetweenDates(startDate, endDate);
    },

    /**
    *  Returns the region for a "global" time span in the view. Coordinates are relative to element containing the time columns
    *  @param {Date} startDate The start date of the span
    *  @param {Date} endDate The end date of the span
    *  @return {Ext.util.Region} The region for the time span
    */
    getTimeSpanRegion: function (startDate, endDate) {
        return this[this.orientation].getTimeSpanRegion(startDate, endDate);
    },

    /**
    * Gets the Ext.util.Region represented by the schedule and optionally only for a single resource. The view will ask the scheduler for 
    * the resource availability by calling getResourceAvailability. By overriding that method you can constrain events differently for
    * different resources.
    * @param {Sch.model.Resource} resourceRecord (optional) The resource record 
    * @param {Sch.model.Event} eventRecord (optional) The event record 
    * @return {Ext.util.Region} The region of the schedule
    */
    getScheduleRegion: function (resourceRecord, eventRecord) {
        return this[this.orientation].getScheduleRegion(resourceRecord, eventRecord);
    },

    // Returns the region of the table element containing the rows of the schedule
    getTableRegion : function () {
        throw 'Abstract method call';
    },

    // Returns the table element containing the rows of the schedule
    getRowNode: function (resourceRecord) {
        throw 'Abstract method call';
    },

    getRecordForRowNode : function(node) {
        throw 'Abstract method call';
    },
    
    /**
    * Method to get the currently visible date range in a scheduling view. Please note that it only works when the schedule is rendered.
    * @return {Object} object with `startDate` and `endDate` properties.
    */
    getVisibleDateRange: function () {
        return this[this.orientation].getVisibleDateRange();
    },

    setColumnWidth: function (width, preventRefresh) {
        this[this.orientation].setColumnWidth(width, preventRefresh);
    },

    findRowByChild : function(t) {
        throw 'Abstract method call';
    },

    /**
    * Sets the amount of margin to keep between bars and rows.
    * @param {Int} margin The new margin value
    * @param {Boolean} preventRefresh true to skip refreshing the view
    */
    setBarMargin: function (margin, preventRefresh) {
        this.barMargin = margin;
        if (!preventRefresh) {
            this.refreshKeepingScroll();
        }
    },

    /**
     * Returns the current row height used by the view (only applicable in a horizontal view)
     * @return {Boolean} The row height
     */
    getRowHeight: function () {
        return this.rowHeight;
    },

    /**
    * Sets the height of row
    * @param {Number} height The height to set
    * @param {Boolean} preventRefresh `true` to prevent view refresh
    */
    setRowHeight: function (height, preventRefresh) {
        this.rowHeight = height || 24;

        if (this.orientation === 'vertical') {
            this.timeAxisViewModel.setTickWidth(this.rowHeight, preventRefresh);
        } else {
            if (this.getEl() && !preventRefresh) {
                this.refreshKeepingScroll();
            }
        }
    },
    
    /**
    * Refreshes the view and maintains the scroll position.
    */
    refreshKeepingScroll : function() {
        throw 'Abstract method call';
    },

    /**
     * Scrolls the view vertically
     * @param {Int} y The y-value to scroll to
     * @param {Boolean/Object} animate The animation config, or true/false
     */
    scrollVerticallyTo : function(y, animate) {
        throw 'Abstract method call';
    },

    /**
     * Scrolls the view horizontally
     * @param {Int} x The x-value to scroll to
     * @param {Boolean/Object} animate The animation config, or true/false
     */
    scrollHorizontallyTo : function(x, animate) {
        throw 'Abstract method call';
    },

    /**
     * Returns the current vertical scroll value
     */
    getVerticalScroll : function() {
        throw 'Abstract method call';
    },

    /**
     * Returns the current horizontal scroll value
     */
    getHorizontalScroll : function() {
        throw 'Abstract method call';
    },

    // This method should be implemented by the consuming class
    getEl : Ext.emptyFn,
    
    
    // returns a secondary canvas el - the el to be used for drawing column lines, zones etc
    getSecondaryCanvasEl : function () {
        if (!this.secondaryCanvasEl) {
            this.secondaryCanvasEl = this.getEl().createChild({ cls : 'sch-secondary-canvas' });
        }
        return this.secondaryCanvasEl;
    },

    /**
     * Returns the current viewport scroll position as an object with left/top properties.
     */
    getScroll : function() {
        throw 'Abstract method call';
    },

    getOuterEl : function() {
        return this.getEl();
    },

    getRowContainerEl : function() {
        return this.getEl();
    },

    getScheduleCell : function(row, col) {
        return this.getCellByPosition({ row : row, column : col});
    },
    
    
    getScrollEventSource : function () {
        return this.getEl();
    },

    getViewportHeight : function () {
        return this.getEl().getHeight();
    },

    getViewportWidth : function () {
        return this.getEl().getWidth();
    },

    getDateConstraints : Ext.emptyFn
});


Ext.apply(Sch, {
    /*PKGVERSION*/VERSION : '2.2.15'
});
/**
@class Sch.mixin.TimelineView

A base mixin for {@link Ext.view.View} classes, giving to the consuming view the "time line" functionality.
This means that the view will be capable to display a list of "events", ordered on the {@link Sch.data.TimeAxis time axis}.

By itself this mixin is not enough for correct rendering. The class, consuming this mixin, should also consume one of the
{@link Sch.view.Horizontal} or {@link Sch.view.Vertical} mixins, which provides the implementation of some orientation-specfic methods.

Generally, should not be used directly, if you need to subclass the view, subclass the {@link Sch.view.SchedulerGridView} instead.

*/
Ext.define("Sch.mixin.TimelineView", {
    extend : 'Sch.mixin.AbstractTimelineView',

    requires : ['Sch.patches.ElementScroll'],

    /**
    * @cfg {String} overScheduledEventClass
    * A CSS class to apply to each event in the view on mouseover (defaults to 'sch-event-hover').
    */
    overScheduledEventClass: 'sch-event-hover',

    ScheduleEventMap    : {
        click           : 'Click',
        mousedown       : 'MouseDown',
        mouseup         : 'MouseUp',
        dblclick        : 'DblClick',
        contextmenu     : 'ContextMenu',
        keydown         : 'KeyDown',
        keyup           : 'KeyUp'
    },

    _initializeTimelineView : function() {
        this.callParent(arguments);

        this.on('destroy', this._onDestroy, this);
        this.on('afterrender', this._onAfterRender, this);

        this.setOrientation(this.orientation);

        this.addEvents(
            /**
             * @event beforetooltipshow
             * Fires before the event tooltip is shown, return false to suppress it.
             * @param {Sch.mixin.SchedulerPanel} scheduler The scheduler object
             * @param {Sch.model.Event} eventRecord The event record corresponding to the rendered event
             */
            'beforetooltipshow',

            'columnwidthchange'
        );

        this.enableBubble('columnwidthchange');

        this.addCls("sch-timelineview");

        if (this.readOnly) {
            this.addCls(this._cmpCls + '-readonly');
        }

        this.addCls(this._cmpCls);

        if (this.eventAnimations) {
            this.addCls('sch-animations-enabled');
        }
    },

    inheritables : function() {
        return {
            // @OVERRIDE
            processUIEvent: function(e){
                var eventBarNode = e.getTarget(this.eventSelector),
                    map = this.ScheduleEventMap,
                    type = e.type,
                    preventViewEvent = false;

                if (eventBarNode && type in map) {
                    this.fireEvent(this.scheduledEventName + type, this, this.resolveEventRecord(eventBarNode), e);

                    // In Scheduler, clicking or interacting with an event should not trigger itemclick or other itemXXX events
                    // In gantt, a rendered bar corresponds to the row, so let view superclass process the event too
                    preventViewEvent = !(this.getSelectionModel() instanceof Ext.selection.RowModel);
                }

                if (!preventViewEvent) {
                    // For gantt, default actions should be executed too
                    return this.callParent(arguments);
                }
            }
        };
    },


    // private, clean up
    _onDestroy: function () {
        if (this.tip) {
            this.tip.destroy();
        }
    },

    _onAfterRender : function () {
        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(true);
        }

        if (this.tooltipTpl) {
            this.el.on('mousemove', this.setupTooltip, this, { single : true });
        }

        var bufferedRenderer    = this.bufferedRenderer;

        if (bufferedRenderer) {
            this.patchBufferedRenderingPlugin(bufferedRenderer);
            this.patchBufferedRenderingPlugin(this.lockingPartner.bufferedRenderer);
        }

        this.on('bufferedrefresh', this.onBufferedRefresh, this, { buffer : 10 });

        this.setupTimeCellEvents();

        // The `secondaryCanvasEl` needs to be setup early, for the underlying gridview to know about it 
        // and not remove it on later 'refresh' calls.
        this.getSecondaryCanvasEl();
    },


    patchBufferedRenderingPlugin : function (plugin) {
        var me                      = this;
        var oldSetBodyTop           = plugin.setBodyTop;

        // @OVERRIDE Overriding buffered renderer plugin
        plugin.setBodyTop           = function (bodyTop, calculatedTop) {
            if (bodyTop < 0) bodyTop = 0;

            var val                 = oldSetBodyTop.apply(this, arguments);

            me.fireEvent('bufferedrefresh', this);

            return val;
        };
    },



    onBufferedRefresh : function() {
        this.getSecondaryCanvasEl().dom.style.top = this.body.dom.style.top;
    },

    setMouseOverEnabled : function(enabled) {
        this[enabled ? "mon" : "mun"](this.el, {
            mouseover : this.onEventMouseOver,
            mouseout  : this.onEventMouseOut,
            delegate  : this.eventSelector,
            scope     : this
        });
    },

    // private
    onEventMouseOver: function (e, t) {
        if (t !== this.lastItem) {
            this.lastItem = t;

            Ext.fly(t).addCls(this.overScheduledEventClass);

            var eventModel      = this.resolveEventRecord(t);

            // do not fire this event if model can not be found
            // this can be the case for "sch-dragcreator-proxy" elements for example
            if (eventModel) this.fireEvent('eventmouseenter', this, eventModel, e);
        }
    },

    // private
    onEventMouseOut: function (e, t) {
        if (this.lastItem) {
            if (!e.within(this.lastItem, true, true)) {
                Ext.fly(this.lastItem).removeCls(this.overScheduledEventClass);
                this.fireEvent('eventmouseleave', this, this.resolveEventRecord(this.lastItem), e);
                delete this.lastItem;
            }
        }
    },

    // Overridden since locked grid can try to highlight items in the unlocked grid while it's loading/empty
    highlightItem: function(item) {
        if (item) {
            var me = this;
            me.clearHighlight();
            me.highlightedItem = item;
            Ext.fly(item).addCls(me.overItemCls);
        }
    },

    // private
    setupTooltip: function () {
        var me = this,
            tipCfg = Ext.apply({
                renderTo    : Ext.getBody(),
                delegate    : me.eventSelector,
                target      : me.el,
                anchor      : 'b',
                rtl         : me.rtl,

                show : function() {
                    Ext.ToolTip.prototype.show.apply(this, arguments);

                    // Some extra help required to correct alignment (in cases where event is in part outside the scrollable area
                    // https://www.assembla.com/spaces/bryntum/tickets/626#/activity/ticket:
                    if (this.triggerElement && me.getOrientation() === 'horizontal') {
                        this.setX(this.targetXY[0]-10);
                        this.setY(Ext.fly(this.triggerElement).getY()-this.getHeight()-10);
                    }
                }
            }, me.tipCfg);

        me.tip = Ext.create('Ext.ToolTip', tipCfg);

        me.tip.on({
            beforeshow: function (tip) {
                if (!tip.triggerElement || !tip.triggerElement.id) {
                    return false;
                }

                var record = this.resolveEventRecord(tip.triggerElement);

                if (!record || this.fireEvent('beforetooltipshow', this, record) === false) {
                    return false;
                }

                tip.update(this.tooltipTpl.apply(this.getDataForTooltipTpl(record)));
            },

            scope: this
        });
    },

    getTimeAxisColumn : function () {
        if (!this.timeAxisColumn) {
            this.timeAxisColumn = this.headerCt.down('timeaxiscolumn');
        }

        return this.timeAxisColumn;
    },

    /**
    * Template method to allow you to easily provide data for your {@link Sch.mixin.TimelinePanel#tooltipTpl} template.
    * @return {Mixed} The data to be applied to your template, typically any object or array.
    */
    getDataForTooltipTpl : function(record) {
        return Ext.apply({
            _record : record
        }, record.data);
    },

    /**
     * Refreshes the view and maintains the scroll position.
     */
    refreshKeepingScroll : function() {
        Ext.suspendLayouts();

        this.saveScrollState();

        this.refresh();

        if (this.up('tablepanel[lockable=true]').lockedGridDependsOnSchedule) {
            this.lockingPartner.refresh();
        }

        this.restoreScrollState();

        Ext.resumeLayouts(true);
    },

    setupTimeCellEvents: function () {
        this.mon(this.el, {
            // `handleScheduleEvent` is an abstract method, defined in "SchedulerView" and "GanttView"
            click       : this.handleScheduleEvent,
            dblclick    : this.handleScheduleEvent,
            contextmenu : this.handleScheduleEvent,

            scope       : this
        });
    },

    getTableRegion: function () {
        var tableEl = this.el.down('.' + Ext.baseCSSPrefix + 'grid-table');

        // Also handle odd timing cases where the table hasn't yet been inserted into the dom
        return (tableEl || this.el).getRegion();
    },

    // Returns the table element containing the rows of the schedule
    getRowNode: function (resourceRecord) {
        return this.getNodeByRecord(resourceRecord);
    },

    findRowByChild : function(t) {
        return this.findItemByChild(t);
    },

    getRecordForRowNode : function(node) {
        return this.getRecord(node);
    },

    /**
    * Refreshes the view and maintains the resource axis scroll position.
    */
    refreshKeepingResourceScroll : function() {
        var scroll = this.getScroll();

        this.refresh();

        if (this.getOrientation() === 'horizontal') {
            this.scrollVerticallyTo(scroll.top);
        } else {
            this.scrollHorizontallyTo(scroll.left);
        }
    },

    scrollHorizontallyTo : function(x, animate) {
        var el = this.getEl();
        if (el) {
            el.scrollTo('left', Math.max(0, x), animate);
        }
    },

    scrollVerticallyTo : function(y, animate) {
        var el = this.getEl();
        if (el) {
            el.scrollTo('top', Math.max(0,  y), animate);
        }
    },

    getVerticalScroll : function() {
        var el = this.getEl();
        return el.getScroll().top;
    },

    getHorizontalScroll : function() {
        var el = this.getEl();
        return el.getScroll().left;
    },

    getScroll : function() {
        var scroll = this.getEl().getScroll();

        return {
            top : scroll.top,
            left : scroll.left
        };
    },

    /**
     * @deprecated Use getCoordinateFromDate instead.
     * @BWCOMPAT 2.2
     */
    getXYFromDate : function() {
        var coord = this.getCoordinateFromDate.apply(this, arguments);

        return this.orientation === 'horizontal' ? [coord, 0] : [0, coord];
    },

    handleScheduleEvent : function (e) {
    }

});

/**

@class Sch.view.TimelineGridView
@extends Ext.grid.View
@mixin Sch.mixin.TimelineView

A grid view class, that consumes the {@link Sch.mixin.TimelineView} mixin. Used internally.

*/

Ext.define("Sch.view.TimelineGridView", {
    extend      : "Ext.grid.View",
    mixins      : ['Sch.mixin.TimelineView']
}, function() {
    this.override(Sch.mixin.TimelineView.prototype.inheritables() || {});
});
// !XXX when adding new methods to this mixing need to also update the 
// `setupLockableTree` method in the Sch.mixin.Lockable
Ext.define("Sch.mixin.FilterableTreeView", {
    
    prevBlockRefresh        : null,
    
    
    initTreeFiltering : function () {
        var doInit  = function () {
            var treeStore       = this.up('tablepanel').store;

            // if are we inside of locked grid 
            if (treeStore instanceof Ext.data.NodeStore) treeStore  = this.up('tablepanel[lockable=true]').store;
            
            this.mon(treeStore, 'nodestore-datachange-start', this.onFilterChangeStart, this);
            this.mon(treeStore, 'nodestore-datachange-end', this.onFilterChangeEnd, this);
            
            this.mon(treeStore, 'filter-clear', this.onFilterCleared, this);
            this.mon(treeStore, 'filter-set', this.onFilterSet, this);
        };
        
        if (this.rendered)
            doInit.call(this);
        else
            this.on('beforerender', doInit, this, { single : true });
    },
    
    
    onFilterChangeStart : function () {
        this.prevBlockRefresh   = this.blockRefresh;
        
        // block refresh in filterable tree view, for the cases when this mixin is consumed by non-tree views
        // "blockRefresh" is already true in all tree views, so in the Sch.data.mixin.FilterableTreeStore
        // we use "nodeStore.fireEvent('clear', nodeStore);" hack, which is directly tied to "refresh" method of the view
        // in case when non-tree view consumes this mixin, we need to temporarily block the refresh manually,
        // to avoid double refresh
        this.blockRefresh       = true;
        
        Ext.suspendLayouts();
    },
    
    
    onFilterChangeEnd : function () {
        Ext.resumeLayouts(true);
        
        this.blockRefresh       = this.prevBlockRefresh;
    },
    
    
    onFilterCleared : function () {
        delete this.toggle;
        
        var el          = this.getEl();
        
        if (el) el.removeCls('sch-tree-filtered');
    },
    
    
    onFilterSet : function () {
        this.toggle     = function () {};
        
        var el          = this.getEl();
        
        if (el) el.addCls('sch-tree-filtered');
    }
});
/**
@class Sch.mixin.Zoomable

A mixin for {@link Sch.mixin.TimelinePanel} class, providing "zooming" functionality to the consuming panel.

The zooming feature works by reconfiguring panel's time axis with the current zoom level values selected from the {@link #zoomLevels} array.
Zoom levels can be added and removed from the array to change the amount of available steps. Range of zooming in/out can be also
modified with {@link #maxZoomLevel} / {@link #minZoomLevel} properties.

This mixin adds additional methods to the scheduler : {@link #setMaxZoomLevel}, {@link #setMinZoomLevel}, {@link #zoomToLevel}, {@link #zoomIn},
{@link #zoomOut}, {@link #zoomInFull}, {@link #zoomOutFull}.

Notice: zooming doesn't work properly when `forceFit` option is set to true for the panel.
*/

Ext.define('Sch.mixin.Zoomable', {
    /**
     * @cfg {Array} [zoomLevels=Array] Predefined map of zoom levels for each preset in the ascending order. Zoom level is basically a {@link Sch.preset.ViewPreset view preset},
     * which is based on another preset, with some values overriden.
     *
     * Each element is an {Object} with the following parameters :
     *
     * - `preset` (String)      - {@link Sch.preset.ViewPreset} to be used for this zoom level. This must be a valid preset name registered in {@link Sch.preset.Manager preset manager}.
     * - `width` (Int)          - {@link Sch.preset.ViewPreset#timeColumnWidth timeColumnWidth} time column width value from the preset
     * - `increment` (Int)      - {@link Sch.preset.ViewPresetHeaderRow#increment increment} value from the bottom header row of the preset
     * - `resolution` (Int)     - {@link Sch.preset.ViewPreset#timeResolution increment} part of the `timeResolution` object in the preset
     * - `resolutionUnit` (String) (Optional) - {@link Sch.preset.ViewPreset#timeResolution unit} part of the `timeResolution` object in the preset
     */
    zoomLevels: [
        //YEAR
        { width: 80,    increment: 5,   resolution: 1, preset: 'manyYears', resolutionUnit: 'YEAR' },
        { width: 40,    increment: 1,   resolution: 1, preset: 'manyYears', resolutionUnit: 'YEAR' },
        { width: 80,    increment: 1,   resolution: 1, preset: 'manyYears', resolutionUnit: 'YEAR' },
        { width: 30,    increment: 1,   resolution: 1, preset: 'year', resolutionUnit: 'MONTH' },
        { width: 50,    increment: 1,   resolution: 1, preset: 'year', resolutionUnit: 'MONTH'},
        { width: 100,   increment: 1,   resolution: 1, preset: 'year', resolutionUnit: 'MONTH'},
        { width: 200,   increment: 1,   resolution: 1, preset: 'year', resolutionUnit: 'MONTH'},

        //MONTH
        { width: 100,   increment: 1,   resolution: 7, preset: 'monthAndYear', resolutionUnit: 'DAY'},
        { width: 30,    increment: 1,   resolution: 1, preset: 'weekDateAndMonth', resolutionUnit: 'DAY'},

        //WEEK
        { width: 35,    increment: 1,   resolution: 1, preset: 'weekAndMonth', resolutionUnit: 'DAY'},
        { width: 50,    increment: 1,   resolution: 1, preset: 'weekAndMonth', resolutionUnit: 'DAY'},
        { width: 20,    increment: 1,   resolution: 1, preset: 'weekAndDayLetter' },

        //DAY
        { width: 50,    increment: 1,   resolution: 1, preset: 'weekAndDay', resolutionUnit: 'HOUR'},
        { width: 100,   increment: 1,   resolution: 1, preset: 'weekAndDay', resolutionUnit: 'HOUR' },

        //HOUR
        { width: 50,    increment: 6,   resolution: 30, preset: 'hourAndDay', resolutionUnit: 'MINUTE' },
        { width: 100,   increment: 6,   resolution: 30, preset: 'hourAndDay', resolutionUnit: 'MINUTE' },
        { width: 60,    increment: 2,   resolution: 30, preset: 'hourAndDay', resolutionUnit: 'MINUTE' },
        { width: 60,    increment: 1,   resolution: 30, preset: 'hourAndDay', resolutionUnit: 'MINUTE' },

        //MINUTE
        { width: 30,    increment: 15,  resolution: 5, preset: 'minuteAndHour' },
        { width: 60,    increment: 15,  resolution: 5, preset: 'minuteAndHour' },
        { width: 130,   increment: 15,  resolution: 5, preset: 'minuteAndHour' },
        { width: 60,    increment: 5,   resolution: 5, preset: 'minuteAndHour' },
        { width: 100,   increment: 5,   resolution: 5, preset: 'minuteAndHour' },
        { width: 50,    increment: 2,   resolution: 1, preset: 'minuteAndHour' },

        //SECOND
        { width: 30,    increment: 10,  resolution: 5,  preset: 'secondAndMinute' },
        { width: 60,    increment: 10,  resolution: 5,  preset: 'secondAndMinute' },
        { width: 130,   increment: 5,   resolution: 5,  preset: 'secondAndMinute' }
    ],

    /**
     * @cfg {Int} minZoomLevel Minimal zoom level to which {@link #zoomOut} will work.
     */
    minZoomLevel        : null,

    /**
     * @cfg {Int} maxZoomLevel Maximal zoom level to which {@link zoomIn} will work.
     */
    maxZoomLevel        : null,


    /**
     * Integer number indicating the size of timespan during zooming. When zooming, the timespan is adjusted to make the scrolling area `visibleZoomFactor` times
     * wider than the scheduler size itself.
     */
    visibleZoomFactor   : 5,
    
    /**
     * @cfg {Boolean} zoomKeepsOriginalTimespan Whether the originally rendered timespan should be preserved while zooming. By default it is set to `false`,
     * meaning scheduler will adjust the currently rendered timespan to limit the amount of HTML content to render. When setting this option
     * to `true`, be careful not to allow to zoom a big timespan in seconds resolution for example. That will cause **a lot** of HTML content
     * to be rendered and affect performance. You can use {@link minZoomLevel} and {@link maxZoomLevel} config options for that.
     */
    zoomKeepsOriginalTimespan    : false,


    cachedCenterDate    : null,
    isFirstZoom         : true,
    isZooming           : false,


    initializeZooming: function () {
        //create instance-specific copy of zoomLevels
        this.zoomLevels         = this.zoomLevels.slice();

        this.setMinZoomLevel(this.minZoomLevel || 0);
        this.setMaxZoomLevel(this.maxZoomLevel !== null ? this.maxZoomLevel : this.zoomLevels.length - 1);

        this.on('viewchange', this.clearCenterDateCache, this);
    },


    getZoomLevelUnit : function (zoomLevel) {
        var headerConfig        = Sch.preset.Manager.getPreset(zoomLevel.preset).headerConfig;

        return headerConfig.bottom ? headerConfig.bottom.unit : headerConfig.middle.unit;
    },


    getMilliSecondsPerPixelForZoomLevel : function (level) {
        var DATE    = Sch.util.Date;

        // trying to convert the unit + increment to a number of milliseconds
        // this number is not fixed (month can be 28, 30 or 31 day), but at least this convertion
        // will be consistent (should be no DST changes at year 1
        return Math.round(
            (DATE.add(new Date(1, 0, 1), this.getZoomLevelUnit(level), level.increment) - new Date(1, 0, 1)) / level.width
        );
    },


    // XXX possibly merge into "calculateCurrentZoomLevel" and remove after
    presetToZoomLevel : function (presetName) {
        var preset              = Sch.preset.Manager.getPreset(presetName);
        var headerConfig        = preset.headerConfig;
        var bottom              = headerConfig.bottom;
        var middle              = headerConfig.middle;

        return {
            preset          : presetName,
            increment       : (bottom ? bottom.increment : middle.increment) || 1,
            resolution      : preset.timeResolution.increment,
            resolutionUnit  : preset.timeResolution.unit,
            width           : preset.timeColumnWidth
        };
    },


    calculateCurrentZoomLevel : function () {
        var zoomLevel       = this.presetToZoomLevel(this.viewPreset);
        var headerConfig    = this.timeAxis.headerConfig;
        var bottom          = headerConfig.bottom;
        var middle          = headerConfig.middle;

        // update the `width` of the zoomLevel
        zoomLevel.width     = this.timeAxis.preset.timeColumnWidth;
        zoomLevel.increment = (bottom ? bottom.increment : middle.increment) || 1;

        return zoomLevel;
    },


    getCurrentZoomLevelIndex : function () {
        var currentZoomLevel        = this.calculateCurrentZoomLevel();
        var currentFactor           = this.getMilliSecondsPerPixelForZoomLevel(currentZoomLevel);

        var zoomLevels              = this.zoomLevels;

        for (var i = 0; i < zoomLevels.length; i++) {
            var zoomLevelFactor     = this.getMilliSecondsPerPixelForZoomLevel(zoomLevels[ i ]);

            if (zoomLevelFactor == currentFactor) return i;

            // current zoom level is outside of pre-defined zoom levels
            if (i === 0 && currentFactor > zoomLevelFactor) return -0.5;
            if (i == zoomLevels.length - 1 && currentFactor < zoomLevelFactor) return zoomLevels.length - 1 + 0.5;

            var nextLevelFactor     = this.getMilliSecondsPerPixelForZoomLevel(zoomLevels[ i + 1 ]);

            if (zoomLevelFactor > currentFactor && currentFactor > nextLevelFactor) return i + 0.5;
        }

        throw "Can't find current zoom level index";
    },


    /**
    * Sets the {@link #maxZoomLevel} value.
    * @param {Int} level The level to limit zooming in to.
    */
    setMaxZoomLevel: function (level) {
        if (level < 0 || level >= this.zoomLevels.length) {
            throw new Error("Invalid range for `setMinZoomLevel`");
        }

        this.maxZoomLevel = level;
    },

    /**
    * Sets the {@link #minZoomLevel} value.
    * @param {Int} level The level to limit zooming out to.
    */
    setMinZoomLevel: function (level) {
        if (level < 0 || level >= this.zoomLevels.length) {
            throw new Error("Invalid range for `setMinZoomLevel`");
        }

        this.minZoomLevel = level;
    },


    // when zooming out, the precision for the center date becomes not so good (1px starts to contains too big time interval)
    // because of that zooming will be "floating"
    // to prevent that we cache the center date
    // cache will be cleared after any user scroll operation
    /** @ignore */
    getViewportCenterDateCached : function () {
        if (this.cachedCenterDate) return this.cachedCenterDate;

        return this.cachedCenterDate = this.getViewportCenterDate();
    },


    clearCenterDateCache : function () {
        this.cachedCenterDate = null;
    },


    /**
     * Allows zooming to certain level of {@link #zoomLevels} array. Automatically limits zooming between {@link #maxZoomLevel} 
     * and {@link #minZoomLevel}. Can also set time axis timespan to the supplied start and end dates.
     *
     * @param {Int} level Level to zoom to.
     * @param {Object} span The time frame. Used to set time axis timespan to the supplied start and end dates. If provided, the view
     * will be centered in this time interval
     * @param {Date} span.start The time frame start.
     * @param {Date} span.end The time frame end.
     *
     * @return {Int} level Current zoom level or null if it hasn't changed.
     */
    zoomToLevel: function (level, span) {
        level                       = Ext.Number.constrain(level, this.minZoomLevel, this.maxZoomLevel);

        var currentZoomLevel        = this.calculateCurrentZoomLevel();
        var currentFactor           = this.getMilliSecondsPerPixelForZoomLevel(currentZoomLevel);

        var nextZoomLevel           = this.zoomLevels[ level ];
        var nextFactor              = this.getMilliSecondsPerPixelForZoomLevel(nextZoomLevel);

        if (currentFactor == nextFactor && !span) {
            // already at requested zoom level
            return null;
        }

        var me                      = this;
        var view                    = this.getSchedulingView();
        var viewEl                  = view.getOuterEl();
        var scrollSource            = view.getScrollEventSource();

        if (this.isFirstZoom) {
            this.isFirstZoom = false;

            // clear the center date cache on any scroll operation
            scrollSource.on('scroll', this.clearCenterDateCache, this);
        }

        var isVertical              = this.orientation == 'vertical';

        var centerDate              = span ? new Date((span.start.getTime() + span.end.getTime()) / 2) : this.getViewportCenterDateCached();

        var panelSize               = isVertical ? viewEl.getHeight() : viewEl.getWidth();

        var presetCopy              = Ext.clone(Sch.preset.Manager.getPreset(nextZoomLevel.preset));
        
        var hasSpanProvided         = Boolean(span);

        span                        = span || this.calculateOptimalDateRange(centerDate, panelSize, nextZoomLevel);

        var headerConfig            = presetCopy.headerConfig;
        var bottom                  = headerConfig.bottom;
        var middle                  = headerConfig.middle;

        presetCopy[ isVertical ? 'rowHeight' : 'timeColumnWidth' ] = nextZoomLevel.width;

        if (bottom) {
            bottom.increment        = nextZoomLevel.increment;
        } else {
            middle.increment        = nextZoomLevel.increment;
        }

        this.isZooming              = true;

        this.viewPreset             = nextZoomLevel.preset;

        var unit                    = bottom ? bottom.unit : middle.unit;
        var timeAxis                = this.timeAxis;

        timeAxis.reconfigure({
            preset              : presetCopy,
            headerConfig        : headerConfig,

            unit                : unit,
            increment           : nextZoomLevel.increment,

            resolutionUnit      : Sch.util.Date.getUnitByName(nextZoomLevel.resolutionUnit || unit),
            resolutionIncrement : nextZoomLevel.resolution,

            weekStartDay        : this.weekStartDay,

            mainUnit            : middle.unit,
            shiftUnit           : presetCopy.shiftUnit,
            shiftIncrement      : presetCopy.shiftIncrement || 1,

            defaultSpan         : presetCopy.defaultSpan || 1,

            start               : span.start || this.getStart(),
            end                 : span.end || this.getEnd()
        });
        
        // re-calculate the center date after reconfiguring the timeaxis, 
        // because the actual start/end date may change because of time axis "autoAdjust" property
        if (hasSpanProvided) centerDate = new Date((timeAxis.getStart().getTime() + timeAxis.getEnd().getTime()) / 2);

        // restore the cached center date to keep it stable
        // this handler will be called 2nd after the clearing handler and will restore the cache
        // this handler will be called only for the programming scroll  called below
        scrollSource.on('scroll', function () { me.cachedCenterDate = centerDate; }, this, { single : true });

        if (isVertical) {
            var y = view.getYFromDate(centerDate, true);
            view.scrollVerticallyTo(y - panelSize / 2);
        } else {
            var x = view.getXFromDate(centerDate, true);
            view.scrollHorizontallyTo(x - panelSize / 2);
        }

        me.isZooming              = false;

        /**
         * @event zoomchange
         *
         * Fires after zoom level has been changed
         *
         * @param {Sch.mixin.SchedulerPanel} scheduler The scheduler object
         * @param {Integer} level The index of the new zoom level
         */
        this.fireEvent('zoomchange', this, level);

        return level;
    },

    /**
     * Sets time frame to specified range and applies zoom level which allows to fit all columns to this range.
     *
     * @param {Object} span The time frame.
     * @param {Date} span.start The time frame start.
     * @param {Date} span.end The time frame end.
     * @param {Object} config Configuration object containing following properties:
     * @param {Integer} config.adjustStart Set timeaxis start date to `adjustStart` time frame units earlier than span.start value. Use this to have some margin for comfortable reading. By default this set to `1`.
     * @param {Integer} config.adjustEnd Set timeaxis end date to `adjustEnd` time frame units after than span.end value. Use this to have some margin for comfortable reading. By default this set to `1`.
     *
     * @return {Int} level Current zoom level or null if it hasn't changed.
     */
    zoomToSpan : function (span, config) {
        if (span.start && span.end && span.start < span.end) {

            config = Ext.applyIf(config || {}, {
                adjustStart : 1,
                adjustEnd   : 1
            });

            var start       = span.start,
                end         = span.end,
                fnSame      = function (v) { return v; },
                adjustStart = fnSame,
                adjustEnd   = fnSame;

            if (this.timeAxis.autoAdjust) {

                if (config.adjustStart) {
                    adjustStart = function (start, unit, timeAxis) {
                        var result  = Sch.util.Date.add(start, timeAxis && timeAxis.mainUnit || unit, - config.adjustStart);

                        if (timeAxis) {
                            var adjusted    = timeAxis.getAdjustedDates(result, end);
                            return adjusted.start;
                        }

                        return result;
                    };
                }
                if (config.adjustEnd) {
                    adjustEnd   = function (end, unit, timeAxis) {
                        var result  = Sch.util.Date.add(end, timeAxis && timeAxis.mainUnit || unit, config.adjustEnd);

                        if (timeAxis) {
                            var adjusted    = timeAxis.getAdjustedDates(start, result);
                            return adjusted.end;
                        }

                        return result;
                    };
                }

            } else {

                if (config.adjustStart) {
                    adjustStart = function (start, unit) { return Sch.util.Date.add(start, unit, - config.adjustStart); };
                }
                if (config.adjustEnd) {
                    adjustEnd   = function (end, unit) { return Sch.util.Date.add(end, unit, config.adjustEnd); };
                }

            }

            var timeAxis    = Ext.create('Sch.data.TimeAxis');

            // get scheduling view width
            var width       = this.getSchedulingView().getTimeAxisViewModel().getAvailableWidth();

            // if potential width of col is less than col width provided by zoom level
            //   - we'll zoom out panel until col width fit into width from zoom level
            // and if width of column is more than width from zoom level
            //   - we'll zoom in until col width fit won't fit into width from zoom level

            var currLevel   = Math.floor(this.getCurrentZoomLevelIndex());

            // if we zoomed out even more than the highest zoom level - limit it to the highest zoom level
            if (currLevel == -1) currLevel = 0;

            var diffMS      = adjustEnd(end, this.timeAxis.mainUnit, this.timeAxis) - adjustStart(start, this.timeAxis.mainUnit, this.timeAxis),
                factor      = this.getMilliSecondsPerPixelForZoomLevel(this.zoomLevels[currLevel]),
                // increment to get next zoom level (-1 for zoom out and +1 - for zoom in)
                inc         = diffMS / factor > width ? -1 : 1,
                level       = currLevel + inc,
                sizeProp    = this.orientation == 'vertical' ? 'rowHeight' : 'timeColumnWidth';


            var zoomLevel, preset, unit, levelToZoom = null, unitToZoom = this.timeAxis.mainUnit;

            // loop over zoom levels
            while (level >= 0 && level <= this.zoomLevels.length - 1) {

                // get zoom level
                zoomLevel   = this.zoomLevels[level];

                //preset      = Sch.preset.Manager.getPreset(zoomLevel.preset);
                //unit        = (preset.headerConfig.bottom || preset.headerConfig.middle).unit;

                // get its preset copy
                preset      = Ext.clone(Sch.preset.Manager.getPreset(zoomLevel.preset));
                var bottom  = preset.headerConfig.bottom;
                var middle  = preset.headerConfig.middle;

                preset[sizeProp]        = zoomLevel.width;

                if (bottom) {
                    bottom.increment    = zoomLevel.increment;
                    unit                = bottom.unit;
                } else {
                    middle.increment    = zoomLevel.increment;
                    unit                = middle.unit;
                }

                // apply zoom level params to timeAxis
                Ext.apply(timeAxis, {
                    autoAdjust          : this.timeAxis.autoAdjust,
                    preset              : preset,
                    headerConfig        : preset.headerConfig,
                    unit                : unit,
                    increment           : zoomLevel.increment,
                    resolutionUnit      : Sch.util.Date.getUnitByName(zoomLevel.resolutionUnit || unit),
                    resolutionIncrement : zoomLevel.resolution,
                    mainUnit            : middle.unit,
                    shiftUnit           : preset.shiftUnit,
                    shiftIncrement      : preset.shiftIncrement || 1,
                    defaultSpan         : preset.defaultSpan || 1
                });

                diffMS      = adjustEnd(end, unit, timeAxis) - adjustStart(start, unit, timeAxis);
                factor      = this.getMilliSecondsPerPixelForZoomLevel(zoomLevel);

                // if zooming out
                if (inc < 0) {
                    // if columns fit into available space
                    if (diffMS / factor <= width) {
                        levelToZoom     = level;
                        unitToZoom      = unit;
                        // stop searching
                        break;
                    }
                // if zooming in
                } else {
                    // if columns fit into available space
                    if (diffMS / factor <= width) {
                        // if it's not currently active level
                        if (currLevel !== level - inc) {
                            // remember this level as applicable
                            levelToZoom     = level - inc;
                            unitToZoom      = unit;
                        }
                    } else {
                        // Sanity check to find the following case:
                        // If we're already zoomed in at the appropriate level, but the current zoomLevel is "too small" to fit and had to be expanded,
                        // there is an edge case where we should actually just stop and use the currently selected zoomLevel
                        break;
                    }
                }

                level += inc;
            }

            // If we didn't find a large/small enough zoom level, use the lowest/highest level
            levelToZoom = levelToZoom !== null ? levelToZoom : level-inc;

            return this.zoomToLevel(levelToZoom, {
                start   : adjustStart(start, unitToZoom),
                end     : adjustEnd(end, unitToZoom)
            });
        }

        return null;
    },

    /**
    * Zooms in Scheduler view following map of zoom levels. If the amount of levels to zoom is given, view will zoom in by this value.
    * Otheriwse a value of `1` will be used.
    *
    * @param {Int levels}[1] (optional) amount of levels to zoom in
    *
    * @return {Int} currentLevel New zoom level of the panel or null if level hasn't changed.
    */
    zoomIn: function (levels) {
        //if called without parameters or with 0, zoomIn by 1 level
        levels          = levels || 1;

        var currentZoomLevelIndex       = this.getCurrentZoomLevelIndex();

        if (currentZoomLevelIndex >= this.zoomLevels.length - 1) return null;

        return this.zoomToLevel(Math.floor(currentZoomLevelIndex) + levels);
    },

    /**
    * Zooms out Scheduler view following map of zoom levels. If the amount of levels to zoom is given, view will zoom out by this value.
    * Otheriwse a value of `1` will be used.
    *
    * @param {Int levels}[1] (optional) amount of levels to zoom out
    *
    * @return {Int} currentLevel New zoom level of the panel or null if level hasn't changed.
    */
    zoomOut: function(levels){
        //if called without parameters or with 0, zoomIn by 1 level
        levels          = levels || 1;

        var currentZoomLevelIndex       = this.getCurrentZoomLevelIndex();

        if (currentZoomLevelIndex <= 0) return null;

        return this.zoomToLevel(Math.ceil(currentZoomLevelIndex) - levels);
    },

    /**
    * Zooms in Scheduler view to the {@link maxZoomLevel} following map of zoom levels.
    *
    * @return {Int} currentLevel New zoom level of the panel or null if level hasn't changed.
    */
    zoomInFull: function () {
        return this.zoomToLevel(this.maxZoomLevel);
    },

    /**
    * Zooms out Scheduler view to the {@link minZoomLevel} following map of zoom levels.
    *
    * @return {Int} currentLevel New zoom level of the panel or null if level hasn't changed.
    */
    zoomOutFull: function () {
        return this.zoomToLevel(this.minZoomLevel);
    },


    /*
    * Adjusts the timespan of panel to the new zoom level. Used for performance reasons,
    * as rendering too many columns takes noticeable amount of time so their number is limited.
    */
    calculateOptimalDateRange: function (centerDate, panelSize, zoomLevel) {
        var timeAxis            = this.timeAxis;
        
        if (this.zoomKeepsOriginalTimespan) {
            return {
                start           : timeAxis.getStart(),
                end             : timeAxis.getEnd()
            };
        }
        
        var schDate             = Sch.util.Date;

        var headerConfig        = Sch.preset.Manager.getPreset(zoomLevel.preset).headerConfig;
        var topUnit             = headerConfig.top ? headerConfig.top.unit : headerConfig.middle.unit;

        var unit                = this.getZoomLevelUnit(zoomLevel);
//        this is weird, but we need to floor/ceil to the "topUnit" above, not the resolution unit..
//        var resolutionUnit      = zoomLevel.resolutionUnit ? schDate.getUnitByName(zoomLevel.resolutionUnit) : unit;

        var difference          = Math.ceil(panelSize / zoomLevel.width * zoomLevel.increment * this.visibleZoomFactor / 2);

        var startDate           = schDate.add(centerDate, unit, -difference);
        var endDate             = schDate.add(centerDate, unit, difference);

        return {
            start   : timeAxis.floorDate(startDate, false, topUnit),
            end     : timeAxis.ceilDate(endDate, false, topUnit)
        };
    }
});

/**

@class Sch.mixin.AbstractTimelinePanel
@private

A base mixin giving the consuming panel "time line" functionality. 
This means that the panel will be capable to display a list of "events", along a {@link Sch.data.TimeAxis time axis}.

This class should not be used directly.

*/

Ext.define('Sch.mixin.AbstractTimelinePanel', {
    requires: [
        'Sch.data.TimeAxis',
        'Sch.view.model.TimeAxis',
        'Sch.feature.ColumnLines',
        'Sch.preset.Manager'
    ],
    
    mixins: [
        'Sch.mixin.Zoomable'
    ],

    /**
     * @cfg {String} orientation An initial orientation of the view - can be either `horizontal` or `vertical`. Default value is `horizontal`.
     */
    orientation             : 'horizontal',

    /**
     * @cfg {Int} weekStartDay A valid JS date index between 0-6. (0: Sunday, 1: Monday etc.).
     */
    weekStartDay            : 1,

    /**
     * @cfg {Boolean} snapToIncrement true to snap to resolution increment while interacting with scheduled events.
     */
    snapToIncrement         : false,

    /**
     * @cfg {Boolean} readOnly true to disable editing.
     */
    readOnly                : false,

    /**
     * @cfg {Boolean} forceFit Set to true to force the time columns to fit to the available horizontal space.
     */
    forceFit                : false,

    /**
     * @cfg {String} eventResizeHandles Defines which resize handles to use for resizing events. Possible values: 'none', 'start', 'end', 'both'. Defaults to 'both'
     */
    eventResizeHandles      : 'both',

    /**
     * @cfg {Int} rowHeight The row height (used in horizontal mode only)
     */

    /**
     * @cfg {Sch.data.TimeAxis} timeAxis The backing store providing the input date data for the timeline panel.
     */
    timeAxis                : null,
    
    /**
     * @cfg {Boolean} autoAdjustTimeAxis The value for the {@link Sch.data.TimeAxis#autoAdjust} config option, which will be used
     * when creating the time axis instance. You can set this option to `false` to make the timeline panel start and end on the exact provided
     * {@link #startDate}/{@link #endDate} w/o adjusting them.
     */
    autoAdjustTimeAxis      : true,

    /**
     * @private
     * @cfg {Sch.view.model.TimeAxis/Object} timeAxisViewModel The backing view model for the visual representation of the time axis.
     * Either a real instance or a simple config object.
     */
    timeAxisViewModel       : null,

    /**
     * @cfg {Object} validatorFnScope
     * The scope used for the different validator functions.
     */

    /**
     * @cfg {String} viewPreset
     * @property {String} viewPreset
     * A key used to lookup a predefined {@link Sch.preset.ViewPreset} (e.g. 'weekAndDay', 'hourAndDay'), managed by {@link Sch.preset.Manager}. See {@link Sch.preset.Manager} for more information.
     */
    viewPreset              : 'weekAndDay',

    /**
     * @cfg {Boolean} trackHeaderOver `true` to highlight each header cell when the mouse is moved over it.
     */
    trackHeaderOver         : true,

    /**
     * @cfg {Date} startDate The start date of the timeline. If omitted, the start date of the provided {@link Sch.data.TimeAxis} will be used.
     * Defaults to the current date and time if no time axis has been provided.
     */
    startDate               : null,

    /**
     * @cfg {Date} endDate The end date of the timeline. If omitted, it will be calculated based on the {@link #startDate} setting and
     * the 'defaultSpan' property of the current {@link #viewPreset}.
     */
    endDate                 : null,

    columnLines             : true,
    trackMouseOver          : false,

    // If user supplied a 'rowHeight' config or a panel subclass with such a value - skip reading this setting
    // from the viewpreset
    readRowHeightFromPreset : true,

    /**
     * @cfg {Int} eventBorderWidth
     * The width of the border of your event, needed to calculate the correct start/end positions
     */
    eventBorderWidth        : 1,

    /**
    * Returns the orientation of this panel, "horizontal" or "vertical"
    * @return {String}  
    */
    getOrientation: function () {
        return this.orientation;
    },


    isHorizontal : function() {
        return this.getOrientation() === 'horizontal';
    },


    isVertical : function() {
        return !this.isHorizontal();
    },

    cellBorderWidth         : 1,
    cellTopBorderWidth      : 1,        // 0 since Ext JS 4.2.1
    cellBottomBorderWidth   : 1,

    // Must be called during initialization by consuming class
    _initializeTimelinePanel : function() {

        this.initializeZooming();

        this.renderers = [];

        this.readRowHeightFromPreset = !this.rowHeight;

        if (!this.timeAxis) {
            this.timeAxis = new Sch.data.TimeAxis({ autoAdjust : this.autoAdjustTimeAxis });
        }

        if (!this.timeAxisViewModel || !(this.timeAxisViewModel instanceof Sch.view.model.TimeAxis)) {
            var config = Ext.apply({
                snapToIncrement : this.snapToIncrement,
                forceFit        : this.forceFit,
                timeAxis        : this.timeAxis
            }, this.timeAxisViewModel || {});

            this.timeAxisViewModel = new Sch.view.model.TimeAxis(config);
        }

        this.timeAxisViewModel.on('update', this.onTimeAxisViewModelUpdate, this);
        this.timeAxisViewModel.refCount++;

        if (!this.viewPreset) {
            throw 'You must define a valid view preset object. See Sch.preset.Manager class for reference';
        }

        this.on('destroy', this.onPanelDestroyed, this);
        this.timeAxis.on('reconfigure', this.onTimeAxisReconfigure, this);

        this.addCls(['sch-timelinepanel', 'sch-' + this.orientation]);
    },

    onTimeAxisViewModelUpdate : function() {
        var view = this.getSchedulingView();

        if (view && view.viewReady) {
            view.refreshKeepingScroll();
        }
    },

    onPanelDestroyed : function() {
        this.timeAxisViewModel.un('update', this.onTimeAxisViewModelUpdate, this);
        this.timeAxisViewModel.refCount--;

        if (this.timeAxisViewModel.refCount <= 0) {
            this.timeAxisViewModel.destroy();
        }
        this.timeAxis.un('reconfigure', this.onTimeAxisReconfigure, this);
    },

    /**
    * @abstract
    * 
    * @return {Sch.mixin.AbstractSchedulerView} A view consuming the {@link Sch.mixin.AbstractSchedulerView} mixin
    */
    getSchedulingView: function () {
        throw 'Abstract method call';
    },

    /**
    * The {@link #readOnly} accessor. Use it to switch the `readonly` state. 
    */
    setReadOnly: function (readOnly) {
        this.getSchedulingView().setReadOnly(readOnly);
    },

    /**
    * Returns true if the panel is currently read only.
    * @return {Boolean} readOnly 
    */
    isReadOnly: function () {
        return this.getSchedulingView().isReadOnly();
    },

    /**
    * Switches the current view preset. See the {@link Sch.preset.Manager} class for details. Calling it will first fire a {@link #beforeviewchange} event,
    * followed by a {@link #viewchange} event. Returning `false` from any 'beforeviewchange' listener will cancel the switch.
    * 
    * @param {String} preset The name of the new preset
    * @param {Date} startDate (optional) A new start date for the time axis
    * @param {Date} endDate (optional) A new end date for the time axis
    */
    switchViewPreset: function (preset, startDate, endDate, initial) {

        // Timeaxis may already be configured, no need to reconfigure it
        if (initial && this.timeAxis.preset) {
            this.applyViewSettings(this.timeAxis.preset, initial);

            return;
        }

        if (this.fireEvent('beforeviewchange', this, preset, startDate, endDate) !== false) {
            if (Ext.isString(preset)) {
                this.viewPreset = preset;
                preset = Sch.preset.Manager.getPreset(preset);
            }

            if (!preset) {
                throw 'View preset not found';
            }

            var hConf = preset.headerConfig;

            var timeAxisCfg = {
                unit                : hConf.bottom ? hConf.bottom.unit : hConf.middle.unit,
                increment           : (hConf.bottom ? hConf.bottom.increment : hConf.middle.increment) || 1,
                resolutionUnit      : preset.timeResolution.unit,
                resolutionIncrement : preset.timeResolution.increment,

                weekStartDay        : this.weekStartDay,

                mainUnit            : hConf.middle.unit,
                shiftUnit           : preset.shiftUnit,

                headerConfig        : preset.headerConfig,
                shiftIncrement      : preset.shiftIncrement || 1,
                preset              : preset,
                defaultSpan         : preset.defaultSpan || 1
            };

            if (initial) {
                if (this.timeAxis.getCount() === 0 || startDate) {
                    timeAxisCfg.start = startDate || new Date();
                }
            } else {
                timeAxisCfg.start = startDate || this.timeAxis.getStart();
            }

            timeAxisCfg.end = endDate;
            this.timeAxis.reconfigure(timeAxisCfg);

            if (this.getOrientation() === 'horizontal') {
                this.getSchedulingView().scrollHorizontallyTo(0);
            } else {
                this.getSchedulingView().scrollVerticallyTo(0);
            }
        }
    },

    // Applies view specific settings from the preset about to be used
    applyViewSettings: function (preset, initial) {
        var view = this.getSchedulingView();

        view.setDisplayDateFormat(preset.displayDateFormat);

        if (this.orientation === 'horizontal') {
            view.setRowHeight(this.readRowHeightFromPreset ? preset.rowHeight : this.rowHeight, true);
        } else {
            // timeColumnWidth is used for row height in vertical mode
            var height = preset.timeColumnWidth || 60;

            view.setRowHeight(height, true);
            view.setColumnWidth(this.resourceColumnWidth || preset.resourceColumnWidth || 100, true);
        }
    },

    /**
    * Method to get a the current start date of the scheduler view
     * @return {Date} The start date
    */
    getStart: function () {
        return this.getStartDate();
    },

    /**
     * Method to get a the current start date of the scheduler view
     * @return {Date} The start date
     */
    getStartDate: function () {
        return this.timeAxis.getStart();
    },


    /**
    * Method to get a the current end date of the scheduler view
    * @return {Date} The end date
    */
    getEnd: function () {
        return this.getEndDate();
    },

    /**
     * Method to get a the current end date of the scheduler view
     * @return {Date} The end date
     */
    getEndDate: function () {
        return this.timeAxis.getEnd();
    },

    /**
    * Updates the widths of all time columns to the supplied value. Only applicable when forceFit is set to false on the view.
    * @param {Int} width The new time column width
    */
    setTimeColumnWidth: function (width, preventRefresh) {
        this.timeAxisViewModel.setTickWidth(width, preventRefresh);
    },

    /**
    * @return {Int} width The time column width
    */
    getTimeColumnWidth: function () {
        return this.timeAxisViewModel.getTickWidth();
    },

    // private
    onTimeAxisReconfigure: function (timeAxis) {
        // Apply view specific properties to the view
        // Subclass may decide which properties from the preset to use (orientation specific)
        this.applyViewSettings(timeAxis.preset);

        this.fireEvent('viewchange', this);
    },

    /**
    * Moves the time axis forward in time in units specified by the view preset 'shiftUnit', and by the amount specified by the parameter or by the shiftIncrement config of the current view preset.
    * @param {Int} amount (optional) The number of units to jump forward
    */
    shiftNext: function (amount) {
        this.suspendLayouts && this.suspendLayouts();

        this.timeAxis.shiftNext(amount);

        this.suspendLayouts && this.resumeLayouts(true);
    },

    /**
    * Moves the time axis backward in time in units specified by the view preset 'shiftUnit', and by the amount specified by the parameter or by the shiftIncrement config of the current view preset.
    * @param {Int} amount (optional) The number of units to jump backward
    */
    shiftPrevious: function (amount) {
        this.suspendLayouts && this.suspendLayouts();

        this.timeAxis.shiftPrevious(amount);

        this.suspendLayouts && this.resumeLayouts(true);
    },

    /**
    * Convenience method to go to current date.
    */
    goToNow: function () {
        this.setTimeSpan(new Date());
    },

    /**
    * Changes the time axis timespan to the supplied start and end dates.
    * @param {Date} start The new start date
    * @param {Date} end (Optional) The new end date. If not supplied, the {@link Sch.preset.ViewPreset#defaultSpan} property of the current view preset will be used to calculate the new end date.
    */
    setTimeSpan: function (start, end) {
        if (this.timeAxis) {
            this.timeAxis.setTimeSpan(start, end);
        }
    },

    /**
    * Changes the time axis start date to the supplied date.
    * @param {Date} amount The new start date
    */
    setStart: function (date) {
        this.setTimeSpan(date);
    },

    /**
    * Changes the time end start date to the supplied date.
    * @param {Date} amount The new end date
    */
    setEnd: function (date) {
        this.setTimeSpan(null, date);
    },

    /**
    * Returns the {@link Sch.data.TimeAxis} instance in use.
    * @return {Sch.data.TimeAxis}
    */
    getTimeAxis: function () {
        return this.timeAxis;
    },


    /**
    * Scrolls the time line to the specified `date`.
    * @param {Date} date The date to which to scroll the time line
    */
    scrollToDate: function (date, animate) {
        var view = this.getSchedulingView();
        var coordinate = view.getCoordinateFromDate(date, true);

        if (coordinate < 0) {
            // Not currently showing this date, adjust the timeaxis first
            var halfVisibleSpan = (this.timeAxis.getEnd() - this.timeAxis.getStart())/2;
            var me = this;

            this.setTimeSpan(new Date(date.getTime() - halfVisibleSpan), new Date(date.getTime() + halfVisibleSpan));

            // Need to wait for the view to refresh itself first
            setTimeout(function() {
                me.scrollToDate(date, animate);
            }, 20);

            return;
        }

        if(this.orientation === 'horizontal'){
            view.scrollHorizontallyTo(coordinate, animate);
        } 
        else {
            view.scrollVerticallyTo(coordinate, animate);
        }
    },

     /**
    * Returns the center date of the currently visible timespan of scheduler.
    *
    * @return {Date} date Center date for the viewport.
    */
    getViewportCenterDate: function(){
        var view       = this.getSchedulingView(),
            scroll     = view.getScroll(),
            xy;

        if (this.getOrientation() === 'vertical') {
            xy                 = [ 0, scroll.top + view.getViewportHeight() / 2 ];
        } else {     
            xy                 = [ scroll.left + view.getViewportWidth() / 2, 0 ];
        }

        return view.getDateFromXY(xy, null, true);
    },   

    addCls : function() {
        throw 'Abstract method call';
    },

    removeCls : function() {
        throw 'Abstract method call';
    },

    registerRenderer : function(fn, scope) {
        this.renderers.push({
            fn      : fn,
            scope   : scope
        });
    },

    deregisterRenderer : function(fn, scope) {
        Ext.each(this.renderers, function(rend, i) {
            if (fn === rend) {
                Ext.Array.removeAt(this.renderers, i);
                return false;
            }
        });
    }
});
/**

 @class Sch.mixin.TimelinePanel
 @extends Sch.mixin.AbstractTimelinePanel
 A base mixing for {@link Ext.panel.Panel} classes, giving to the consuming panel the "time line" functionality.
 This means that the panel will be capabale to display a list of "events", ordered on the {@link Sch.data.TimeAxis time axis}.

 Generally, should not be used directly, if you need to subclass the scheduler panel, subclass the {@link Sch.panel.SchedulerGrid} or {@link Sch.panel.SchedulerTree}
 instead.

*/

Ext.define('Sch.mixin.TimelinePanel', {
    extend : 'Sch.mixin.AbstractTimelinePanel',

    requires: [
        'Sch.util.Patch',

        'Sch.column.timeAxis.Horizontal',
        'Sch.preset.Manager'
    ],

    mixins: [
        'Sch.mixin.Zoomable',
        'Sch.mixin.Lockable'
    ],

    /**
    * @cfg {Object} lockedGridConfig A custom config object used to initialize the left (locked) grid panel.
    */

    /**
    * @cfg {Object} schedulerConfig A custom config object used to initialize the right (schedule) grid panel. 
    */

    /**
    * @cfg {Ext.Template} tooltipTpl 
    * Template used to show a tooltip over a scheduled item, null by default (meaning no tooltip). The tooltip will be populated with the data in 
    * record corresponding to the hovered element. See also {@link #tipCfg}.
    */

    /**
     * @cfg {Sch.mixin.TimelinePanel} partnerTimelinePanel A reference to another timeline panel that this panel should be 'partner' with.
     * If this config is supplied, this panel will:
     *
     * - Share and use the {@link Sch.data.TimeAxis} timeAxis from the partner panel.
     * - Synchronize the width of the two locked grid panels (after a drag of the splitter).
     * - Synchronize horizontal scrolling between two panels.
     */

    /**
    * @cfg {Object} tipCfg
    * The {@link Ext.Tooltip} config object used to configure a tooltip (only applicable if tooltipTpl is set).
    */
    tipCfg: {
        cls: 'sch-tip',

        showDelay: 1000,
        hideDelay: 0,

        autoHide: true,
        anchor: 'b'
    },
    
    inheritables: function() {

        return {
            // Configuring underlying table panel
            columnLines         : true,
            enableLocking       : true,
            lockable            : true,

            // EOF: Configuring underlying table panel

            // private
            initComponent: function () {
                if (this.partnerTimelinePanel) {
                    this.timeAxisViewModel = this.partnerTimelinePanel.timeAxisViewModel;
                    this.timeAxis = this.partnerTimelinePanel.getTimeAxis();
                    this.startDate  = this.timeAxis.getStart();
                    this.endDate    = this.timeAxis.getEnd();
                }

                // @COMPAT 2.2
                if (this.viewConfig && this.viewConfig.forceFit) this.forceFit = true;

                if (Ext.versions.extjs.isGreaterThanOrEqual("4.2.1")) {
                    this.cellTopBorderWidth = 0;
                }

                this._initializeTimelinePanel();

                this.configureColumns();

                var viewConfig = this.normalViewConfig = this.normalViewConfig || {};
                var id = this.getId();

                // Copy some properties to the view instance
                Ext.apply(this.normalViewConfig, {
                    id                      : id + '-timelineview',
                    eventPrefix             : this.autoGenId ? null : id,
                    timeAxisViewModel       : this.timeAxisViewModel,
                    eventBorderWidth        : this.eventBorderWidth,
                    timeAxis                : this.timeAxis,
                    readOnly                : this.readOnly,
                    orientation             : this.orientation,
                    rtl                     : this.rtl,
                    cellBorderWidth         : this.cellBorderWidth,
                    cellTopBorderWidth      : this.cellTopBorderWidth,
                    cellBottomBorderWidth   : this.cellBottomBorderWidth
                });

                Ext.Array.forEach(
                    [
                        "eventRendererScope",
                        "eventRenderer",
                        "dndValidatorFn",
                        "resizeValidatorFn",
                        "createValidatorFn",
                        "tooltipTpl",
                        "validatorFnScope",
                        "snapToIncrement",
                        "eventResizeHandles",
                        "enableEventDragDrop",
                        "enableDragCreation",
                        "resizeConfig",
                        "createConfig",
                        "tipCfg",
                        "getDateConstraints"
                    ],
                    function(prop) {
                      if (prop in this) viewConfig[prop] = this[prop];
                    },
                    this
                );

                this.mon(this.timeAxis, 'reconfigure', this.onMyTimeAxisReconfigure, this);

                this.addEvents(

                    /** 
                    * @event timeheaderclick
                    * Fires after a click on a time header cell
                    * @param {Sch.column.timeAxis.Horizontal} column The column object
                    * @param {Date} startDate The start date of the header cell
                    * @param {Date} endDate The start date of the header cell
                    * @param {Ext.EventObject} e The event object
                    */
                    'timeheaderclick',

                    /** 
                    * @event timeheaderdblclick
                    * Fires after a doubleclick on a time header cell
                    * @param {Sch.column.timeAxis.Horizontal} column The column object
                    * @param {Date} startDate The start date of the header cell
                    * @param {Date} endDate The start date of the header cell
                    * @param {Ext.EventObject} e The event object
                    */
                    'timeheaderdblclick',

                    /**
                    * @event beforeviewchange
                    * Fires before the current view changes to a new view type or a new time span. Return false to abort this action.
                    * @param {Sch.mixin.SchedulerPanel} scheduler The scheduler object
                    * @param {Object} preset The new preset
                    */
                    'beforeviewchange',

                    /**
                    * @event viewchange
                    * Fires after current view preset or time span has changed
                    * @param {Sch.mixin.SchedulerPanel} scheduler The scheduler object
                    */
                    'viewchange'
                );

                this.callParent(arguments);

                this.switchViewPreset(this.viewPreset, this.startDate || this.timeAxis.getStart(), this.endDate || this.timeAxis.getEnd(), true);

                var columnLines     = this.columnLines;
                
                if (columnLines) {
                    this.columnLinesFeature = new Sch.feature.ColumnLines(Ext.isObject(columnLines) ? columnLines : undefined);
                    this.columnLinesFeature.init(this);
                    
                    this.columnLines    = true;
                }

                this.relayEvents(this.getSchedulingView(), [
                    /**
                    * @event beforetooltipshow
                    * Fires before the event tooltip is shown, return false to suppress it.
                    * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
                    * @param {Sch.model.Event} eventRecord The event record of the clicked record
                    */
                    'beforetooltipshow'
                ]);

                this.on('afterrender', this.__onAfterRender, this);

                // HACK, required since Ext has an async scroll sync mechanism setup which won't play nice with our "sync scroll" above.
                this.on('zoomchange', function() {
                    // After a zoom, the header is resized and Ext JS TablePanel reacts to the size change.
                    // Ext JS reacts after a short delay, so we cancel this task to prevent Ext from messing up the scroll sync
                    this.normalGrid.scrollTask.cancel();
                });
            },

            getState: function () {
                var me = this,
                    state = me.callParent(arguments);
                    
                Ext.apply(state, {
                    viewPreset      : me.viewPreset,
                    startDate       : me.getStart(),
                    endDate         : me.getEnd(),
                    zoomMinLevel    : me.zoomMinLevel,
                    zoomMaxLevel    : me.zoomMaxLevel,
                    currentZoomLevel: me.currentZoomLevel
                });
                return state;
            },

            applyState: function (state) {
                var me = this;

                me.callParent(arguments);

                if (state && state.viewPreset) {
                    me.switchViewPreset(state.viewPreset, state.startDate, state.endDate);
                }
                if (state && state.currentZoomLevel){
                    me.zoomToLevel(state.currentZoomLevel);
                }
            }
        };
    },

    // private
    onMyTimeAxisReconfigure: function (timeAxis) {
        if (this.stateful && this.rendered) {
            this.saveState();
        }
    },

    onLockedGridItemDblClick : function(grid, record, el, rowIndex, event){
        if(this.orientation === 'vertical' && record) {
            this.fireEvent('timeheaderdblclick', this, record.get('start'), record.get('end'), rowIndex, event);
        }
    },

    /**
    * Returns the view which renders the schedule and time columns. This method should be used instead of the usual `getView`,
    * since `getView` will return an instance of a special "locking" grid view, which has no scheduler-specific features.
    * 
    * @return {Sch.mixin.SchedulerView} view A view implementing the {@link Sch.mixin.SchedulerView} mixin
    */
    getSchedulingView: function () {
        return this.normalGrid.getView();
    },

    getTimeAxisColumn : function () {
        if (!this.timeAxisColumn) {
            this.timeAxisColumn = this.down('timeaxiscolumn');
        }

        return this.timeAxisColumn;
    },

    configureColumns : function() {

        var columns         = this.columns || [];

        // The 'columns' config can also be a config object for Ext.grid.header.Container
        if (columns.items) {
            columns = columns.items;
        } else {
            // Clone it to make sure we handle the case of a column array object put on the class prototype
            columns = this.columns = columns.slice();
        }

        var lockedColumns   = [];
        var normalColumns   = [];

        // Split locked and normal columns first
        Ext.Array.each(columns, function (column) {
            if (column.position === 'right') {
                if (!Ext.isNumber(column.width)) {
                    Ext.Error.raise('"Right" columns must have a fixed width');
                }
                column.locked = false;

                normalColumns.push(column);
            } else {
                column.locked = true;
                lockedColumns.push(column);
            }
            column.lockable = false;
        });

        Ext.Array.erase(columns, 0, columns.length);
        Ext.Array.insert(columns, 0, lockedColumns.concat(
            {
                xtype                   : 'timeaxiscolumn',
                timeAxisViewModel       : this.timeAxisViewModel,
                trackHeaderOver         : this.trackHeaderOver,
                renderer                : this.mainRenderer,
                scope                   : this
            }
        ).concat(normalColumns));

        // Save reference to original set of columns
        this.horizontalColumns = Ext.Array.clone(columns);

        this.verticalColumns = [
            Ext.apply({
                xtype                   : 'verticaltimeaxis',
                width                   : 100,
                timeAxis                : this.timeAxis,
                timeAxisViewModel       : this.timeAxisViewModel,
                cellTopBorderWidth      : this.cellTopBorderWidth,
                cellBottomBorderWidth   : this.cellBottomBorderWidth
            }, this.timeAxisColumnCfg || {})
        ];

        if (this.orientation === 'vertical') {
            this.columns    = this.verticalColumns;
            this.store      = this.timeAxis;

            this.on('beforerender', function () {
                this.normalGrid.headerCt.add(this.createResourceColumns(this.resourceColumnWidth || this.timeAxis.preset.resourceColumnWidth));
            }, this);
        }
    },


    mainRenderer : function(val, meta, rowRecord, rowIndex, colIndex) {
        var rend = this.renderers,
            isHorizontal = this.orientation === 'horizontal',
            resource = isHorizontal ? rowRecord : this.resourceStore.getAt(colIndex),
            retVal = '&nbsp;'; // To ensure cells always consume correct height

        // Ext doesn't clear the meta object between cells
        meta.rowHeight = null;

        for (var i = 0; i < rend.length; i++) {
            retVal += rend[i].fn.call(rend[i].scope || this, val, meta, resource, rowIndex, colIndex) || '';
        }

        if (this.variableRowHeight) {
            // Set row height
            var view = this.getSchedulingView();
            var defaultRowHeight = isHorizontal ? view.getRowHeight() : this.timeAxisViewModel.getTickWidth();

            meta.style = 'height:' + ((meta.rowHeight || defaultRowHeight) - view.cellTopBorderWidth - view.cellBottomBorderWidth) + 'px';
        }

        return retVal;
    },

    // Child grids sync code
    // ---------------------------------
    __onAfterRender: function () {
        var me = this;

        me.normalGrid.on({
            collapse    : me.onNormalGridCollapse,
            expand      : me.onNormalGridExpand,
            scope       : me
        });

        me.lockedGrid.on({
            collapse    : me.onLockedGridCollapse,
            itemdblclick: me.onLockedGridItemDblClick,
            scope       : me
        });

        if (me.lockedGridDependsOnSchedule) {
            me.normalGrid.getView().on('itemupdate', me.onNormalViewItemUpdate, me);
        }

        if (this.partnerTimelinePanel) {
            if (this.partnerTimelinePanel.rendered) {
                this.setupPartnerTimelinePanel();
            } else {
                this.partnerTimelinePanel.on('afterrender', this.setupPartnerTimelinePanel, this);
            }
        }
    },


    onLockedGridCollapse : function() {
        if (this.normalGrid.collapsed) {
            this.normalGrid.expand();
        }
    },

    onNormalGridCollapse : function() {
        var me = this;

        //Hack for Gantt to prevent creating second expander when normal grid initially collapsed
        if(!me.normalGrid.reExpander){
            me.normalGrid.reExpander = me.normalGrid.placeholder;
        }

        if (!me.lockedGrid.rendered) {
            me.lockedGrid.on('render', me.onNormalGridCollapse, me, { delay: 1 });
        } else {
            me.lockedGrid.flex = 1;
            me.lockedGrid.doLayout();

            if (me.lockedGrid.collapsed) {
                me.lockedGrid.expand();
            }

            // Show a vertical scrollbar in locked grid if normal grid is collapsed
            me.addCls('sch-normalgrid-collapsed');
        }
    },

    onNormalGridExpand : function() {
        this.removeCls('sch-normalgrid-collapsed');

        delete this.lockedGrid.flex;
        this.lockedGrid.doLayout();
    },


    onNormalViewItemUpdate: function (record, index, oldRowEl) {
        if (this.lockedGridDependsOnSchedule) {
            var lockedView = this.lockedGrid.getView();

            lockedView.suspendEvents();
            lockedView.refreshNode(index);
            lockedView.resumeEvents();
        }
    },

    setupPartnerTimelinePanel : function () {

        // Sync locked grids by listening for splitter resize events of both locked grids.
        var otherPanel = this.partnerTimelinePanel;
        var externalSplitter = otherPanel.down('splitter');
        var ownSplitter = this.down('splitter');

        if (externalSplitter) {
            externalSplitter.on('dragend', function() {
                this.lockedGrid.setWidth(otherPanel.lockedGrid.getWidth());
            }, this);
        }

        if (ownSplitter) {
            ownSplitter.on('dragend', function() {
                otherPanel.lockedGrid.setWidth(this.lockedGrid.getWidth());
            }, this);
        }

        var lockedWidth = this.partnerTimelinePanel.lockedGrid.getWidth();
        this.lockedGrid.setWidth(lockedWidth);

        // sync scrolling with external timeline panel
        var otherViewEl  = this.partnerTimelinePanel.getSchedulingView().getEl(),
            ownViewEl = this.getSchedulingView().getEl();

        this.partnerTimelinePanel.mon(ownViewEl, 'scroll', function (e, el) {
            otherViewEl.scrollTo('left', el.scrollLeft);
        });

        this.mon(otherViewEl, 'scroll', function (e, el) {
            ownViewEl.scrollTo('left', el.scrollLeft);
        });
    }


    // EOF child grids sync code --------------------------
}, function () {
    var MIN_EXT_VERSION = '4.2.1';

    Ext.apply(Sch, {
        /*PKGVERSION*/VERSION : '2.2.15'
    });

    // DELETE THIS CHECK IF YOU WANT TO RUN AGAINST AN OLDER UNSUPPORTED EXT JS VERSION
    if (Ext.versions.extjs.isLessThan(MIN_EXT_VERSION)) {
        alert('The Ext JS version you are using needs to be updated to at least ' + MIN_EXT_VERSION);
    }
});
/**

@class Sch.panel.TimelineGridPanel
@extends Ext.grid.Panel
@mixin Sch.mixin.TimelinePanel

Internal class. 

*/
Ext.define("Sch.panel.TimelineGridPanel", {
    extend  : "Ext.grid.Panel",
    mixins  : ['Sch.mixin.TimelinePanel'],
    subGridXType            : 'gridpanel',

    requires : [
        'Sch.patches.ColumnResize'
    ],

    initComponent : function() {
        this.callParent(arguments);
        this.getSchedulingView()._initializeTimelineView();
    }
}, function() {
    this.override(Sch.mixin.TimelinePanel.prototype.inheritables() || {});
});
/**

@class Sch.panel.TimelineTreePanel
@extends Ext.tree.Panel
@mixin Sch.mixin.TimelinePanel

Internal class.

*/
Ext.define("Sch.panel.TimelineTreePanel", {
    extend      : "Ext.tree.Panel",
    requires    : [
        // need to require grid panel too here, because one of the sub-grids will be a normal grid
        'Ext.grid.Panel',
        'Ext.data.TreeStore',
        // will be used in the `setupLockableTree` of lockable mixin
        'Sch.mixin.FilterableTreeView',

        'Sch.patches.ColumnResizeTree'
    ],
    mixins      : ['Sch.mixin.TimelinePanel'],

    useArrows   : true,
    rootVisible : false,
    lockedXType : 'treepanel',

    initComponent : function() {
        this.callParent(arguments);
        this.getSchedulingView()._initializeTimelineView();
    }
}, function() { 
    this.override(Sch.mixin.TimelinePanel.prototype.inheritables() || {});
});
/**
@class Sch.plugin.Printable

Plugin (ptype = 'scheduler_printable') for printing an Ext Scheduler instance. Please note that this will not generate a picture perfect
 printed version, due to various limitations in the browser print implementations. If you require a high quality print, you should use the Export plugin instead and first export to PDF.

 To use this plugin, add it to scheduler as usual. The plugin will add an additional `print` method to the scheduler:

        var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
            ...

            resourceStore   : resourceStore,
            eventStore      : eventStore,

            plugins         : [
                Ext.create('Sch.plugin.Printable', {
                    // default values
                    docType             : '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">',
                    autoPrintAndClose   : true
                })
            ]
        });

        ...

        scheduler.print();


*/
Ext.define("Sch.plugin.Printable", {
    extend          : 'Ext.AbstractPlugin',

    alias           : 'plugin.scheduler_printable',

    lockableScope   : 'top',

    /**
     * @cfg {String} docType This is the DOCTYPE to use for the print window. It should be the same DOCTYPE as on your application page.
     */
    docType             : '<!DOCTYPE HTML>',

    /**
     * An empty function by default, but provided so that you can perform a custom action
     * before the print plugin extracts data from the scheduler.
     * @param {SchedulerPanel} scheduler The scheduler instance
     * @method beforePrint
     */
    beforePrint         : Ext.emptyFn,

    /**
     * An empty function by default, but provided so that you can perform a custom action
     * after the print plugin has extracted the data from the scheduler.
     * @param {SchedulerPanel} scheduler The scheduler instance
     * @method afterPrint
     */
    afterPrint          : Ext.emptyFn,

    /**
     * @cfg {Boolean} autoPrintAndClose True to automatically call print and close the new window after printing. Default value is `true`
     */
    autoPrintAndClose   : true,

     /**
     * @cfg {Boolean} fakeBackgroundColor True to reset background-color of events and enable use of border-width to fake background color (borders print by default in every browser). Default value is `true`
     */
    fakeBackgroundColor : true,

    scheduler           : null,


    constructor : function(config) {
        Ext.apply(this, config);
    },

    init : function(scheduler) {
        this.scheduler = scheduler;
        scheduler.print = Ext.Function.bind(this.print, this);
    },

    // private, the template for the new window
    mainTpl : new Ext.XTemplate('{docType}' +
          '<html class="' + Ext.baseCSSPrefix + 'border-box {htmlClasses}">' +
            '<head>' +
              '<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />' +
              '<title>{title}</title>' +
              '{styles}' +
            '</head>' +
            '<body class="sch-print-body {bodyClasses}">'+
                '<div class="sch-print-ct {componentClasses}" style="width:{totalWidth}px">'+
                    '<div class="sch-print-headerbg" style="border-left-width:{totalWidth}px;height:{headerHeight}px;"></div>'+
                    '<div class="sch-print-header-wrap">'+
                        '{[this.printLockedHeader(values)]}'+
                        '{[this.printNormalHeader(values)]}'+
                    '</div>'+
                    '{[this.printLockedGrid(values)]}'+
                    '{[this.printNormalGrid(values)]}'+
                '</div>' +
                '<script type="text/javascript">'+
                    '{setupScript}'+
                '</script>'+
            '</body>'+
          '</html>',
          {
            printLockedHeader: function(values){
                var str = '';

                if (values.lockedGrid){
                    str += '<div style="left:-'+values.lockedScroll+'px;margin-right:-'+values.lockedScroll+'px;width:'+(values.lockedWidth + values.lockedScroll)+'px"';
                    str += 'class="sch-print-lockedheader ' + values.lockedGrid.headerCt.el.dom.className + '">';
                    str +=     values.lockedHeader;
                    str += '</div>';
                }
                return str;
            },
            printNormalHeader: function(values){
                var str = '';

                if (values.normalGrid){
                    str += '<div style="left:'+(values.lockedGrid ? values.lockedWidth : '0')+'px;width:'+values.normalWidth+'px;" class="sch-print-normalheader '  + values.normalGrid.headerCt.el.dom.className + '">';
                    str +=     '<div style="margin-left:-'+values.normalScroll+'px">'+values.normalHeader+'</div>';
                    str += '</div>';
                }
                return str;
            },
            printLockedGrid: function(values){
                var str = '';

                if (values.lockedGrid){
                    str += '<div id="lockedRowsCt" style="left:-'+values.lockedScroll+'px;margin-right:-'+values.lockedScroll+'px;width:'+(values.lockedWidth + values.lockedScroll)+'px;top:'+values.headerHeight+'px;" class="sch-print-locked-rows-ct ' + values.innerLockedClasses + ' ' + Ext.baseCSSPrefix + 'grid-inner-locked">';
                    str +=     values.lockedRows;
                    str += '</div>';
                }
                return str;
            },
            printNormalGrid: function(values){
                var str = '';

                if (values.normalGrid){
                    str += '<div id="normalRowsCt" style="left:'+(values.lockedGrid ? values.lockedWidth : '0')+'px;top:'+values.headerHeight+'px;width:'+values.normalWidth+'px" class="sch-print-normal-rows-ct '+values.innerNormalClasses+'">';
                    str +=     '<div style="position:relative;overflow:visible;margin-left:-'+values.normalScroll+'px">'+values.normalRows+'</div>';
                    str += '</div>';
                }
                return str;
            }
          }),

    // private
    getGridContent : function(component) {
        var normalGrid = component.normalGrid,
            lockedGrid = component.lockedGrid,
            lockedView = lockedGrid.getView(),
            normalView = normalGrid.getView(),
            header, lockedRows, normalRows, lockedScroll, normalScroll,
            normalWidth, lockedWidth;

        this.beforePrint(component);

        if (lockedGrid.collapsed && !normalGrid.collapsed){
            normalWidth = lockedGrid.getWidth() + normalGrid.getWidth();
        } else {
            normalWidth = normalGrid.getWidth();
            lockedWidth = lockedGrid.getWidth();
        }

        // Render rows
        var records  = lockedView.store.getRange();
        lockedRows   = lockedView.tpl.apply(lockedView.collectData(records, 0));
        normalRows   = normalView.tpl.apply(normalView.collectData(records, 0));
        lockedScroll = lockedView.el.getScroll().left;
        normalScroll = normalView.el.getScroll().left;

        // Hide hidden columns
        var div = document.createElement('div');
        div.innerHTML = lockedRows;

        if (Ext.versions.extjs.isLessThan('4.2.1')) {
            lockedGrid.headerCt.items.each(function(column, i) {
                if (column.isHidden()) {
                    Ext.fly(div).down('colgroup:nth-child(' + (i+1) + ') col').setWidth(0);
                }
            });
        }

        lockedRows = div.innerHTML;

        // Print additional markup produced by lines plugins, zones plugins etc
        if (Sch.feature && Sch.feature.AbstractTimeSpan) {
            var toIterate = (component.plugins || []).concat(component.normalGrid.plugins || []).concat(component.columnLinesFeature || []);
            Ext.each(toIterate, function(plug) {
                if (plug instanceof Sch.feature.AbstractTimeSpan && plug.generateMarkup) {
                    normalRows = plug.generateMarkup(true) + normalRows;
                }
            });
        }

        this.afterPrint(component);

        return {
            normalHeader       : normalGrid.headerCt.el.dom.innerHTML,
            lockedHeader       : lockedGrid.headerCt.el.dom.innerHTML,
            lockedGrid         : lockedGrid.collapsed ? false : lockedGrid,
            normalGrid         : normalGrid.collapsed ? false : normalGrid,
            lockedRows         : lockedRows,
            normalRows         : normalRows,
            lockedScroll       : lockedScroll,
            normalScroll       : normalScroll,
            lockedWidth        : lockedWidth - (Ext.isWebKit ? 1 : 0),
            normalWidth        : normalWidth,
            headerHeight       : normalGrid.headerCt.getHeight(),
            innerLockedClasses : lockedGrid.view.el.dom.className,
            innerNormalClasses : normalGrid.view.el.dom.className + (this.fakeBackgroundColor ? ' sch-print-fake-background' : ''),
            width              : component.getWidth()
        };
    },

    getStylesheets : function() {
        return Ext.getDoc().select('link[rel="stylesheet"]');
    },

    /**
     * Prints a scheduler panel. This method will be aliased to the main scheduler instance, so you can call it directly:
     *
     *      scheduler.print()
     */
    print : function() {
        var component = this.scheduler;

        if (!(this.mainTpl instanceof Ext.Template)) {
            // Compile the tpl upon first call
            var headerRowHeight = 22;

            this.mainTpl = Ext.create("Ext.XTemplate", this.mainTpl, {
                compiled : true,
                disableFormats : true
            });
        }

        var v = component.getView(),
            styles = this.getStylesheets(),
            ctTmp = Ext.get(Ext.core.DomHelper.createDom({
                tag : 'div'
            })),
            styleFragment;

        styles.each(function(s) {
            ctTmp.appendChild(s.dom.cloneNode(true));
        });

        styleFragment = ctTmp.dom.innerHTML + '';

        var gridContent = this.getGridContent(component),
            html = this.mainTpl.apply(Ext.apply({
                waitText            : this.waitText,
                docType             : this.docType,
                htmlClasses         : Ext.getBody().parent().dom.className,
                bodyClasses         : Ext.getBody().dom.className,
                componentClasses    : component.el.dom.className,
                title               : (component.title || ''),
                styles              : styleFragment,
                totalWidth          : component.getWidth(),
                setupScript         : ("window.onload = function(){ (" + this.setupScript.toString() + ")(" +
                    component.syncRowHeight + ", " + this.autoPrintAndClose + ", " + Ext.isChrome + ", " + Ext.isIE +
                "); };")
            }, gridContent));

        // Assign to this for testability, need a reference to the opened window
        var win = window.open('', 'printgrid');
        this.printWindow = win;
        win.document.write(html);
        win.document.close();
    },

    // Script executed in the newly open window, to sync row heights
    setupScript : function (syncRowHeight, autoPrintAndClose, isChrome, isIE) {
        var syncHeightAndPrint  = function () {
            if (syncRowHeight) {
                var lockedTableCt = document.getElementById('lockedRowsCt'),
                    normalTableCt = document.getElementById('normalRowsCt'),

                    //checks added in case of hidden/collapsed grids
                    lockedRows = lockedTableCt && lockedTableCt.getElementsByTagName('tr'),
                    normalRows = normalTableCt && normalTableCt.getElementsByTagName('tr'),
                    count      = normalRows && lockedRows ? normalRows.length : 0;

                for (var i = 0; i < count; i++) {
                    var normalHeight    = normalRows[ i ].clientHeight;
                    var lockedHeight    = lockedRows[ i ].clientHeight;

                    var max             = Math.max(normalHeight, lockedHeight) + 'px';

                    lockedRows[ i ].style.height = normalRows[ i ].style.height = max;
                }
            }

            if (autoPrintAndClose) {
                window.print();
                // Chrome cannot print the page if you close the window being printed
                if (!isChrome) {
                    window.close();
                }
            }
        };

        if (isIE)
            // TODO: probably we don't need this anymore, as we now use window.onload to call setupScript
            setTimeout(syncHeightAndPrint, 0);
        else
            syncHeightAndPrint();
    }
});
/**
@class Sch.plugin.Export
@extends Ext.util.Observable

A plugin (ptype = 'scheduler_export') for generating PDF/PNG out of a Scheduler panel. NOTE: This plugin will make an Ajax request to the server, POSTing
 the HTML to be exported. The {@link #printServer} url must therefore be on the same domain as your application.

#Configuring/usage

To use this plugin, add it to your scheduler as any other plugin. It is also required to have [PhantomJS][1] and [Imagemagick][2]
installed on the server. The complete process of setting up a backend for this plugin can be found in the readme file inside export examples
as well as on our [blog][3]. Note that export is currently not supported if your view (or store) is buffered.

        var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
            ...

            resourceStore   : resourceStore,
            eventStore      : eventStore,

            plugins         : [
                Ext.create('Sch.plugin.Export', {
                    // default values
                    printServer: 'server.php'
                })
            ]
        });

Scheduler will be extended with three new methods:

* {@link #setFileFormat}, which allows setting the format to which panel should be exported. Default format is `pdf`.

* {@link #showExportDialog}, which shows export settings dialog

        scheduler.showExportDialog();

* {@link #doExport} which actually performs the export operation using {@link #defaultConfig} or provided config object :

        scheduler.doExport(
            {
                format: "A5",
                orientation: "landscape",
                range: "complete",
                showHeader: true,
                singlePageExport: false
            }
        );

#Export options

In the current state, plugin gives few options to modify the look and feel of the generated PDF document throught a dialog window :

{@img scheduler/images/export_dialog.png}

If no changes are made to the form, the {@link #defaultConfig} will be used.

##Export Range

This setting controls the timespan visible on the exported document. Three options are available here :

{@img scheduler/images/export_dialog_ranges.png}

###Complete schedule

Whole current timespan will be visible on the exported document.

###Date range

User can select the start and end dates (from the total timespan of the panel) visible on the exported document.

{@img scheduler/images/export_dialog_ranges_date.png}

###Current view

Timespan of the exported document/image will be set to the currently visible part of the time axis. User can control
the width of the time column and height of row.

{@img scheduler/images/export_dialog_ranges_current.png}

##Paper Format

This combo gives control of the size of the generated document/image by choosing one from a list of supported ISO paper sizes : (`A5`, `A4`, `A3`, `Letter`).
Generated PDF has a fixed DPI value of 72. Dafault format is `A4`.

{@img scheduler/images/export_dialog_format.png}

##Orientation

This setting defines the orientation of the generated document/image.

{@img scheduler/images/export_dialog_orientation.png}

Default option is the `portrait` (horizontal) orientation :

{@img scheduler/images/export_dialog_portrait.png}

Second option is the `landscape` (vertical) orientation :

{@img scheduler/images/export_dialog_landscape.png}

[1]: http://www.phantomjs.org
[2]: http://www.imagemagick.org
[3]: http://bryntum.com/blog

*/
Ext.define('Sch.plugin.Export', {
    extend                  : 'Ext.util.Observable',

    alternateClassName      : 'Sch.plugin.PdfExport',
    alias                   : 'plugin.scheduler_export',

    mixins                  : ['Ext.AbstractPlugin'],

    requires        : [
        'Ext.XTemplate'
    ],

    lockableScope           : 'top',

    /**
    * @cfg {String}
    * URL of the server responsible for running the export steps.
    */
    printServer             : undefined,

    //private template for the temporary export html page
    tpl                     : null,

    /**
    * @cfg {String}
    * Class name of the dialog used to change export settings.
    */
    exportDialogClassName   : 'Sch.widget.ExportDialog',

    /**
    * @cfg {Object}
    * Config object for the {@link #exportDialogClass}. Use this to override default values for the export dialog.
    */
    exportDialogConfig      : {},

    /**
    * @cfg {Object}
    * Default export configuration.
    */
    defaultConfig           : {
        format              : "A4",
        orientation         : "portrait",
        range               : "complete",
        showHeader          : true,
        singlePageExport    : false
    },

    /**
     * @cfg {Boolean} expandAllBeforeExport Only applicable for tree views, set to true to do a full expand prior to the export. Defaults to false.
     */
    expandAllBeforeExport   : false,

    /**
    * @private
    * @cfg {Object}
    * Predefined paper sizes in inches for different formats, as defined by ISO standards.
    */
    pageSizes               : {
        A5      : {
            width   : 5.8,
            height  : 8.3
        },
        A4      : {
            width   : 8.3,
            height  : 11.7
        },
        A3      : {
            width   : 11.7,
            height  : 16.5
        },
        Letter  : {
            width   : 8.5,
            height  : 11
        },
        Legal   : {
            width   : 8.5,
            height  : 14
        }
    },

    /**
    * @cfg {Boolean}
    * If set to true, open new window with the generated document after the operation has finished.
    */
    openAfterExport         : true,

    /**
     * An empty function by default, but provided so that you can perform a custom action
     * before the export plugin extracts data from the scheduler.
     * @param {SchedulerPanel} scheduler The scheduler instance
     * @param {Array[Object]} ticks The ticks gathered by plugin to export.
     * @method beforeExport
     */
    beforeExport            : Ext.emptyFn,

    /**
     * An empty function by default, but provided so that you can perform a custom action
     * after the export plugin has extracted the data from the scheduler.
     * @param {SchedulerPanel} scheduler The scheduler instance
     * @method afterExport
     */
    afterExport             : Ext.emptyFn,

    /**
    * @cfg {String}
    * Format of the exported file, selectable from `pdf` or `png`. By default plugin exports panel contents to PDF
    * but PNG file format is also available.
    */
    fileFormat              : 'pdf',

    //private Constant DPI value for generated PDF
    DPI                     : 72,

    constructor : function (config) {
        config = config || {};

        if (config.exportDialogConfig) {
            Ext.Object.each(this.defaultConfig, function(k, v, o){
                var configK = config.exportDialogConfig[k];
                if (configK) {
                    o[k] = configK;
                }
            });
        }

        this.callParent([ config ]);

        if (!this.tpl) {
            this.tpl = new Ext.XTemplate('<!DOCTYPE html>' +
                '<html class="' + Ext.baseCSSPrefix + 'border-box {htmlClasses}">' +
                    '<head>' +
                        '<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />' +
                        '<title>{column}/{row}</title>' +
                        '{styles}' +
                    '</head>' +
                    '<body class="' + Ext.baseCSSPrefix + 'webkit sch-export {bodyClasses}">' +
                        '<tpl if="showHeader">' +
                            '<div class="sch-export-header" style="width:{totalWidth}px"><h2>{column}/{row}</h2></div>' +
                        '</tpl>' +
                        '<div class="{componentClasses}" style="height:{bodyHeight}px; width:{totalWidth}px; position: relative !important">' +
                            '{HTML}' +
                        '</div>' +
                    '</body>' +
                '</html>',
                {
                    disableFormats: true
                }
            );
        }

        this.addEvents(
            /**
             * @event hidedialogwindow
             * Fires to hide the dialog window.
             */
            'hidedialogwindow',

            /**
             * @event showdialogerror
             * Fires to show error in the dialog window.
             * @param {String} message Error message to show in the dialog window.
             */
            'showdialogerror',

            /**
             * @event updateprogressbar
             * Fires when a progressbar of the {@link #exportDialogClassName dialog} should update it's value.
             * @param {Number} value Value (between 0 and 1) to set on the progressbar.
             */
            'updateprogressbar'
        );

        this.setFileFormat(this.fileFormat);
    },

    init : function (scheduler) {
        this.scheduler = scheduler;

        scheduler.showExportDialog = Ext.Function.bind(this.showExportDialog, this);
        scheduler.doExport         = Ext.Function.bind(this.doExport, this);
    },

    /**
    * Function for setting the {@link #fileFormat} of exporting panel. Can be either `pdf` or `png`.
    *
    * @param {String} format format of the file to set. Can take either `pdf` or `png`.
    */
    setFileFormat : function (format) {
        if (typeof format !== 'string') {
            this.fileFormat = 'pdf';
        } else {
            format = format.toLowerCase();

            if (format === 'png') {
                this.fileFormat = format;
            } else {
                this.fileFormat = 'pdf';
            }
        }
    },

    /**
    * Instantiates and shows a new {@link #exportDialogClassName} class using {@link #exportDialogConfig} config.
    * This popup should give user possibility to change export settings.
    */
    showExportDialog : function() {
        var me   = this,
            view = me.scheduler.getSchedulingView();

        //dialog window is always removed to avoid resetting its layout after hiding
        if (me.win) {
            me.win.destroy();
            me.win = null;
        }

        me.win  = Ext.create(me.exportDialogClassName, {
            plugin                  : me,
            exportDialogConfig      : Ext.apply({
                startDate       : me.scheduler.getStart(),
                endDate         : me.scheduler.getEnd(),
                rowHeight       : view.rowHeight,
                columnWidth     : view.timeAxisViewModel.getTickWidth(),
                defaultConfig   : me.defaultConfig
            }, me.exportDialogConfig)
        });

        me.saveRestoreData();

        me.win.show();
    },

    /*
    * @private
    * Save values to restore panel after exporting
    */
    saveRestoreData : function() {
        var component  = this.scheduler,
            view       = component.getSchedulingView(),
            normalGrid = component.normalGrid,
            lockedGrid = component.lockedGrid;

        //values needed to restore original size/dates of panel
        this.restoreSettings = {
            width           : component.getWidth(),
            height          : component.getHeight(),
            rowHeight       : view.rowHeight,
            columnWidth     : view.timeAxisViewModel.getTickWidth(),
            startDate       : component.getStart(),
            endDate         : component.getEnd(),
            normalWidth     : normalGrid.getWidth(),
            normalLeft      : normalGrid.getEl().getStyle('left'),
            lockedWidth     : lockedGrid.getWidth(),
            lockedCollapse  : lockedGrid.collapsed,
            normalCollapse  : normalGrid.collapsed
        };
    },

    /*
    * @private
    * Get links to the stylesheets of current page.
    */
    getStylesheets : function() {
        var styleSheets = Ext.getDoc().select('link[rel="stylesheet"]'),
            ctTmp = Ext.get(Ext.core.DomHelper.createDom({
                tag : 'div'
            })),
            stylesString;

        styleSheets.each(function(s) {
            ctTmp.appendChild(s.dom.cloneNode(true));
        });

        stylesString = ctTmp.dom.innerHTML + '';

        return stylesString;
    },

    /**
    * Function performing the export operation using config from arguments or default {@link #defaultConfig config}. After getting data
    * from the scheduler an XHR request to {@link #printServer} will be made with the following JSON encoded data :
    *
    * * `html` {Array}         - array of html strings containing data of each page
    * * `format` {String}      - paper size of the exported file
    * * `orientation` {String} - orientation of the exported file
    * * `range`       {String} - range of the exported file
    * * `fileFormat`  {String} - file format of the exported file
    *
    * @param {Object} [conf] Config options for exporting. If not provided, {@link #defaultConfig} is used.
    * Possible parameters are :
    *
    * * `format` {String}            - format of the exported document/image, selectable from the {@link #pageSizes} list.
    * * `orientation` {String}       - orientation of the exported document/image. Either `portrait` or `landscape`.
    * * `range` {String}             - range of the panel to be exported. Selectable from `complete`, `current`, `date`.
    * * `showHeader` {Boolean}       - boolean value defining if exported pages should have row/column numbers added in the headers.
    * * `singlePageExport` {Boolean} - boolean value defining if exported file should be divided into separate pages or not
    *
    * @param {Function} [callback] Optional function that will be called after successful response from export backend script.
    * @param {Function} [errback] Optional function that will be called if export backend script returns error.
    */
    doExport : function (conf, callback, errback) {
        // put mask on the panel
        this.mask();

        var me           = this,
            component    = me.scheduler,
            view         = component.getSchedulingView(),
            styles       = me.getStylesheets(),
            config       = conf || me.defaultConfig,
            normalGrid   = component.normalGrid,
            lockedGrid   = component.lockedGrid,
            headerHeight = normalGrid.headerCt.getHeight();

        // keep scheduler state to restore after export
        me.saveRestoreData();

        //expand grids in case they're collapsed
        normalGrid.expand();
        lockedGrid.expand();

        me.fireEvent('updateprogressbar', 0.1);

        // For Tree grid, optionally expand all nodes
        if (this.expandAllBeforeExport && component.expandAll) {
            component.expandAll();
        }

        var ticks           = component.timeAxis.getTicks(),
            timeColumnWidth = view.timeAxisViewModel.getTickWidth(),
            paperWidth,
            printHeight,
            paperHeight;

        //check if we're not exporting to single image as those calculations are not needed in this case
        if (!config.singlePageExport) {
            //size of paper we will be printing on. 72 DPI used by phantomJs generator
            //take orientation into account
            if (config.orientation === 'landscape') {
                paperWidth     = me.pageSizes[config.format].height*me.DPI;
                paperHeight    = me.pageSizes[config.format].width*me.DPI;
            } else {
                paperWidth     = me.pageSizes[config.format].width*me.DPI;
                paperHeight    = me.pageSizes[config.format].height*me.DPI;
            }

            var pageHeaderHeight = 41;

            printHeight = Math.floor(paperHeight) - headerHeight - (config.showHeader ? pageHeaderHeight : 0);
        }

        view.timeAxisViewModel.suppressFit = true;

        var skippedColsBefore   = 0;
        var skippedColsAfter    = 0;

        // if we export a part of scheduler
        if (config.range !== 'complete') {
            var newStart, newEnd;

            switch (config.range) {
                case 'date' :
                    newStart    = new Date(config.dateFrom);
                    newEnd      = new Date(config.dateTo);

                    // ensure that specified period has at least a day
                    if (Sch.util.Date.getDurationInDays(newStart, newEnd) < 1) {
                        newEnd  = Sch.util.Date.add(newEnd, Sch.util.Date.DAY, 1);
                    }

                    newStart    = Sch.util.Date.constrain(newStart, component.getStart(), component.getEnd());
                    newEnd      = Sch.util.Date.constrain(newEnd, component.getStart(), component.getEnd());
                    break;

                case 'current' :
                    var visibleSpan = view.getVisibleDateRange();
                    newStart        = visibleSpan.startDate;
                    newEnd          = visibleSpan.endDate || view.timeAxis.getEnd();

                    if (config.cellSize) {
                        // will change columns wiidth to provided value
                        timeColumnWidth = config.cellSize[0];

                        // change the row height only if value is provided
                        if (config.cellSize.length > 1) {
                            view.setRowHeight(config.cellSize[1]);
                        }
                    }
                    break;
            }

            // set specified time frame
            component.setTimeSpan(newStart, newEnd);

            var startTick   = Math.floor(view.timeAxis.getTickFromDate(newStart));
            var endTick     = Math.floor(view.timeAxis.getTickFromDate(newEnd));

            ticks       = component.timeAxis.getTicks();
            // filter only needed ticks
            ticks       = Ext.Array.filter(ticks, function (tick, index) {
                if (index < startTick) {
                    skippedColsBefore++;
                    return false;
                } else if (index > endTick) {
                    skippedColsAfter++;
                    return false;
                }
                return true;
            });
        }

        // run template method
        this.beforeExport(component, ticks);

        var format, htmlArray, calculatedPages;

        // multiple pages mode
        if (!config.singlePageExport) {

            component.setWidth(paperWidth);
            component.setTimeColumnWidth(timeColumnWidth);
            view.timeAxisViewModel.setTickWidth(timeColumnWidth);

            //calculate amount of pages in the document
            calculatedPages = me.calculatePages(config, ticks, timeColumnWidth, paperWidth, printHeight);

            htmlArray       = me.getExportJsonHtml(calculatedPages, {
                styles              : styles,
                config              : config,
                ticks               : ticks,
                skippedColsBefore   : skippedColsBefore,
                skippedColsAfter    : skippedColsAfter,
                printHeight         : printHeight,
                paperWidth          : paperWidth,
                headerHeight        : headerHeight
            });

            format          = config.format;

        // single page mode
        } else {

            htmlArray           = me.getExportJsonHtml(null, {
                styles              : styles,
                config              : config,
                ticks               : ticks,
                skippedColsBefore   : skippedColsBefore,
                skippedColsAfter    : skippedColsAfter,
                timeColumnWidth     : timeColumnWidth
            });

            var sizeInInches    = me.getRealSize(),
                width           = Ext.Number.toFixed(sizeInInches.width / me.DPI, 1),
                height          = Ext.Number.toFixed(sizeInInches.height / me.DPI, 1);

            format = width+'in*'+height+'in';
        }

        //further update progress bar
        me.fireEvent('updateprogressbar', 0.4);

        if (me.printServer) {

            // if it's not debugging or test environment
            if (!me.debug && !me.test) {
                Ext.Ajax.request({
                    type    : 'POST',
                    url     : me.printServer,
                    timeout : 60000,
                    params  : Ext.apply({
                        html        : {
                            array   : htmlArray
                        },
                        startDate   : component.getStartDate(),
                        endDate     : component.getEndDate(),
                        format      : format,
                        orientation : config.orientation,
                        range       : config.range,
                        fileFormat  : me.fileFormat
                    }, this.getParameters()),
                    success : function(response) {
                        me.onSuccess(response, callback, errback);
                    },
                    failure : function(response) {
                        me.onFailure(response, errback);
                    },
                    scope   : me
                });

            // for debugging mode we just show output instead of sending it to server
            } else if (me.debug) {

                var w, a = Ext.JSON.decode(htmlArray);
                for (var i = 0, l = a.length; i < l; i++) {
                    w = window.open();
                    w.document.write(a[i].html);
                    w.document.close();
                }

            }

        } else {
            throw 'Print server URL is not defined, please specify printServer config';
        }

        view.timeAxisViewModel.suppressFit = false;

        // restore scheduler state
        me.restorePanel();

        // run template method
        this.afterExport(component);

        // for test environment we return export results
        if (me.test) {
            return {
                htmlArray       : Ext.JSON.decode(htmlArray),
                calculatedPages : calculatedPages
            };
        }
    },
    
    /**
     * This method should return an object, that will be applied to the JSON data passed to the export XHR request.
     * By default this method returns empty object, it is supposed to be overriden in the subclass to provide some extra custom data.
     * 
     * @return {Object}
     */
    getParameters : function () {
        return {};
    },

    /*
    * @private
    * Function returning full width and height of both grids.
    *
    * @return {Object} values Object containing width and height properties.
    */
    getRealSize : function() {
        var component    = this.scheduler,
            headerHeight = component.normalGrid.headerCt.getHeight(),
            height       = (headerHeight + component.lockedGrid.getView().getEl().down('.' + Ext.baseCSSPrefix + 'grid-table').getHeight()),
            width        =  (component.lockedGrid.headerCt.getEl().first().getWidth() +
                component.normalGrid.body.select('.' + Ext.baseCSSPrefix + 'grid-table').first().getWidth());

        return {
            width   : width,
            height  : height
        };
    },

    /*
    * @private
    * Function calculating amount of pages in vertical/horizontal direction in the exported document/image.
    *
    * @param {Array} ticks Ticks from the TickStore.
    * @param {Int} timeColumnWidth Width of a single time column.
    * @return {Object} valuesObject Object containing calculated amount of pages, rows and columns.
    */
    calculatePages : function (config, ticks, timeColumnWidth, paperWidth, printHeight) {
        var me                  = this,
            component           = me.scheduler,
            lockedGrid          = component.lockedGrid,
            rowHeight           = component.getSchedulingView().rowHeight,
            lockedHeader        = lockedGrid.headerCt,
            lockedGridWidth     = lockedHeader.getEl().first().getWidth(),
            lockedColumnPages   = null,
            //amount of columns with locked grid visible
            columnsAmountLocked = 0;

        if (lockedGridWidth > lockedGrid.getWidth()) {
            var startCursor   = 0,
                endCursor     = 0,
                width         = 0,
                addItem       = false,
                columnWidth;

            lockedColumnPages = [];

            lockedGrid.headerCt.items.each(function(column, idx, len) {
                columnWidth = column.width;

                if (!width || width + columnWidth < paperWidth) {
                    width += columnWidth;
                    if (idx === len -1) {
                        addItem = true;

                        //we still need to check if any time columns fit
                        var widthLeft = paperWidth - width;
                        columnsAmountLocked = Math.floor(widthLeft / timeColumnWidth);
                    }
                } else {
                    addItem = true;
                }

                if (addItem) {
                    endCursor = idx;

                    lockedColumnPages.push({
                        firstColumnIdx    : startCursor,
                        lastColumnIdx     : endCursor,
                        totalColumnsWidth : width || columnWidth
                    });

                    startCursor = endCursor + 1;
                    width       = 0;
                }
            });
        } else {
            columnsAmountLocked = Math.floor((paperWidth - lockedGridWidth) / timeColumnWidth);
        }

        //amount of columns without locked grid visible
        var columnsAmountNormal = Math.floor(paperWidth / timeColumnWidth),
            //amount of pages horizontally
            columnPages         = Math.ceil((ticks.length - columnsAmountLocked) / columnsAmountNormal),
            rowsAmount          = Math.floor(printHeight/rowHeight);

        if (!lockedColumnPages || columnPages === 0) {
            columnPages += 1;
        }

        return {
            columnsAmountLocked : columnsAmountLocked,
            columnsAmountNormal : columnsAmountNormal,
            lockedColumnPages   : lockedColumnPages,
            rowsAmount          : rowsAmount,
            //amount of pages vertically
            rowPages            : Math.ceil(component.getSchedulingView().store.getCount()/rowsAmount),
            columnPages         : columnPages,
            timeColumnWidth     : timeColumnWidth,
            lockedGridWidth     : lockedGridWidth,
            rowHeight           : rowHeight,
            panelHTML           : {}
        };
    },

    /*
    * @private
    * Method exporting panel's HTML to JSON structure. This function is taking snapshots of the visible panel (by changing timespan
    * and hiding rows) and pushing their html to an array, which is then encoded to JSON.
    *
    * @param {Object} calculatedPages Object with values returned from {@link #calculatePages}.
    * @param {Object} params Object with additional properties needed for calculations.
    *
    * @return {Array} htmlArray JSON string created from an array of objects with stringified html.
    */
    getExportJsonHtml : function (calculatedPages, params) {
        var me                  = this,
            component           = me.scheduler,
            htmlArray           = [],

            //Remove any non-webkit browser-specific css classes
            re                  = new RegExp(Ext.baseCSSPrefix + 'ie\\d?|' + Ext.baseCSSPrefix + 'gecko', 'g'),
            bodyClasses         = Ext.getBody().dom.className.replace(re, ''),
            componentClasses    = component.el.dom.className,
            styles              = params.styles,
            config              = params.config,
            ticks               = params.ticks,
            panelHTML, readyHTML, htmlObject, html,
            timeColumnWidth;

        //Hack for IE
        if (Ext.isIE) {
            bodyClasses += ' sch-ie-export';
        }

        //we need to prevent Scheduler from auto adjusting the timespan
        component.timeAxis.autoAdjust = false;

        if (!config.singlePageExport) {
            var columnsAmountLocked = calculatedPages.columnsAmountLocked,
                columnsAmountNormal = calculatedPages.columnsAmountNormal,
                lockedColumnPages   = calculatedPages.lockedColumnPages,
                rowsAmount          = calculatedPages.rowsAmount,
                rowPages            = calculatedPages.rowPages,
                columnPages         = calculatedPages.columnPages,
                paperWidth          = params.paperWidth,
                printHeight         = params.printHeight,
                headerHeight        = params.headerHeight,
                lastColumn          = null,
                columns, lockedColumnPagesLen;

            timeColumnWidth = calculatedPages.timeColumnWidth;
            panelHTML       = calculatedPages.panelHTML;

            panelHTML.skippedColsBefore = params.skippedColsBefore;
            panelHTML.skippedColsAfter  = params.skippedColsAfter;

            if (lockedColumnPages) {
                lockedColumnPagesLen = lockedColumnPages.length;
                columnPages         += lockedColumnPagesLen;
            }

            //horizontal pages
            for (var i = 0; i < columnPages; i++) {

                //set visible time range to corresponding ticks
                if (lockedColumnPages && i < lockedColumnPagesLen) {
                    if (i === lockedColumnPagesLen - 1 && columnsAmountLocked !== 0) {
                        component.normalGrid.show();
                        lastColumn = Ext.Number.constrain((columnsAmountLocked-1), 0, (ticks.length - 1));
                        component.setTimeSpan(ticks[0].start, ticks[lastColumn].end);
                    } else {
                        component.normalGrid.hide();
                    }
                    var visibleColumns = lockedColumnPages[i];

                    this.showLockedColumns();
                    this.hideLockedColumns(visibleColumns.firstColumnIdx, visibleColumns.lastColumnIdx);

                    //resize lockedGrid to width of visible columns + 1px of border
                    component.lockedGrid.setWidth(visibleColumns.totalColumnsWidth+1);
                } else {

                    if (i === 0) {
                        this.showLockedColumns();

                        if (columnsAmountLocked !== 0) {
                            component.normalGrid.show();
                        }

                        lastColumn = Ext.Number.constrain(columnsAmountLocked - 1, 0, ticks.length - 1);
                        component.setTimeSpan(ticks[0].start, ticks[lastColumn].end);
                    } else {
                        //hide locked grid
                        component.lockedGrid.hide();

                        component.normalGrid.show();

                        if (lastColumn === null) {
                            //set lastColumn to -1 as it'll be incremented by 1, and in this case
                            //we want to start from 0
                            lastColumn = -1;
                        }

                        if (ticks[lastColumn+columnsAmountNormal]){
                            component.setTimeSpan(ticks[lastColumn+1].start, ticks[lastColumn+columnsAmountNormal].end);
                            lastColumn = lastColumn+columnsAmountNormal;
                        } else {
                            component.setTimeSpan(ticks[lastColumn+1].start, ticks[ticks.length-1].end);
                        }
                    }
                }

                //changing timespan resets column width
                component.setTimeColumnWidth(timeColumnWidth, true);
                component.getSchedulingView().timeAxisViewModel.setTickWidth(timeColumnWidth);

                //vertical pages
                for (var k = 0; k < rowPages; k+=1) {

                    //hide rows that are not supposed to be visible on the current page
                    me.hideRows(rowsAmount, k);

                    panelHTML.dom   = component.body.dom.innerHTML;
                    panelHTML.k     = k;
                    panelHTML.i     = i;

                    readyHTML       = me.resizePanelHTML(panelHTML);

                    html            = me.tpl.apply(Ext.apply({
                        bodyClasses      : bodyClasses,
                        bodyHeight       : printHeight + headerHeight,
                        componentClasses : componentClasses,
                        styles           : styles,
                        showHeader       : config.showHeader,
                        HTML             : readyHTML.dom.innerHTML,
                        totalWidth       : paperWidth,
                        headerHeight     : headerHeight,
                        column           : i+1,
                        row              : k+1
                    }));

                    htmlObject = {'html': html};
                    htmlArray.push(htmlObject);

                    //unhide all rows
                    me.showRows();
                }
            }

        } else {
            timeColumnWidth = params.timeColumnWidth;
            panelHTML = calculatedPages ? calculatedPages.panelHTML : {};

            component.setTimeSpan(ticks[0].start, ticks[ticks.length-1].end);
            component.lockedGrid.setWidth(component.lockedGrid.headerCt.getEl().first().getWidth());
            component.setTimeColumnWidth(timeColumnWidth);
            component.getSchedulingView().timeAxisViewModel.setTickWidth(timeColumnWidth);

            var realSize  = me.getRealSize();

            Ext.apply(panelHTML, {
                dom                 : component.body.dom.innerHTML,
                column              : 1,
                row                 : 1,
                timeColumnWidth     : params.timeColumnWidth,
                skippedColsBefore   : params.skippedColsBefore,
                skippedColsAfter    : params.skippedColsAfter
            });

            readyHTML   = me.resizePanelHTML(panelHTML);

            html        = me.tpl.apply(Ext.apply({
                bodyClasses      : bodyClasses,
                bodyHeight       : realSize.height,
                componentClasses : componentClasses,
                styles           : styles,
                showHeader       : false,
                HTML             : readyHTML.dom.innerHTML,
                totalWidth       : realSize.width
            }));

            htmlObject = {'html': html};
            htmlArray.push(htmlObject);
        }

        component.timeAxis.autoAdjust = true;

        return Ext.JSON.encode(htmlArray);
    },

    /*
    * @private
    * Resizes panel elements to fit on the print page. This has to be done manually in case of wrapping Scheduler
    * inside another, smaller component.
    *
    * @param {Object} HTML Object with html of panel, and row & column number.
    *
    * @return {Object} frag Ext.dom.Element with resized html.
    */
    resizePanelHTML: function (HTML) {
        //create empty div that will temporarily hold our panel current HTML
        var frag       = Ext.get(Ext.core.DomHelper.createDom({
                tag: 'div',
                html: HTML.dom
            })),
            component  = this.scheduler,
            lockedGrid = component.lockedGrid,
            normalGrid = component.normalGrid,
            lockedEl,
            lockedElements,
            normalElements;

        //HACK for resizing in IE6/7 and Quirks mode. Requires operating on a document fragment with DOM methods
        //instead of using unattached div and Ext methods.
        if (Ext.isIE6 || Ext.isIE7 || Ext.isIEQuirks){
            var dFrag = document.createDocumentFragment(),
                method, selector;

            //IE removed getElementById from documentFragment in later browsers
            if (dFrag.getElementById){
                method   = 'getElementById';
                selector = '';
            } else {
                method = 'querySelector';
                selector = '#';
            }

            dFrag.appendChild(frag.dom);

            lockedEl = lockedGrid.view.el;

            lockedElements = [
                dFrag[method](selector+component.id+'-targetEl'),
                dFrag[method](selector+component.id+'-innerCt'),
                dFrag[method](selector+lockedGrid.id),
                dFrag[method](selector+lockedGrid.body.id),
                dFrag[method](selector+lockedEl.id)
            ];
            normalElements = [
                dFrag[method](selector+normalGrid.id),
                dFrag[method](selector+normalGrid.headerCt.id),
                dFrag[method](selector+normalGrid.body.id),
                dFrag[method](selector+normalGrid.getView().id)
            ];

            Ext.Array.each(lockedElements, function(el){
                if(el !== null){
                    el.style.height = '100%';
                    el.style.width  = '100%';
                }
            });

            Ext.Array.each(normalElements, function(el, idx){
                if (el !== null){
                    if (idx === 1){
                        el.style.width = '100%';
                    } else {
                        el.style.height = '100%';
                        el.style.width  = '100%';
                    }
                }
            });

            frag.dom.innerHTML = dFrag.firstChild.innerHTML;
        } else {
            //this wasn't needed in real life, only for tests under 4.2 to pass
            lockedEl = lockedGrid.view.el;

            lockedElements = [
                frag.select('#'+component.id+'-targetEl').first(),
                frag.select('#'+component.id+'-innerCt').first(),
                frag.select('#'+lockedGrid.id).first(),
                frag.select('#'+lockedGrid.body.id).first(),
                frag.select('#'+lockedEl.id)
            ];
            normalElements = [
                frag.select('#'+normalGrid.id).first(),
                frag.select('#'+normalGrid.headerCt.id).first(),
                frag.select('#'+normalGrid.body.id).first(),
                frag.select('#'+normalGrid.getView().id).first()
            ];

            Ext.Array.each(lockedElements, function(el, idx){
                if(el){
                    el.setHeight('100%');
                    if (idx !== 3 && idx !== 2 ) {
                        el.setWidth('100%');
                    }
                }
            });

            Ext.Array.each(normalElements, function(el, idx){
                //don't change height of the header, just width
                if (idx === 1){
                    el.setWidth('100%');
                } else {
                    el.applyStyles({
                        height: '100%',
                        width: '100%'
                    });
                }
            });
        }

        return frag;
    },

    //Private used to prevent using old reference in the response callbacks
    getWin : function () {
        return this.win || null;
    },

    //Private.
    onSuccess : function (response, callback, errback) {
        var me  = this,
            win = me.getWin(),
            result;

        try {
            result = Ext.JSON.decode(response.responseText);
        } catch (e) {
            this.onFailure(response, errback);
            return;
        }

        //set progress to 100%
        me.fireEvent('updateprogressbar', 1);

        if (result.success) {
            //close print widget
            setTimeout(function() {

                //fire event for hiding window
                me.fireEvent('hidedialogwindow');
                me.unmask();

                if (me.openAfterExport) {
                    window.open(result.url, 'ExportedPanel');
                }
            }, win ? win.hideTime : 3000);
        } else {
            //show error message in print widget window
            me.fireEvent('showdialogerror', win, result.msg);
            me.unmask();
        }

        if (callback) {
            callback.call(this, response);
        }
    },

    //Private.
    onFailure : function (response, errback) {
        var win = this.getWin(),                     // Not JSON           // Decoded JSON ok
            msg = response.status === 200 ? response.responseText : response.statusText;

        this.fireEvent('showdialogerror', win, msg);
        this.unmask();

        if (errback) {
            errback.call(this, response);
        }
    },

    /*
    * @private
    * Hide rows from the panel that are not needed on current export page by adding css class to them.
    *
    * @param {Int} rowsAmount Amount of rows to be hidden.
    * @param {Int} page Current page number.
    */
    hideRows : function (rowsAmount, page) {
        var lockedRows = this.scheduler.lockedGrid.view.getNodes(),
            normalRows = this.scheduler.normalGrid.view.getNodes(),
            start      = rowsAmount * page,
            end        = start + rowsAmount;

        for (var i = 0, l = normalRows.length; i < l; i++) {
            if (i < start || i >= end) {
                lockedRows[i].className += ' sch-none';
                normalRows[i].className += ' sch-none';
            }
        }
    },

    /*
    * @private
    * Unhide all rows of the panel by removing the previously added css class from them.
    */
    showRows : function () {
        this.scheduler.getEl().select(this.scheduler.getSchedulingView().getItemSelector()).each(function(el){
            el.removeCls('sch-none');
        });
    },

    hideLockedColumns : function (startColumn, endColumn) {
        var lockedColumns = this.scheduler.lockedGrid.headerCt.items.items;

        for (var i = 0, l = lockedColumns.length; i < l; i++) {
            if (i < startColumn || i > endColumn) {
                lockedColumns[i].hide();
            }
        }
    },

    showLockedColumns : function () {
        this.scheduler.lockedGrid.headerCt.items.each(function(column){
            column.show();
        });
    },

    /*
    * @private
    * Mask the body, hiding panel to allow changing it's parameters in the background.
    */
    mask : function () {
        var mask = Ext.getBody().mask();
        mask.addCls('sch-export-mask');
    },

    //Private.
    unmask : function () {
        Ext.getBody().unmask();
    },

    /*
    * @private
    * Restore panel to pre-export state.
    */
    restorePanel : function () {
        var s      = this.scheduler,
            config = this.restoreSettings;

        s.setWidth(config.width);
        s.setHeight(config.height);
        s.setTimeSpan(config.startDate, config.endDate);
        s.setTimeColumnWidth(config.columnWidth, true);
        s.getSchedulingView().setRowHeight(config.rowHeight);
        s.lockedGrid.show();
        s.normalGrid.setWidth(config.normalWidth);
        s.normalGrid.getEl().setStyle('left', config.normalLeft);
        s.lockedGrid.setWidth(config.lockedWidth);

        if (config.lockedCollapse) {
            s.lockedGrid.collapse();
        }
        if (config.normalCollapse) {
            s.normalGrid.collapse();
        }
    },

    destroy : function () {
        if (this.win) {
            this.win.destroy();
        }
    }
});

/**
@class Sch.widget.ResizePicker
@private
@extends Ext.Panel

Size picker widget for changing columns width/rows height.

*/
Ext.define('Sch.widget.ResizePicker', {
    extend          : 'Ext.Panel',
    alias           : 'widget.dualrangepicker',
    width           : 200,
    height          : 200,
    border          : true,
    collapsible     : false,
    bodyStyle       : 'position:absolute; margin:5px',

    verticalCfg     : {
        height      : 120,
        value       : 24,
        increment   : 2,
        minValue    : 20,
        maxValue    : 80,
        reverse     : true,
        disabled    : true
    },

    horizontalCfg   : {
        width       : 120,
        value       : 100,
        minValue    : 25,
        increment   : 5,
        maxValue    : 200,
        disable     : true
    },

    initComponent : function () {
        var me = this;

        me.addEvents('change', 'changecomplete', 'select');

        me.horizontalCfg.value  = me.dialogConfig.columnWidth;
        me.verticalCfg.value    = me.dialogConfig.rowHeight;
        me.verticalCfg.disabled = me.dialogConfig.scrollerDisabled || false;

        me.dockedItems = [
            me.vertical     = new Ext.slider.Single(Ext.apply({
                dock        : 'left',
                style       : 'margin-top:10px',
                vertical    : true,
                listeners   : {
                    change          : me.onSliderChange,
                    changecomplete  : me.onSliderChangeComplete,
                    scope           : me
                }
            }, me.verticalCfg)),

            me.horizontal   = new Ext.slider.Single(Ext.apply({
                dock        : 'top',
                style       : 'margin-left:28px',
                listeners   : {
                    change          : me.onSliderChange,
                    changecomplete  : me.onSliderChangeComplete,
                    scope           : me
                }
            }, me.horizontalCfg))
        ];

        me.callParent(arguments);
    },

    afterRender : function () {
        var me = this;

        me.addCls('sch-ux-range-picker');
        me.valueHandle = this.body.createChild({
            cls : 'sch-ux-range-value',
            cn  : {
                tag: 'span'
            }
        });
        me.valueSpan = this.valueHandle.down('span');

        var dd = new Ext.dd.DD(this.valueHandle);

        Ext.apply(dd, {
            startDrag   : function () {
                me.dragging = true;
                this.constrainTo(me.body);
            },
            onDrag      : function () {
                me.onHandleDrag.apply(me, arguments);
            },
            endDrag     : function () {
                me.onHandleEndDrag.apply(me, arguments);
                me.dragging = false;
            },
            scope       : this
        });

        this.setValues(this.getValues());
        this.callParent(arguments);

        this.body.on('click', this.onBodyClick, this);
    },

    onBodyClick: function (e, t) {
        var xy = [e.getXY()[0] - 8 - this.body.getX(), e.getXY()[1] - 8 - this.body.getY()];

        this.valueHandle.setLeft(Ext.Number.constrain(xy[0], 0, this.getAvailableWidth()));
        this.valueHandle.setTop(Ext.Number.constrain(xy[1], 0, this.getAvailableHeight()));

        this.setValues(this.getValuesFromXY([this.valueHandle.getLeft(true), this.valueHandle.getTop(true)]));
        this.onSliderChangeComplete();
    },

    getAvailableWidth: function () {
        return this.body.getWidth() - 18;
    },

    getAvailableHeight: function () {
        return this.body.getHeight() - 18;
    },

    onHandleDrag: function () {
        this.setValues(this.getValuesFromXY([this.valueHandle.getLeft(true), this.valueHandle.getTop(true)]));
    },

    onHandleEndDrag: function () {
        this.setValues(this.getValuesFromXY([this.valueHandle.getLeft(true), this.valueHandle.getTop(true)]));
    },

    getValuesFromXY: function (xy) {
        var xFraction = xy[0] / this.getAvailableWidth();
        var yFraction = xy[1] / this.getAvailableHeight();

        var horizontalVal = Math.round((this.horizontalCfg.maxValue - this.horizontalCfg.minValue) * xFraction);
        var verticalVal = Math.round((this.verticalCfg.maxValue - this.verticalCfg.minValue) * yFraction) + this.verticalCfg.minValue;

        return [horizontalVal + this.horizontalCfg.minValue, verticalVal];
    },

    getXYFromValues: function (values) {
        var xRange = this.horizontalCfg.maxValue - this.horizontalCfg.minValue;
        var yRange = this.verticalCfg.maxValue - this.verticalCfg.minValue;

        var x = Math.round((values[0] - this.horizontalCfg.minValue) * this.getAvailableWidth() / xRange);

        var verticalVal = values[1] - this.verticalCfg.minValue;
        var y = Math.round(verticalVal * this.getAvailableHeight() / yRange);

        return [x, y];
    },

    updatePosition: function () {
        var values = this.getValues();
        var xy = this.getXYFromValues(values);

        this.valueHandle.setLeft(Ext.Number.constrain(xy[0], 0, this.getAvailableWidth()));
        if (this.verticalCfg.disabled){
            this.valueHandle.setTop(this.dialogConfig.rowHeight);
        } else {
            this.valueHandle.setTop(Ext.Number.constrain(xy[1], 0, this.getAvailableHeight()));
        }

        this.positionValueText();
        this.setValueText(values);
    },

    positionValueText: function () {
        var handleTop = this.valueHandle.getTop(true);
        var handleLeft = this.valueHandle.getLeft(true);

        this.valueSpan.setLeft(handleLeft > 30 ? -30 : 10);
        this.valueSpan.setTop(handleTop > 10 ? -20 : 20);
    },

    setValueText: function(values){
        if (this.verticalCfg.disabled) values[1] = this.dialogConfig.rowHeight;
        this.valueSpan.update('[' + values.toString() + ']');
    },

    setValues: function (values) {
        this.horizontal.setValue(values[0]);

        if (this.verticalCfg.reverse) {
            if (!this.verticalCfg.disabled) this.vertical.setValue(this.verticalCfg.maxValue + this.verticalCfg.minValue - values[1]);
        } else {
            if (!this.verticalCfg.disabled) this.vertical.setValue(values[1]);
        }

        if (!this.dragging) {
            this.updatePosition();
        }
        this.positionValueText();

        this.setValueText(values);
    },

    getValues: function () {
        if (!this.verticalCfg.disabled) {
            var verticalVal = this.vertical.getValue();

            if (this.verticalCfg.reverse) {
                verticalVal = this.verticalCfg.maxValue - verticalVal + this.verticalCfg.minValue;
            }

            return [this.horizontal.getValue(), verticalVal];

        }

        return [this.horizontal.getValue()];
    },

    onSliderChange: function () {
        this.fireEvent('change', this, this.getValues());

        if (!this.dragging) {
            this.updatePosition();
        }
    },

    onSliderChangeComplete: function () {
        this.fireEvent('changecomplete', this, this.getValues());
    },

    afterLayout: function () {
        this.callParent(arguments);
        this.updatePosition();
    }
});

/**
 @class Sch.widget.ExportDialogForm
 @private
 @extends Ext.form.Panel

 Form for {@link Sch.widget.ExportDialog}. This is a private class and can be overriden by providing `formPanel` option to
 {@link Sch.plugin.Export#cfg-exportDialogConfig exportDialogConfig}.
 */
Ext.define('Sch.widget.ExportDialogForm', {
    extend      : 'Ext.form.Panel',
    requires    : [
        'Ext.ProgressBar',
        'Ext.form.field.ComboBox',
        'Ext.form.field.Date',
        'Ext.form.FieldContainer',
        'Ext.form.field.Checkbox',
        'Sch.widget.ResizePicker'
    ],
    border      : false,
    bodyPadding : '10 10 0 10',
    autoHeight  : true,

    initComponent : function () {
        var me = this;

        // HACK
        // fix for tooltip width
        // http://www.sencha.com/forum/showthread.php?260106-Tooltips-on-forms-and-grid-are-not-resizing-to-the-size-of-the-text
        if (Ext.getVersion('extjs').isLessThan('4.2.1')) {
            if (typeof Ext.tip !== 'undefined' && Ext.tip.Tip && Ext.tip.Tip.prototype.minWidth != 'auto') {
                Ext.tip.Tip.prototype.minWidth      = 'auto';
            }
        }

        me.createFields();

        Ext.apply(this, {
            fieldDefaults   : {
                labelAlign  : 'left',
                labelWidth  : 120,
                anchor      : '99%'
            },
            items           : [
                me.rangeField,
                me.resizerHolder,
                me.datesHolder,
                me.showHeaderField,
                me.exportToSingleField,
                me.formatField,
                me.orientationField,

                me.progressBar || me.createProgressBar()
            ]
        });

        me.callParent(arguments);

        me.onRangeChange(null, me.dialogConfig.defaultConfig.range);

        me.on({
            hideprogressbar     : me.hideProgressBar,
            showprogressbar     : me.showProgressBar,
            updateprogressbar   : me.updateProgressBar,
            scope               : me
        });
    },

    isValid : function () {
        var me  = this;
        if (me.rangeField.getValue() === 'date') return me.dateFromField.isValid() && me.dateToField.isValid();

        return true;
    },

    getValues : function (asString, dirtyOnly, includeEmptyText, useDataValues) {
        var result      = this.callParent(arguments);

        var cellSize    = this.resizePicker.getValues();
        if (!asString) {
            result.cellSize = cellSize;
        } else {
            result += '&cellSize[0]='+cellSize[0]+'&cellSize[1]='+cellSize[1];
        }

        return result;
    },

    createFields : function () {
        var me                  = this,
            cfg                 = me.dialogConfig,
            beforeLabelTextTpl  = '<table class="sch-fieldcontainer-label-wrap"><td width="1" class="sch-fieldcontainer-label">',
            afterLabelTextTpl   = '<td><div class="sch-fieldcontainer-separator"></div></table>';

        me.rangeField = new Ext.form.field.ComboBox({
            value           : cfg.defaultConfig.range,
            triggerAction   : 'all',
            cls             : 'sch-export-dialog-range',
            forceSelection  : true,
            editable        : false,
            fieldLabel      : cfg.rangeFieldLabel,
            name            : 'range',
            queryMode       : 'local',
            displayField    : 'name',
            valueField      : 'value',
            store           : Ext.create('Ext.data.Store', {
                fields  : ['name', 'value'],
                data    : [
                    { name : cfg.completeViewText,  value : 'complete' },
                    { name : cfg.dateRangeText,     value : 'date' },
                    { name : cfg.currentViewText,   value : 'current' }
                ]
            }),
            listeners      : {
                change  : me.onRangeChange,
                scope   : me
            }
        });

        // col/row resizer
        me.resizePicker = new Sch.widget.ResizePicker({
            dialogConfig    : cfg,
            margin          : '10 20'
        });

        me.resizerHolder    = new Ext.form.FieldContainer({
            fieldLabel          : cfg.scrollerDisabled ? cfg.adjustCols : cfg.adjustColsAndRows,
            labelAlign          : 'top',
            hidden              : true,
            labelSeparator      : '',
            beforeLabelTextTpl  : beforeLabelTextTpl,
            afterLabelTextTpl   : afterLabelTextTpl,
            layout              : 'vbox',
            defaults            : {
                flex        : 1,
                allowBlank  : false
            },
            items               : [me.resizePicker]
        });

        // from date
        me.dateFromField = new Ext.form.field.Date({
            fieldLabel  : cfg.dateRangeFromText,
            baseBodyCls : 'sch-exportdialogform-date',
            name        : 'dateFrom',
            format      : cfg.dateRangeFormat || Ext.Date.defaultFormat,
            allowBlank  : false,
            maxValue    : cfg.endDate,
            minValue    : cfg.startDate,
            value       : cfg.startDate
        });

        // till date
        me.dateToField = new Ext.form.field.Date({
            fieldLabel  : cfg.dateRangeToText,
            name        : 'dateTo',
            format      : cfg.dateRangeFormat || Ext.Date.defaultFormat,
            baseBodyCls : 'sch-exportdialogform-date',
            allowBlank  : false,
            maxValue    : cfg.endDate,
            minValue    : cfg.startDate,
            value       : cfg.endDate
        });

        // date fields holder
        me.datesHolder  = new Ext.form.FieldContainer({
            fieldLabel          : cfg.specifyDateRange,
            labelAlign          : 'top',
            hidden              : true,
            labelSeparator      : '',
            beforeLabelTextTpl  : beforeLabelTextTpl,
            afterLabelTextTpl   : afterLabelTextTpl,
            layout              : 'vbox',
            defaults            : {
                flex        : 1,
                allowBlank  : false
            },
            items               : [me.dateFromField, me.dateToField]
        });

        me.showHeaderField = new Ext.form.field.Checkbox({
            xtype       : 'checkboxfield',
            boxLabel    : me.dialogConfig.showHeaderLabel,
            name        : 'showHeader',
            checked     : !!cfg.defaultConfig.showHeaderLabel
        });

        me.exportToSingleField = new Ext.form.field.Checkbox({
            xtype       : 'checkboxfield',
            boxLabel    : me.dialogConfig.exportToSingleLabel,
            name        : 'singlePageExport',
            checked     : !!cfg.defaultConfig.singlePageExport
        });

        me.formatField = new Ext.form.field.ComboBox({
            value          : cfg.defaultConfig.format,
            triggerAction  : 'all',
            forceSelection : true,
            editable       : false,
            fieldLabel     : cfg.formatFieldLabel,
            name           : 'format',
            queryMode      : 'local',
            store          : ["A5", "A4", "A3", "Letter", "Legal"]
        });

        var orientationLandscapeCls = cfg.defaultConfig.orientation === "portrait" ? 'class="sch-none"' : '',
            orientationPortraitCls = cfg.defaultConfig.orientation === "landscape" ? 'class="sch-none"' : '';

        me.orientationField = new Ext.form.field.ComboBox({
            value          : cfg.defaultConfig.orientation,
            triggerAction  : 'all',
            baseBodyCls    : 'sch-exportdialogform-orientation',
            forceSelection : true,
            editable       : false,
            fieldLabel     : me.dialogConfig.orientationFieldLabel,
            afterSubTpl    : new Ext.XTemplate('<span id="sch-exportdialog-imagePortrait" ' + orientationPortraitCls +
                '></span><span id="sch-exportdialog-imageLandscape" ' + orientationLandscapeCls + '></span>'),
            name           : 'orientation',
            displayField   : 'name',
            valueField     : 'value',
            queryMode      : 'local',
            store          : Ext.create('Ext.data.Store', {
                fields : ['name', 'value'],
                data   : [
                    { name : cfg.orientationPortraitText, value : 'portrait' },
                    { name : cfg.orientationLandscapeText, value : 'landscape' }
                ]
            }),
            listeners      : {
                change : function (field, newValue) {
                    switch (newValue) {
                        case 'landscape':
                            Ext.fly('sch-exportdialog-imagePortrait').toggleCls('sch-none');
                            Ext.fly('sch-exportdialog-imageLandscape').toggleCls('sch-none');
                            break;
                        case 'portrait':
                            Ext.fly('sch-exportdialog-imagePortrait').toggleCls('sch-none');
                            Ext.fly('sch-exportdialog-imageLandscape').toggleCls('sch-none');
                            break;
                    }
                }
            }
        });
    },

    createProgressBar : function () {
        return this.progressBar = new Ext.ProgressBar({
            text    : this.config.progressBarText,
            animate : true,
            hidden  : true,
            margin  : '4px 0 10px 0'
        });
    },

    onRangeChange : function (field, newValue) {
        switch (newValue) {
            case 'complete':
                this.datesHolder.hide();
                this.resizerHolder.hide();
                break;
            case 'date':
                this.datesHolder.show();
                this.resizerHolder.hide();
                break;
            case 'current':
                this.datesHolder.hide();
                this.resizerHolder.show();
                this.resizePicker.expand(true);
                break;
        }
    },

    showProgressBar : function () {
        if (this.progressBar) this.progressBar.show();
    },

    hideProgressBar : function () {
        if (this.progressBar) this.progressBar.hide();
    },

    updateProgressBar : function (value) {
        if (this.progressBar) this.progressBar.updateProgress(value);
    }
});

/**
 @class Sch.widget.ExportDialog
 @private
 @extends Ext.window.Window

 Widget for export options.

 */
Ext.define('Sch.widget.ExportDialog', {
    alternateClassName  : 'Sch.widget.PdfExportDialog',
    extend              : 'Ext.window.Window',
    requires            : ['Sch.widget.ExportDialogForm'],
    mixins              : ['Sch.mixin.Localizable'],
    alias               : "widget.exportdialog",

    //Panel settings. Overridable with {@link Sch.plugin.Export#cfg-exportDialogConfig}
    modal               : false,
    width               : 350,
    cls                 : 'sch-exportdialog',
    frame               : false,
    layout              : 'fit',
    draggable           : true,
    padding             : 0,

    //Private
    plugin              : null,

    /**
     * @cfg {Ext.Component} buttonsPanel Component with buttons controlling export.
     */
    buttonsPanel        : null,

    /**
     * @cfg {Object} buttonsPanelScope
     * The scope for the {@link #buttonsPanel}
     */
    buttonsPanelScope   : null,

    /**
     * @cfg {Ext.Component} progressBar Progress bar component.
     */
    progressBar         : null,

    /**
     * @cfg {String} generalError Text used for displaying errors, when no error message was returned from the server.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} formatFieldLabel Text used as a label for the paper format setting.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} orientationFieldLabel Text used as a label for the orientation setting.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} rangeFieldLabel Text used as a label for the export range setting.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} showHeaderLabel Text used as a label for the showing/hiding of page numbers checkbox.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} exportToSingleLabel Text used as a label for the checkbox defining if export should create single page.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} orientationPortraitText Text used for the portrait orientation setting.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} orientationLandscapeText Text used for the landscape orientation setting.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} completeViewText Text used for the complete view export range setting.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} currentViewText Text used for the current view export range setting.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} dateRangeText Text used for the date range export range setting.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} dateRangeFromText Text indicating the start of timespan when exporting a date range.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} pickerText Text used as a legend for the row/column picker.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} dateRangeToText Text indicating the end of timespan when exporting a date range.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} exportButtonText Text displayed on the button starting the export operation.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} cancelButtonText Text displayed on the button cancelling the export and hiding the dialog.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} progressBarText Text displayed on the progress bar while exporting.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - generalError                : 'An error occured, try again.',
            - title                       : 'Export Settings',
            - formatFieldLabel            : 'Paper format',
            - orientationFieldLabel       : 'Orientation',
            - rangeFieldLabel             : 'Export range',
            - showHeaderLabel             : 'Add page number',
            - orientationPortraitText     : 'Portrait',
            - orientationLandscapeText    : 'Landscape',
            - completeViewText            : 'Complete schedule',
            - currentViewText             : 'Current view',
            - dateRangeText               : 'Date range',
            - dateRangeFromText           : 'Export from',
            - pickerText                  : 'Resize column/rows to desired value',
            - dateRangeToText             : 'Export to',
            - exportButtonText            : 'Export',
            - cancelButtonText            : 'Cancel',
            - progressBarText             : 'Exporting...',
            - exportToSingleLabel         : 'Export as single page'
     */

    /**
     * @cfg {String} dateRangeFormat Valid date format to be used by the date ranges fields.
     */
    dateRangeFormat : '',

    constructor : function (config) {
        Ext.apply(this, config.exportDialogConfig);

        Ext.Array.forEach(
            [
                'generalError',
                'title',
                'formatFieldLabel',
                'orientationFieldLabel',
                'rangeFieldLabel',
                'showHeaderLabel',
                'orientationPortraitText',
                'orientationLandscapeText',
                'completeViewText',
                'currentViewText',
                'dateRangeText',
                'dateRangeFromText',
                'pickerText',
                'dateRangeToText',
                'exportButtonText',
                'cancelButtonText',
                'progressBarText',
                'exportToSingleLabel'
            ],
            function (prop) {
                if (prop in config) this[prop] = config[prop];
            },
            this
        );

        this.title = this.L('title');

        //store fields texts in the config object for further use by form
        this.config = Ext.apply({
            progressBarText          : this.L('progressBarText'),
            dateRangeToText          : this.L('dateRangeToText'),
            pickerText               : this.L('pickerText'),
            dateRangeFromText        : this.L('dateRangeFromText'),
            dateRangeText            : this.L('dateRangeText'),
            currentViewText          : this.L('currentViewText'),
            formatFieldLabel         : this.L('formatFieldLabel'),
            orientationFieldLabel    : this.L('orientationFieldLabel'),
            rangeFieldLabel          : this.L('rangeFieldLabel'),
            showHeaderLabel          : this.L('showHeaderLabel'),
            exportToSingleLabel      : this.L('exportToSingleLabel'),
            orientationPortraitText  : this.L('orientationPortraitText'),
            orientationLandscapeText : this.L('orientationLandscapeText'),
            completeViewText         : this.L('completeViewText'),
            adjustCols               : this.L('adjustCols'),
            adjustColsAndRows        : this.L('adjustColsAndRows'),
            specifyDateRange         : this.L('specifyDateRange'),
            dateRangeFormat          : this.dateRangeFormat,
            defaultConfig            : this.defaultConfig
        }, config.exportDialogConfig);

        this.callParent(arguments);
    },

    initComponent : function () {
        var me          = this,
            listeners   = {
                hidedialogwindow    : me.destroy,
                showdialogerror     : me.showError,
                updateprogressbar   : function (value) {
                    me.fireEvent('updateprogressbar', value);
                },
                scope               : this
            };

        me.form         = me.buildForm(me.config);

        Ext.apply(this, {
            items : me.form,
            fbar  : me.buildButtons(me.buttonsPanelScope || me)
        });

        me.callParent(arguments);

        me.plugin.on(listeners);
    },

    afterRender : function () {
        var me = this;

        me.relayEvents(me.form.resizePicker, ['change', 'changecomplete', 'select']);

        me.form.relayEvents(me, ['updateprogressbar', 'hideprogressbar', 'showprogressbar']);

        me.callParent(arguments);
    },

    /**
     * Create Dialog's buttons.
     *
     * @param {Object} buttonsScope Scope for the buttons.
     * @return {Object} buttons Object containing buttons for Exporting/Cancelling export.
     */
    buildButtons : function (buttonsScope) {
        return [
            {
                xtype   : 'button',
                scale   : 'medium',
                text    : this.L('exportButtonText'),
                handler : function () {
                    if (this.form.isValid()) {
                        this.fireEvent('showprogressbar');
                        this.plugin.doExport(this.form.getValues());
                    }
                },
                scope   : buttonsScope
            },
            {
                xtype   : 'button',
                scale   : 'medium',
                text    : this.L('cancelButtonText'),
                handler : function () {
                    this.destroy();
                },
                scope   : buttonsScope
            }
        ];
    },

    /**
     * Build the {@link Sch.widget.ExportDialogForm} for the dialog window.
     *
     * @param {Object} config Config object for the form, containing field names and values.
     * @return {@link Sch.widget.ExportDialogForm} form
     */
    buildForm : function (config) {
        return new Sch.widget.ExportDialogForm({
            progressBar  : this.progressBar,
            dialogConfig : config
        });
    },

    /**
     * @private
     * Displays error message in the dialog. When it's called, both form and buttons are hidden. Dialog will be automatically
     * hidden after {@link #hideTime} time.
     *
     * @param {String} (optional) error Text of the message that will be displayed in the dialog. If not provided, {@link #generalError}
     * will be used.
     */
    showError : function (dialog, error) {
        var me = dialog,
            text = error || me.L('generalError');

        me.fireEvent('hideprogressbar');
        Ext.Msg.alert('', text);
    }
});


Ext.define('Gnt.locale.En', {
    extend      : 'Sch.locale.Locale',
    requires    : 'Sch.locale.En',
    singleton   : true,

    l10n        : {
        'Gnt.util.DurationParser' : {
            unitsRegex : {
                MILLI       : /^ms$|^mil/i,
                SECOND      : /^s$|^sec/i,
                MINUTE      : /^m$|^min/i,
                HOUR        : /^h$|^hr$|^hour/i,
                DAY         : /^d$|^day/i,
                WEEK        : /^w$|^wk|^week/i,
                MONTH       : /^mo|^mnt/i,
                QUARTER     : /^q$|^quar|^qrt/i,
                YEAR        : /^y$|^yr|^year/i
            }
        },

        'Gnt.field.Duration' : {
            invalidText : 'Invalid duration value'
        },

        'Gnt.feature.DependencyDragDrop' : {
            fromText    : 'From: <strong>{0}</strong> - {1}<br/>',
            toText      : 'To: <strong>{0}</strong> - {1}',
            startText   : 'Start',
            endText     : 'End'
        },

        'Gnt.Tooltip' : {
            startText       : 'Starts: ',
            endText         : 'Ends: ',
            durationText    : 'Duration: '
        },

        'Gnt.plugin.TaskContextMenu' : {
            newTaskText         : 'New task',
            deleteTask          : 'Delete task(s)',
            editLeftLabel       : 'Edit left label',
            editRightLabel      : 'Edit right label',
            add                 : 'Add...',
            deleteDependency    : 'Delete dependency...',
            addTaskAbove        : 'Task above',
            addTaskBelow        : 'Task below',
            addMilestone        : 'Milestone',
            addSubtask          : 'Sub-task',
            addSuccessor        : 'Successor',
            addPredecessor      : 'Predecessor',
            convertToMilestone  : 'Convert to milestone',
            convertToRegular    : 'Convert to regular task'
        },

        'Gnt.plugin.DependencyEditor' : {
            fromText            : 'From',
            toText              : 'To',
            typeText            : 'Type',
            lagText             : 'Lag',
            endToStartText      : 'Finish-To-Start',
            startToStartText    : 'Start-To-Start',
            endToEndText        : 'Finish-To-Finish',
            startToEndText      : 'Start-To-Finish'
        },

        'Gnt.widget.calendar.Calendar' : {
            dayOverrideNameHeaderText : 'Name',
            overrideName        : 'Name',
            startDate           : 'Start Date',
            endDate             : 'End Date',
            error               : 'Error',
            dateText            : 'Date',
            addText             : 'Add',
            editText            : 'Edit',
            removeText          : 'Remove',
            workingDayText      : 'Working day',
            weekendsText        : 'Weekends',
            overriddenDayText   : 'Overridden day',
            overriddenWeekText  : 'Overridden week',
            workingTimeText     : 'Working time',
            nonworkingTimeText  : 'Non-working time',
            dayOverridesText    : 'Day overrides',
            weekOverridesText   : 'Week overrides',
            okText              : 'OK',
            cancelText          : 'Cancel',
            parentCalendarText  : 'Parent calendar',
            noParentText        : 'No parent',
            selectParentText    : 'Select parent',
            newDayName          : '[Without name]',
            calendarNameText    : 'Calendar name',
            tplTexts            : {
                tplWorkingHours : 'Working hours for',
                tplIsNonWorking : 'is non-working',
                tplOverride     : 'override',
                tplInCalendar   : 'in calendar',
                tplDayInCalendar: 'standard day in calendar',
                tplBasedOn      : 'Based on'
            },
            overrideErrorText   : 'There is already an override for this day',
            overrideDateError   : 'There is already a week override on this date: {0}',
            startAfterEndError  : 'Start date should be less than end date',
            weeksIntersectError : 'Week overrides should not intersect'
        },

        'Gnt.widget.calendar.AvailabilityGrid' : {
            startText           : 'Start',
            endText             : 'End',
            addText             : 'Add',
            removeText          : 'Remove',
            error               : 'Error'
        },

        'Gnt.widget.calendar.DayEditor' : {
            workingTimeText     : 'Working time',
            nonworkingTimeText  : 'Non-working time'
        },

        'Gnt.widget.calendar.WeekEditor' : {
            defaultTimeText     : 'Default time',
            workingTimeText     : 'Working time',
            nonworkingTimeText  : 'Non-working time',
            error               : 'Error',
            noOverrideError     : "Week override contains only 'default' days - can't save it"
        },

        'Gnt.widget.calendar.ResourceCalendarGrid' : {
            name        : 'Name',
            calendar    : 'Calendar'
        },

        'Gnt.widget.calendar.CalendarWindow' : {
            ok      : 'Ok',
            cancel  : 'Cancel'
        },

        'Gnt.field.Assignment' : {
            cancelText : 'Cancel',
            closeText  : 'Save and Close'
        },

        'Gnt.column.AssignmentUnits' : {
            text : 'Units'
        },

        'Gnt.column.Duration' : {
            text : 'Duration'
        },

        'Gnt.column.Effort' : {
            text : 'Effort'
        },

        'Gnt.column.EndDate' : {
            text : 'Finish'
        },

        'Gnt.column.PercentDone' : {
            text : '% Done'
        },

        'Gnt.column.ResourceAssignment' : {
            text : 'Assigned Resources'
        },

        'Gnt.column.ResourceName' : {
            text : 'Resource Name'
        },

        'Gnt.column.SchedulingMode' : {
            text : 'Mode'
        },

        'Gnt.column.Predecessor' : {
            text : 'Predecessors'
        },

        'Gnt.column.Successor' : {
            text : 'Successors'
        },

        'Gnt.column.StartDate' : {
            text : 'Start'
        },

        'Gnt.column.WBS' : {
            text : 'WBS'
        },

        'Gnt.column.Sequence' : {
            text : '#'
        },

        'Gnt.widget.taskeditor.TaskForm' : {
            taskNameText            : 'Name',
            durationText            : 'Duration',
            datesText               : 'Dates',
            baselineText            : 'Baseline',
            startText               : 'Start',
            finishText              : 'Finish',
            percentDoneText         : 'Percent Complete',
            baselineStartText       : 'Start',
            baselineFinishText      : 'Finish',
            baselinePercentDoneText : 'Percent Complete',
            effortText              : 'Effort',
            invalidEffortText       : 'Invalid effort value',
            calendarText            : 'Calendar',
            schedulingModeText      : 'Scheduling Mode'
        },

        'Gnt.widget.DependencyGrid' : {
            idText                      : 'ID',
            taskText                    : 'Task Name',
            blankTaskText               : 'Please select task',
            invalidDependencyText       : 'Invalid dependency',
            parentChildDependencyText   : 'Dependency between child and parent found',
            duplicatingDependencyText   : 'Duplicate dependency found',
            transitiveDependencyText    : 'Transitive dependency',
            cyclicDependencyText        : 'Cyclic dependency',
            typeText                    : 'Type',
            lagText                     : 'Lag',
            clsText                     : 'CSS class',
            endToStartText              : 'Finish-To-Start',
            startToStartText            : 'Start-To-Start',
            endToEndText                : 'Finish-To-Finish',
            startToEndText              : 'Start-To-Finish'
        },

        'Gnt.widget.AssignmentEditGrid' : {
            confirmAddResourceTitle : 'Confirm',
            confirmAddResourceText  : 'Resource &quot;{0}&quot; not found in list. Would you like to add it?',
            noValueText             : 'Please select resource to assign',
            noResourceText          : 'No resource &quot;{0}&quot; found in the list'
        },

        'Gnt.widget.taskeditor.TaskEditor' : {
            generalText         : 'General',
            resourcesText       : 'Resources',
            dependencyText      : 'Predecessors',
            addDependencyText   : 'Add new',
            dropDependencyText  : 'Remove',
            notesText           : 'Notes',
            advancedText        : 'Advanced',
            wbsCodeText         : 'WBS code',
            addAssignmentText   : 'Add new',
            dropAssignmentText  : 'Remove'
        },

        'Gnt.plugin.TaskEditor' : {
            title           : 'Task Information',
            alertCaption    : 'Information',
            alertText       : 'Please correct marked errors to save changes',
            okText          : 'Ok',
            cancelText      : 'Cancel'
        },

        'Gnt.field.EndDate' : {
            endBeforeStartText : 'End date is before start date'
        },

        'Gnt.column.Note'   : {
            text            : 'Note'
        },

        'Gnt.column.AddNew' : {
            text            : 'Add new column...'
        },

        'Gnt.column.EarlyStartDate' : {
            text            : 'Early Start'
        },

        'Gnt.column.EarlyEndDate' : {
            text            : 'Early Finish'
        },

        'Gnt.column.LateStartDate' : {
            text            : 'Late Start'
        },

        'Gnt.column.LateEndDate' : {
            text            : 'Late Finish'
        },

        'Gnt.field.Calendar' : {
            calendarNotApplicable : 'Task calendar has no overlapping with assigned resources calendars'
        },

        'Gnt.column.Slack' : {
            text            : 'Slack'
        },

        'Gnt.column.Name'   : {
            text            : 'Task Name'
        },

        'Gnt.column.BaselineStartDate'   : {
            text            : 'Baseline Start Date'
        },

        'Gnt.column.BaselineEndDate'   : {
            text            : 'Baseline End Date'
        },

        'Gnt.column.Milestone'   : {
            text            : 'Milestone'
        },

        'Gnt.field.Milestone'   : {
            yes             : 'Yes',
            no              : 'No'
        }
    }
});

/**
@class Gnt.mixin.Localizable

A mixin providing localization functionality to the consuming class.
*/
Ext.define('Gnt.mixin.Localizable', {
    extend      : 'Sch.mixin.Localizable',
    
    // This line used to be like this:
    //      if Sch.config.locale is specified then we'll require corresponding class
    //      by default we require Gnt.locale.En class
    //      requires    : [ typeof Sch != 'undefined' && Sch.config && Sch.config.locale || 'Gnt.locale.En' ]
    //
    // But, SenchaCMD does not support dynamic expressions for `requires`
    // Falling back to requiring English locale - that will cause English locale to always be included in the build
    // (even if user has specified another locale in other `requires`), but thats better than requiring users
    // to always specify and load the locale they need explicitly
    requires    : [ 'Gnt.locale.En' ]
});

/**

@class Gnt.model.CalendarDay
@extends Sch.model.Customizable

A model representing a single day in the calendar. Depending from the `Type` field, day may be a concrete day per se (2012/01/01),  
a certain weekday (all Thursdays), or an override for all certain weekdays in the timeframe 
(all Fridays between 2012/01/01 - 2012/01/15, inclusive).

A collection of this models is supposed to be provided for the {@link Gnt.data.Calendar calendar}   

Fields
------
   
- `Id`   - The id of the date. Can be an arbitrary unique value, assigned by the server. For backward compatibility, if this field has one of the special formats
then some data will be extracted from it. This behavior will be kept for the several next releases, but you should not rely on it anymore. 
- `Type` - The type of this calendar day. Can be one of the following `DAY`, `WEEKDAY`, `WEEKDAYOVERRIDE`:   
    - Default value is `DAY` meaning this day represents a "real" day in the calendar (2012/01/01 for example) and contains availability information for that particular day only. 
    The date is stored in the `Date` field.
    - The `WEEKDAY` value means calendar day contains information about all weekdays with the index, given in the `Weekday` field (0 - Sunday, 1 - Monday and so on).   
    For example - all Fridays. `Date` field is ignored.
    - <p>The `WEEKDAYOVERRIDE` value means calendar day contains information about all weekdays within certain timespan. For example - all Fridays between 2012/01/01 - 2012/01/15. 
    Week day index should be stored in the `Weekday` field again, beginning of the timespan - in the `OverrideStartDate` field and the end of timespan - in the `OverrideEndDate`.
    </p>
    <p>
    A single day instance contains the override for a single week day. So, to define overrides for several days (Monday and Tuesday for example) - add an additional instance 
    to the calendar with the same `Name/OverrideStartDate/OverrideEndDate` values. There's no need to define an override for every week day - if some day is not defined - the 
    default availability will be used.
    </p> 
    <p> 
    * **Note** Every week override should also have a "main" calendar day instance, representing the override itself. It should have the same 
    values for `Name/OverrideStartDate/OverrideEndDate` fields and -1 for `Weekday`. Also, the timespans of all week overrides should not intersect.
    </p> 
    <p> 
    To avoid manual creation of the week overrides you can use the calendar api (for example, {@link Gnt.data.Calendar#addNonStandardWeek addNonStandardWeek},
    {@link Gnt.data.Calendar#removeNonStandardWeek removeNonStandardWeek} methods), or use a special widget: {@link Gnt.widget.calendar.Calendar}
    </p>  
     
- `Date` - the date for this day in the ISO 8601 format. Any time information in this field will be cleared. If this instance 
  represents a weekday or week override, this field will be ignored. 
- `Weekday` - the index of the week day (0 - Sunday, 1 - Monday and so on) if this instance contains information about the week day (applicable for `WEEKDAY` and `WEEKDAYOVERRIDE`).
Should be set to -1 for the "main" instance of the week overrides.
- `OverrideStartDate` - The start date of the timespan for week day override.
- `OverrideEndDate` - The end date of the timespan for week day override.
- `Name` - optional name of the day (holiday name for example)
- `Cls` - optional name of the CSS class, which can be used by various plugins working with weekends and holidays. Default value is `gnt-holiday`
If some holidays lasts for several days, then all days should have the same `Cls` value.
- `IsWorkingDay` - optional boolean flag, allowing you to specify the exceptions - working days which falls on the weekends. Default value is `false`. **Please note**, that just setting this
field to "true" is not enough - you also need to specify what exactly hours are available for work with the `Availability` field (see below).
- `Availability` - should be an array of strings, containing the hourly availability for this day. Strings should have the following format:

        // two working intervals 
        [ '08:00-12:00', '13:00-17:00' ]
    
        // whole 24 hours are available 
        [ '00:00-24:00' ]
* **Please note**, that this field overrides the `IsWorkingDay` - for example, a day with "IsWorkingDay : false" and "Availability : [ '08:00-12:00' ]" - will be considered as
working day.

The name of any field can be customized in the subclass. Please refer to {@link Sch.model.Customizable} for details.

*/


Ext.define('Gnt.model.CalendarDay', {
    
    requires    : [ 'Ext.data.Types' ], 
    
    extend      : 'Sch.model.Customizable',
    
    idProperty  : 'Id',
    
    customizableFields      : [
        /**
         * @method getDate
         * 
         * Returns the value of the `Date` field 
         * 
         * @return {Date} The date of this calendar day
         */
        { 
            name        : 'Date',
            type        : 'date',
            dateFormat  : 'c', 
            
            convert     : function (value, record) {
                if (!value) return;

                var converted   = Ext.data.Types.DATE.convert.call(this, value);
                
                if (converted) {
                    Ext.Date.clearTime(converted);
                }
                
                return converted;
            } 
        },
        /**
         * @method getWeekday
         * 
         * Returns the value of the `Weekday` field 
         * 
         * @return {Number} The index of the week day (0 - Sunday, 1 - Monday, etc).
         */
        /**
         * @method setWeekday
         * 
         * Sets value of the `Weekday` field 
         * 
         * @param {Number} weekday The index of the week day (0 - Sunday, 1 - Monday, etc).
         */
        {
            name            : 'Weekday',
            type            : 'int'
        },
        /**
         * @method getOverrideStartDate
         * 
         * Returns the start date of the timespan for the week day override.
         * 
         * @return {Date} The start date
         */
        /**
         * @method setOverrideStartDate
         * 
         * Sets the start date of the timespan for the week day override 
         * 
         * @param {Date} startDate The new start date
         */
        {
            name            : 'OverrideStartDate',
            type            : 'date',
            dateFormat      : 'c'
        },
        /**
         * @method getOverrideEndDate
         * 
         * Returns the end date of the timespan for the week day override.
         * 
         * @return {Date} The end date
         */
        /**
         * @method setOverrideEndDate
         * 
         * Sets the end date of the timespan for the week day override 
         * 
         * @param {Date} endDate The new end date
         */
        {
            name            : 'OverrideEndDate',
            type            : 'date',
            dateFormat      : 'c'
        },
        {
            name            : 'Type',
            defaultValue    : 'DAY' // 'DAY', 'WEEKDAY', 'WEEKDAYOVERRIDE'
        },
        {
            name            : 'Id'
        },
        { name: 'IsWorkingDay', type: 'boolean', defaultValue : false },
        
        /**
         * @method getCls
         * 
         * Gets the "class" of the day
         * 
         * @return {String} cls The "class" of the day 
         */        
        /**
         * @method setCls
         * 
         * Sets the "class" of the day
         * 
         * @param {String} cls The new class of the day 
         */        
        {   
            name            : 'Cls',
            defaultValue    : 'gnt-holiday'
        },
        
        /**
         * @method getName
         * 
         * Gets the "name" of the day
         * 
         * @return {String} name The "name" of the day 
         */        
        /**
         * @method setName
         * 
         * Sets the "name" of the day
         * 
         * @param {String} name The new name of the day 
         */        
        'Name',
        
        // [ '08:00-12:00', '13:00-17:00' ]
        {
            name        : 'Availability',
            convert     : function (value, record) {
                if (value) {
                    return Ext.typeOf(value) === 'string' ? [ value ] : value;
                } else {
                    return [];
                }
            } 
        }
    ],
    
    availabilityCache           : null,
    
    /**
     * @cfg {String} weekDayField The name of the `Weekday` field.
     */ 
    weekDayField                : 'Weekday',
    
    /**
     * @cfg {String} overrideStartDateField The name of the `OverrideStartDate` field.
     */ 
    overrideStartDateField      : 'OverrideStartDate',
    
    /**
     * @cfg {String} overrideEndDateField The name of the `OverrideEndDate` field.
     */ 
    overrideEndDateField        : 'OverrideEndDate',
    
    /**
     * @cfg {String} typeField The name of the `Type` field.
     */ 
    typeField                   : 'Type',
    
    /**
     * @cfg {String} dateField The name of the `Date` field.
     */ 
    dateField                   : 'Date',
    
    /**
     * @cfg {String} isWorkingDayField The name of the `IsWorkingDay` field.
     */ 
    isWorkingDayField           : 'IsWorkingDay',
    
    /**
     * @cfg {String} clsField The name of the `Cls` field.
     */ 
    clsField                    : 'Cls',
    
    
    /**
     * @cfg {String} nameField The name of the `Name` field.
     */ 
    nameField                   : 'Name',

    /**
     * @cfg {String} availabilityField The name of the `Availability` field.
     */ 
    availabilityField           : 'Availability',
    
    
    /**
     * Set the date for this day (will clear the time part)
     * @param {Date} date
     */
    setDate : function (date) {
        if (date) date      = Ext.Date.clearTime(date, true);
        
        this.set(this.dateField, date);
    },
    
    /**
     * Clears the date for this day
     * @param {Date} date
     */
    clearDate : function () {
        this.set(this.dateField, null);
    },
    
    /**
     * @method getDate
     * 
     * Returns the date for this day (will clear the time part)
     * @return {Date}
     */
    

    /**
     * This method returns the availability of this day. By default it will decode the array of strings '08:00-12:00' to the
     * array of objects like:
     * 
            {
                startTime       : new Date(0, 0, 0, 8),
                endTime         : new Date(0, 0, 0, 12)
            }

     * You can pass the "asString" flag to disable that and just return strings.
     * 
     * @param {Boolean} asString Whether to just return an array of strings, instead of objects.
     * @return {[ Object/String ]} Array of objects with "startTime", "endTime" properties. 
     */
    getAvailability : function (asString) {
        var me      = this;
        
        if (asString) {
            // Return the raw availability array with strings
            return this.get(this.availabilityField);
        }

        if (this.availabilityCache) {
            return this.availabilityCache;
        }
        
        var parsed  = [];
        
        Ext.Array.each(this.get(this.availabilityField), function (value) {
            parsed.push(Ext.typeOf(value) === 'string' ? me.parseInterval(value) : value);
        });
    
        this.verifyAvailability(parsed);
            
        return this.availabilityCache = parsed;
    },
    
    
    /**
     * This method updates the availability information for this day. It accept an array of strings: '08:00-12:00', or
     * objects like:
            
            {
                startTime       : new Date(0, 0, 0, 8),
                endTime         : new Date(0, 0, 0, 12)
            }
            
     * @param {Array[Object/String]} intervals Array of availability intervals
     */
    setAvailability : function (intervals) {
        // clear cache
        this.availabilityCache = null;
        
        this.set(this.availabilityField, this.stringifyIntervals(intervals));
        
        // to trigger the `verifyAvailability`
        this.getAvailability();
    },
    
    
    verifyAvailability : function (intervals) {
        intervals.sort(function (a, b) {
            return a.startTime - b.startTime;
        });
        
        Ext.Array.each(intervals, function (interval) {
            if (interval.startTime > interval.endTime) {
                throw new Error("Start time " + Ext.Date.format(interval.startTime, 'H:i') + " is greater than end time " + Ext.Date.format(interval.endTime, 'H:i'));
            }
        });
        
        for (var i = 1; i < intervals.length; i++) {
            var prev        = intervals[ i - 1 ];
            var curr        = intervals[ i ];
            
            if (prev.endTime > curr.startTime) {
                throw new Error("Availability intervals should not intersect: [" + this.stringifyInterval(prev) + "] and [" + this.stringifyInterval(curr) + "]");
            }
        }
    },
    
    
    prependZero : function (value) {
        return value < 10 ? '0' + value : value;
    },
    
    
    stringifyInterval : function (interval) {
        var startTime   = interval.startTime;
        var endTime     = interval.endTime;
        
        return this.prependZero(startTime.getHours()) + ':' + this.prependZero(startTime.getMinutes()) + '-' +
            this.prependZero(endTime.getHours()) + ':' + this.prependZero(endTime.getMinutes());
    },
    
    
    stringifyIntervals : function (intervals) {
        var me                  = this;
        var result              = [];
        
        Ext.Array.each(intervals, function (interval) {
            if (Ext.typeOf(interval) === 'string') {
                result.push(interval);
            } else {
                result.push(me.stringifyInterval(interval));
            }
        });
        
        return result;
    },
    
    
    parseInterval : function (string) {
        var match   = /(\d\d):(\d\d)-(\d\d):(\d\d)/.exec(string);
        
        if (!match) throw "Invalid format for availability string: " + string + ". It should have exact format: hh:mm-hh:mm";
        
        return {
            startTime       : new Date(0, 0, 0, match[ 1 ], match[ 2 ]),
            endTime         : new Date(0, 0, 0, match[ 3 ], match[ 4 ])
        };
    },
    
    
    /**
     * Return the total length of all availability intervals for this day in hours.
     * 
     * @return {Number} 
     */
    getTotalHours : function () {
        return this.getTotalMS() / 1000 / 60 / 60;
    },
    
    
    /**
     * Return the total length of all availability intervals for this day in milliseconds.
     * 
     * @return {Number} 
     */
    getTotalMS : function () {
        var totalMS      = 0;
        
        Ext.Array.each(this.getAvailability(), function (interval) {
            totalMS      += interval.endTime - interval.startTime;
        });
        
        return totalMS;
    },
    
    
    /**
     * Adds a new availability interval to this day. Both arguments should have the same format.
     * 
     * @param {Date/String} startTime Start time of the interval. Can be a Date object (new Date(0, 0, 0, 8)) or just a plain string: '08'
     * @param {Date/String} endTime End time of the interval. Can be a Date object (new Date(0, 0, 0, 12)) or just a plain string: '12'
     */
    addAvailabilityInterval : function (startTime, endTime) {
        var interval;
        
        if (startTime instanceof Date) {
            interval        = {
                startTime       : startTime,
                endTime         : endTime
            };
        } else {
            interval        = this.parseInterval(startTime + (endTime ? '-' + endTime : ''));
        }
            
        var intervals       = this.getAvailability().concat(interval);
        
        this.verifyAvailability(intervals);
        
        this.setAvailability(intervals);
    },
    
    
    /**
     * Removes the availability interval by its index.
     * 
     * @param {Number} index Ordinal position of the interval to be removed
     */
    removeAvailbilityInterval : function (index) {
        var intervals       = this.getAvailability();
        
        intervals.splice(index, 1);
        
        this.setAvailability(intervals);
    },
    
    
    /**
     * Applies the availability intervals to a concrete day. For example the availability intervals [ '08:00-12:00', '13:00-17:00' ],
     * applied to a day 2012/01/01 will return the following result:
     * 
    [
        {
            startDate       : new Date(2012, 0, 1, 8),
            endDate         : new Date(2012, 0, 1, 12)
        },
        {
            startDate       : new Date(2012, 0, 1, 13),
            endDate         : new Date(2012, 0, 1, 17)
        }
    ]

     * 
     * @param {Date} date The date to apply the intervals to
     * 
     * @returns {Array[ Object ]} Array of objects with "startDate / endDate" properties.
     */
    getAvailabilityIntervalsFor : function (timeDate) {
        timeDate                = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;
        
        var year                = timeDate.getFullYear();
        var month               = timeDate.getMonth();
        var date                = timeDate.getDate();
        
        var result              = [];
        
        Ext.Array.each(this.getAvailability(), function (interval) {
            
            var endDate     = interval.endTime.getDate();
            
            result.push({
                startDate       : new Date(year, month, date, interval.startTime.getHours(), interval.startTime.getMinutes()),
                endDate         : new Date(year, month, date + (endDate == 1 ? 1 : 0), interval.endTime.getHours(), interval.endTime.getMinutes())
            });
        });
        
        return result;
    },
    
    
    /**
     * Returns the earliest available time for the given date. If this day has no availability intervals for this day, returns `null`.
     * 
     * @param {Date} date A date to get the earliest availability time for.
     * 
     * @return {Date}
     */
    getAvailabilityStartFor : function (timeDate) {
        var intervals           = this.getAvailabilityIntervalsFor(timeDate);
        
        if (!intervals.length) {
            return null;
        }
        
        return intervals[ 0 ].startDate;
    },
    
    
    /**
     * Returns the latest available time for the given date. If this day has no availability intervals for this day, returns `null`.
     * 
     * @param {Date} date A date to get the latest availability time for.
     * 
     * @return {Date}
     */
    getAvailabilityEndFor : function (timeDate) {
        var intervals           = this.getAvailabilityIntervalsFor(timeDate);
        
        if (!intervals.length) {
            return null;
        }
        
        return intervals[ intervals.length - 1 ].endDate;
    }

});

/**

@class Gnt.model.Assignment
@extends Sch.model.Customizable

This class represent a single assignment of resource to task in your gantt chart. Its a subclass of the {@link Sch.model.Customizable}, which is in turn subclass of {@link Ext.data.Model}.
Please refer to documentation of those classes to become familar with the base interface of this class.

Assignment has the following fields:

- `Id` - The id of the assignment itself
- `ResourceId` - The id of the resource assigned
- `TaskId` - The id of the task to which the resource is assigned
- `Units` - An integer value representing how much of the resource's availability that is dedicated to this task

The name these field can be customized by subclassing this class. Please refer to {@link Sch.model.Customizable} for details.

See also: {@link Gnt.column.ResourceAssignment}

*/


Ext.define('Gnt.model.Assignment', {
    extend  : 'Sch.model.Customizable',

    idProperty : 'Id',

    customizableFields  : [
        { name : 'Id' },


        { name : 'ResourceId' },
        { name : 'TaskId' },
        { name : 'Units', type : 'float', defaultValue : 100 }
    ],

    /**
    * @cfg {String} resourceIdField The name of the field identifying the resource to which an assignment belongs. Defaults to "ResourceId".
    */
    resourceIdField         : 'ResourceId',

    /**
    * @cfg {String} taskIdField The name of the field identifying the task to which an event belongs. Defaults to "TaskId".
    */
    taskIdField             : 'TaskId',

    /**
    * @cfg {String} unitsField The name of the field identifying the units of this assignment. Defaults to "Units".
    */
    unitsField              : 'Units',

    /**
     * Returns true if the Assignment can be persisted (e.g. task and resource are not 'phantoms')
     *
     * @return {Boolean} true if this model can be persisted to server.
     */
    isPersistable : function() {
        var task        = this.getTask(),
            resource    = this.getResource();

        return task && !task.phantom && resource && !resource.phantom;
    },


    /**
     * Returns the units of this assignment
     *
     * @return {Number} units
     */
    getUnits : function () {
        // constrain to be >= 0
        return Math.max(0, this.get(this.unitsField));
    },


    /**
     * Sets the units of this assignment
     *
     * @param {Number} value The new value for units
     */
    setUnits : function (value) {
        if (value < 0) throw "`Units` value for an assignment can't be less than 0";

        this.set(this.unitsField, value);
    },


    /**
     * Convenience method for returning the name of the associated resource.
     *
     * @return {String} name
     */
    getResourceName : function() {
        var resource = this.getResource();

        if (resource) {
            return resource.getName();
        }

        return '';
    },


    /**
     * Returns the task associated with this assignment.
     *
     * @return {Gnt.model.Task} Instance of task
     * @method getTask
     */
    /** @ignore */
    getTask: function (taskStore) {
        // removed assignment will not have "this.stores" so we are providing a way to get the task via provided taskStore
        return (taskStore || this.stores[ 0 ].getTaskStore()).getByInternalId(this.getTaskId());
    },


    /**
     * Returns the resource associated with this assignment.
     *
     * @return {Gnt.model.Resource} Instance of resource
     */
    getResource: function(){
        return this.stores[ 0 ].getResourceStore().getByInternalId(this.getResourceId());
    },

    // We'll be using `internalId` for Id substitution when dealing with phantom records
    getInternalId: function(){
        return this.getId() || this.internalId;
    },


    /**
     * Returns the effort, contributed by the resource of this assignment to a task of this assignment.
     *
     * @param {String} unit Unit to return the effort in. Defaults to the `EffortUnit` field of the task
     *
     * @return {Number} effort
     */
    getEffort : function (unit) {
        var task            = this.getTask();

        var totalEffort     = 0;

        task.forEachAvailabilityIntervalWithResources(
            {
                startDate   : task.getStartDate(),
                endDate     : task.getEndDate(),
                resources   : [ this.getResource() ]
            },
            function (intervalStartDate, intervalEndDate, currentAssignments) {
                var totalUnits;

                for (var i in currentAssignments) totalUnits = currentAssignments[ i ].units;

                totalEffort             += (intervalEndDate - intervalStartDate) * totalUnits / 100;
            }
        );

        return task.getProjectCalendar().convertMSDurationToUnit(totalEffort, unit || task.getEffortUnit());
    }
});

/**

@class Gnt.model.Dependency
@extends Sch.model.Customizable

This class represents a single Dependency in your gantt chart. Its a subclass of the {@link Sch.model.Customizable}, which is in turn subclass of {@link Ext.data.Model}.
Please refer to documentation of those classes to become familar with the base interface of this class.

A Dependency has the following fields:

- `Id` - The id of the dependency itself
- `From` - The id of the task at which the dependency starts  
- `To` - The id of the task at which the dependency ends
- `Lag` - A numeric part of the lag value between the tasks. Negative values are supported. Please note, that any lag-related calculations will be performed
  using project calendar. Also only working time is counted as "lag" time.
- `LagUnit` - A duration unit part of the lag value between the tasks. Default value is "d" (days). Valid values are:
    - "ms" (milliseconds)
    - "s" (seconds)
    - "mi" (minutes)
    - "h" (hours)
    - "d" (days)
    - "w" (weeks)
    - "mo" (months)
    - "q" (quarters)
    - "y" (years)

- `Cls` - A CSS class that will be applied to each rendered dependency DOM element
- `Type` - An integer constant representing the type of the dependency:
    - 0 - start-to-start dependency
    - 1 - start-to-end dependency
    - 2 - end-to-start dependency
    - 3 - end-to-end dependency

Subclassing the Dependency class
--------------------

The name of any field can be customized in the subclass, see the example below. Please also refer to {@link Sch.model.Customizable} for details.

    Ext.define('MyProject.model.Dependency', {
        extend      : 'Gnt.model.Dependency',
        
        toField     : 'targetId', 
        fromField   : 'sourceId', 

        ...
    })

*/

Ext.define('Gnt.model.Dependency', {
    extend              : 'Sch.model.Customizable',
    
    inheritableStatics  : {
        Type    : {
            StartToStart    : 0,
            StartToEnd      : 1,
            EndToStart      : 2,
            EndToEnd        : 3
        }
    },
    
    idProperty          : 'Id',
    
    customizableFields     : [
        { name : 'Id' },

        // 3 mandatory fields
        { name: 'From' },
        { name: 'To' },
        { name: 'Type', type : 'int', defaultValue : 2},

        { name: 'Lag', type : 'number', defaultValue : 0},
        {
            name            : 'LagUnit',
            type            : 'string',
            defaultValue    : "d",
            // make sure the default value is applied when user provides empty value for the field, like "" or null
            convert         : function (value) {
                return value || "d";
            }
        },
        { name: 'Cls'}
    ],

    /**
    * @cfg {String} fromField The name of the field that contains the id of the source task.
    */ 
    fromField       : 'From',
    
    /**
    * @cfg {String} toField The name of the field that contains the id of the target task.
    */
    toField         : 'To',
    
    /**
    * @cfg {String} typeField The name of the field that contains the dependency type.
    */
    typeField       : 'Type',

    /**
    * @cfg {String} lagField The name of the field that contains the lag amount.
    */
    lagField        : 'Lag',

    /**
    * @cfg {String} lagUnitField The name of the field that contains the lag unit duration.
    */
    lagUnitField    : 'LagUnit',
    
    /**
    * @cfg {String} clsField The name of the field that contains a CSS class that will be added to the rendered dependency elements.
    */
    clsField        : 'Cls',
    
    fromTask        : null,
    toTask          : null,
    
    isHighlighted   : false,
    
    
    constructor : function(config) {
        this.callParent(arguments);
        
        if (config) {
            if (config.fromTask) {
                if (config.fromTask instanceof Gnt.model.Task) {
                    this.setSourceTask(config.fromTask);
                } else {
                    this.setSourceId(config.fromTask);
                }
            }

            if (config.toTask) {
                if (config.toTask instanceof Gnt.model.Task) {
                    this.setTargetTask(config.toTask);
                } else {
                    this.setTargetId(config.toTask);
                }
            }

            if (Ext.isDefined(config.type)) {
                this.setType(config.type);
            }

            if (Ext.isDefined(config.lag)) {
                this.setLag(config.lag);
            }

            if (Ext.isDefined(config.lagUnit)) {
                this.setLagUnit(config.lagUnit);
            }
        }
    },
    

    getTaskStore : function() {
        return this.stores[0].taskStore;
    },

    /**
    * Returns the source task of the dependency
    * @return {Gnt.model.Task} The source task of this dependency
    */
    getSourceTask : function(taskStore) {
        return (taskStore || this.getTaskStore()).getById(this.getSourceId());
    },

    /**
    * Sets the source task of the dependency
    * @param {Gnt.model.Task} task The new source task of this dependency
    */
    setSourceTask : function(task) {
        this.setSourceId(task.getId() || task.internalId);
    },

    /**
    * Returns the target task of the dependency
    * @return {Gnt.model.Task} The target task of this dependency
    */
    getTargetTask : function(taskStore) {
        return (taskStore || this.getTaskStore()).getById(this.getTargetId());
    },

    /**
    * Sets the target task of the dependency
    * @param {Gnt.model.Task} task The new target task of this dependency
    */
    setTargetTask : function(task) {
        this.setTargetId(task.getId() || task.internalId);
    },

    /**
    * Returns the source task id of the dependency
    * @return {Mixed} The id of the source task for the dependency
    */
    getSourceId : function() {
        return this.get(this.fromField);
    },

    /**
    * Sets the source task id of the dependency
    * @param {Mixed} The id of the source task for the dependency
    */
    setSourceId : function(id) {
        this.set(this.fromField, id);
    },

    /**
    * Returns the target task id of the dependency
    * @return {Mixed} The id of the target task for the dependency
    */
    getTargetId : function() {
        return this.get(this.toField);
    },

    /**
    * Sets the target task id of the dependency
    * @param {Mixed} id The id of the target task for the dependency
    */
    setTargetId : function(id) {
        this.set(this.toField, id);
    },

    /**
    * @method getType
    * 
    * Returns the dependency type
    * @return {Mixed} The type of the dependency
    */

    /**
    * @method setType
    * 
    * Sets the dependency type
    * @param {Mixed} id The type of the dependency
    */

    /**
    * @method getLag
    * 
    * Returns the amount of lag for the dependency
    * @return {Int} id The amount of lag for the dependency
    */

    /**
    * @method setLag
    * 
    * Sets the amount of lag for the dependency
    * @param {Int} id The amount of lag for the dependency
    */
    
    /**
    * Returns the duration unit of the lag.  
    * @return {String} the duration unit
    */
    getLagUnit: function () {
        return this.get(this.lagUnitField) || 'd';
    },
    
    /**
    * @method setLagUnit
    * 
    * Updates the lag unit of the dependency.  
    * 
    * @param {String} unit Lag duration unit
    */

    /**
     * @method getCls
     * 
     * Returns the name of field holding the CSS class for each rendered dependency element
     * 
     * @return {String} The cls field
     */

    /**
     * Returns true if the linked tasks have been persisted (e.g. neither of them are 'phantoms')
     * 
     * @return {Boolean} true if this model can be persisted to server.
     */
    isPersistable : function() {
        var source = this.getSourceTask(),
            target = this.getTargetTask();

        return source && !source.phantom && target && !target.phantom;
    },

    
    /**
     * Returns `true` if the dependency is valid. Note, this method assumes that the model is part of a {@link Gnt.data.DependencyStore}.
     * Invalid dependencies are: 
     * - a task linking to itself
     * - a dependency between a child and one of its parent 
     * - transitive dependencies, e.g. if A -> B, B -> C, then A -> C is not valid 
     * 
     * @return {Boolean}
     */
    isValid : function (askStore) {
        var valid       = this.callParent(arguments),
            sourceId    = this.getSourceId(),
            targetId    = this.getTargetId(),
            type        = this.getType();
        
        if (valid) {
            valid       = Ext.isNumber(type) && !Ext.isEmpty(sourceId) && !Ext.isEmpty(targetId) && sourceId != targetId;
        }

        if (valid && askStore !== false && this.stores[ 0 ]) {
            valid       = this.stores[ 0 ].isValidDependency(sourceId, targetId, type, this);
        }

        return valid;
    },

    
    // We'll be using `internalId` for Id substitution when dealing with phantom records
    getInternalId : function(){
        return this.getId() || this.internalId;
    }
});
/**

@class Gnt.model.Resource
@extends Sch.model.Resource

This class represents a single Resource in your gantt chart.
The inheritance hierarchy of this class includes {@link Sch.model.Customizable} and {@link Ext.data.Model} classes.
Please refer to the documentation of those classes to become familar with the base interface of this class.

A Resource has only 2 mandatory fields - `Id` and `Name`. If you want to add some fields, describing resources - subclass this class:

    Ext.define('MyProject.model.Resource', {
        extend      : 'Gnt.model.Resource',

        fields      : [
            // `Id` and `Name` fields are already provided by the superclass
            { name: 'Company',          type : 'string' }
        ],

        getCompany : function () {
            return this.get('Company')
        },
        ...
    })

The name of any field can be customized in the subclass. Please refer to {@link Sch.model.Customizable} for details.

See also: {@link Gnt.model.Assignment}, {@link Gnt.column.ResourceAssignment}

*/

Ext.define('Gnt.model.Resource', {
    extend      : 'Sch.model.Resource',

    customizableFields : [
        'CalendarId'
    ],

    /**
     * @cfg {String} calendarIdField The name of the field defining the id of the calendar for this specific resource.
     */
    calendarIdField         : 'CalendarId',


    normalized                  : false,
    calendarWaitingListener     : null,


    getTaskStore : function () {
        return this.stores[ 0 ].getTaskStore();
    },


    getEventStore : function () {
        return this.getTaskStore();
    },

    /**
     * Returns an array of tasks associated with this resource
     * @return {Array[Sch.model.Event]}
     */
    getEvents : function() {
        return this.getTasks();
    },

    /**
     * Returns an array of tasks associated with this resource
     * @return {Array[Gnt.model.Task]}
     */
    getTasks : function() {
        var tasks = [];
        this.forEachAssignment(function(ass) {
            var t = ass.getTask();
            if (t) {
                tasks.push(t);
            }
        });
        return tasks;
    },


    /**
     * Returns the calendar, based on which is performed the schedule calculations for associated tasks.
     * It will be either the own calendar of this resource (if any) or the calendar of the whole project.
     *
     * @param {Boolean} ownCalendarOnly Pass `true` to return only own calendar.
     *
     * @return {Gnt.data.Calendar} The instance of calendar
     */
    getCalendar: function (ownCalendarOnly) {
        return ownCalendarOnly ? this.getOwnCalendar() : this.getOwnCalendar() || this.getProjectCalendar();
    },


    /**
     * Returns the {@link Gnt.data.Calendar calendar} instance, associated with this resource (if any). See also {@link #calendarIdField}.
     *
     * @return {Gnt.data.Calendar} calendar
     */
    getOwnCalendar : function () {
        var calendarId      = this.getCalendarId();

        return calendarId ? Gnt.data.Calendar.getCalendar(calendarId) : null;
    },


    /**
     * Returns the {@link Gnt.data.Calendar calendar} instance, associated with the project of this resource (with the TaskStore instance
     * this resource belongs to).
     *
     * @return {Gnt.data.Calendar} calendar
     */
    getProjectCalendar : function () {
        return this.stores[ 0 ].getTaskStore().getCalendar();
    },


    /**
     * Sets the {@link Gnt.data.Calendar calendar}, associated with this resource. Calendar must have a {@link Gnt.data.Calendar#calendarId calendarId} property
     * defined, which will be saved in the `CalendarId` field of this task.
     *
     * @param {Gnt.data.Calendar/String} calendar A calendar instance or string with calendar id
     */
    setCalendar: function (calendar) {
        var isCalendarInstance  = calendar instanceof Gnt.data.Calendar;

        if (isCalendarInstance && !calendar.calendarId) throw new Error("Can't set calendar w/o `calendarId` property");

        this.setCalendarId(isCalendarInstance ? calendar.calendarId : calendar);
    },


    setCalendarId : function (calendarId, isInitial) {
        if (calendarId instanceof Gnt.data.Calendar) calendarId = calendarId.calendarId;

        var prevCalendarId  = this.getCalendarId();

        if (prevCalendarId != calendarId || isInitial) {
            if (this.calendarWaitingListener) {
                this.calendarWaitingListener.destroy();
                this.calendarWaitingListener = null;
            }

            var listeners       = {
                calendarchange  : this.adjustToCalendar,
                scope           : this
            };

            var prevInstance        = this.calendar || Gnt.data.Calendar.getCalendar(prevCalendarId);

            // null-ifying the "explicit" property - it should not be used at all generally, only "calendarId"
            this.calendar   = null;

            prevInstance && prevInstance.un(listeners);

            this.set(this.calendarIdField, calendarId);

            var calendarInstance    = Gnt.data.Calendar.getCalendar(calendarId);

            if (calendarInstance) {
                calendarInstance.on(listeners);

                if (!isInitial) this.adjustToCalendar();
            } else {
                this.calendarWaitingListener = Ext.data.StoreManager.on('add', function (index, item, key) {
                    calendarInstance    = Gnt.data.Calendar.getCalendar(calendarId);

                    if (calendarInstance) {
                        this.calendarWaitingListener.destroy();
                        this.calendarWaitingListener = null;

                        calendarInstance.on(listeners);

                        this.adjustToCalendar();
                    }
                }, this, { destroyable : true });
            }
        }
    },


    adjustToCalendar : function () {
        this.forEachTask(function (task) {
            task.adjustToCalendar();
        });
    },


    // We'll be using `internalId` for Id substitution when dealing with phantom records
    getInternalId : function () {
        return this.getId() || this.internalId;
    },


    /**
     * Assigns this resource to a given task. A new {@link Gnt.model.Assignment assignment} will be created
     * and added to the {@link Gnt.data.AssignmentStore} of the project.
     *
     * @param {Gnt.model.Task/Number} taskOrId Either instance of {@link Gnt.model.Task} or id of the task
     * @param {Number} units The value for the "Units" field
     */
    assignTo : function (taskOrId, units) {
        var task    = taskOrId instanceof Gnt.model.Task ? taskOrId : this.getTaskStore().getById(taskOrId);

        return task.assign(this, units);
    },


    unassignFrom : function () {
        return this.unAssignFrom.apply(this, arguments);
    },


    /**
     * Un assigns this resource from the given task. The corresponding {@link Gnt.model.Assignment assignment} record
     * will be removed from the {@link Gnt.data.AssignmentStore} of the project.
     *
     * @param {Gnt.model.Task/Number} taskOrId Either instance of {@link Gnt.model.Task} or id of the task
     */
    unAssignFrom : function (taskOrId) {
        var task    = taskOrId instanceof Gnt.model.Task ? taskOrId : this.getTaskStore().getById(taskOrId);

        task.unAssign(this);
    },


    /**
     * Iterator for each assignment, associated with this resource.
     *
     * @param {Function} func The function to call. This function will receive an {@link Gnt.model.Assignment assignment} instance
     * as the only argument
     *
     * @param {Object} scope The scope to run the function in.
     */
    forEachAssignment : function (func, scope) {
        scope       = scope || this;

        var id      = this.getInternalId();

        this.getTaskStore().getAssignmentStore().each(function (assignment) {
            if (assignment.getResourceId() == id) {
                return func.call(scope, assignment);
            }
        });
    },


    /**
     * Iterator for tasks, assigned to this resource.
     *
     * @param {Function} func The function to call. This function will receive an {@link Gnt.model.Task task} instance
     * as the only argument.
     *
     * @param {Object} scope The scope to run the function in.
     */
    forEachTask : function (func, scope) {
        scope       = scope || this;

        var id      = this.getInternalId();

        this.getTaskStore().getAssignmentStore().each(function (assignment) {
            if (assignment.getResourceId() == id) {
                var task        = assignment.getTask();

                if (task) return func.call(scope, task);
            }
        });
    },


    collectAvailabilityIntervalPoints : function (intervals, getStartPoint, getEndPoint, pointsByTime, pointTimes) {

        var keepStart = Ext.isFunction(getStartPoint) ?
            function (dt) { pointsByTime[ dt ].push(getStartPoint(dt)); } :
            function (dt) { pointsByTime[ dt ].push(getStartPoint); };

        var keepEnd = Ext.isFunction(getEndPoint) ?
            function (dt) { pointsByTime[ dt ].push(getEndPoint(dt)); } :
            function (dt) { pointsByTime[ dt ].push(getEndPoint); };

        for (var k = 0, l = intervals.length; k < l; k++) {
            var interval            = intervals[ k ];

            var intervalStartDate   = interval.startDate - 0;
            var intervalEndDate     = interval.endDate - 0;

            if (!pointsByTime[ intervalStartDate ]) {
                pointsByTime[ intervalStartDate ] = [];

                pointTimes.push(intervalStartDate);
            }

            keepStart(intervalStartDate);

            if (!pointsByTime[ intervalEndDate ]) {
                pointsByTime[ intervalEndDate ] = [];

                pointTimes.push(intervalEndDate);
            }

            keepEnd(intervalEndDate);
        }
    },


    forEachAvailabilityIntervalWithTasks : function (options, func, scope) {
        scope                       = scope || this;

        var startDate               = options.startDate;
        var endDate                 = options.endDate;

        if (!startDate || !endDate) throw "Both `startDate` and `endDate` are required for `forEachAvailabilityIntervalWithTasks`";

        var cursorDate              = new Date(startDate);
        var includeAllIntervals     = options.includeAllIntervals;
        var includeResCalIntervals  = options.includeResCalIntervals;

        var resourceCalendar        = this.getCalendar();

        var assignments             = [];
        var tasks                   = [];
        var tasksCalendars          = [];

        var pointTimes              = [ startDate - 0, endDate - 0 ];
        var pointsByTime            = {};

        pointsByTime[ startDate - 0 ]   = [ { type  : '00-intervalStart' } ];
        pointsByTime[ endDate - 0 ]     = [ { type  : '00-intervalEnd' } ];

        this.forEachAssignment(function (assignment) {
            var task        = assignment.getTask();
            // filter out not existing tasks
            if (!task) return;

            var taskStart   = task.getStartDate();
            var taskEnd     = task.getEndDate();
            var taskId      = task.getInternalId();

            // filter out tasks out of provided [ startDate, endDate ) interval
            if (taskStart > endDate || taskEnd < startDate) return;

            tasks.push(task);
            tasksCalendars.push(task.getCalendar());

            // task start/end dates are points of interest
            this.collectAvailabilityIntervalPoints([{ startDate : taskStart, endDate : taskEnd }],
                {
                    type        : '04-taskStart',
                    assignment  : assignment,
                    taskId      : taskId,
                    units       : assignment.getUnits()
                },
                {
                    type        : '05-taskEnd',
                    taskId      : taskId
                },
                pointsByTime,
                pointTimes
            );

            assignments.push(assignment);
        });

        // if there are no tasks - then there are no common intervals naturally
        if (!tasks.length && !includeAllIntervals && !includeResCalIntervals) return;

        var DATE = Sch.util.Date;

        var i, l, taskId;

        while (cursorDate < endDate) {

            this.collectAvailabilityIntervalPoints(
                resourceCalendar.getAvailabilityIntervalsFor(cursorDate),
                {
                    type    : '00-resourceAvailabilityStart'
                },
                {
                    type    : '01-resourceAvailabilityEnd'
                },
                pointsByTime,
                pointTimes
            );

            // using "for" instead of "each" should be blazing fast! :)
            for (i = 0, l = tasksCalendars.length; i < l; i++) {

                taskId = tasks[ i ].getInternalId();

                // resource specific calendar point
                this.collectAvailabilityIntervalPoints(
                    tasksCalendars[ i ].getAvailabilityIntervalsFor(cursorDate),
                    {
                        type        : '02-taskAvailabilityStart',
                        taskId      : taskId
                    },
                    {
                        type        : '03-taskAvailabilityEnd',
                        taskId      : taskId
                    },
                    pointsByTime,
                    pointTimes
                );

            }

            // does not perform cloning internally!
            cursorDate       = DATE.getStartOfNextDay(cursorDate);
        }

        pointTimes.sort();

        var inInterval          = false,
            inResource          = false,
            currentAssignments  = {},
            inTaskCalendar      = 0,
            inTask              = 0;

        for (i = 0, l = pointTimes.length - 1; i < l; i++) {
            var points      = pointsByTime[ pointTimes[ i ] ];

            points.sort(function (a, b) { return a.type < b.type ? 1 : -1; });

            for (var k = 0, j = points.length; k < j; k++) {
                var point       = points[ k ];

                switch (point.type) {
                    case '00-resourceAvailabilityStart' :
                        inResource = true;
                        break;

                    case '01-resourceAvailabilityEnd' :
                        inResource = false;
                        break;

                    case '02-taskAvailabilityStart' :
                        inTaskCalendar++;
                        break;

                    case '03-taskAvailabilityEnd' :
                        inTaskCalendar--;
                        break;

                    case '04-taskStart' :
                        currentAssignments[ point.taskId ] = point;
                        inTask++;
                        break;

                    case '05-taskEnd' :
                        delete currentAssignments[ point.taskId ];
                        inTask--;
                        break;

                    case '00-intervalStart' :
                        inInterval = true;
                        break;

                    case '00-intervalEnd' : return;
                }
            }

            if (inInterval && (includeAllIntervals || includeResCalIntervals && inResource || inResource && inTaskCalendar && inTask)) {

                var meta = {
                    inResourceCalendar  : !!inResource,
                    inTasksCalendar     : !!inTaskCalendar,
                    inTask              : inTask
                };

                var intervalStartDate       = pointTimes[ i ];
                var intervalEndDate         = pointTimes[ i + 1 ];

                // availability interval is out of [ startDate, endDate )
                if (intervalStartDate > endDate || intervalEndDate < startDate) continue;

                if (intervalStartDate < startDate) intervalStartDate = startDate - 0;
                if (intervalEndDate > endDate) intervalEndDate = endDate - 0;

                if (func.call(scope, intervalStartDate, intervalEndDate, currentAssignments, meta) === false) return false;
            }
        }
    },


    /**
     * This method will generate a report about the resource allocation in the given timeframe.
     * The start and end dates of the timeframe are provided as the "startDate/endDate" properties of the `options` parameter.
     * Options may also contain additional property: `includeAllIntervals` which includes the intervals w/o any
     * assignments in the ouput (see the example below).
     *
     * For example, this resource `R1` has the availability from 10:00 till 17:00 on 2012/06/01 and from 12:00 till 15:00 on 2012/06/02.
     * It is also assigned on 50% to two tasks:
     *
     * - `T1` has availability from 11:00 till 16:00 on 2012/06/01 and from 13:00 till 17:00 on 2012/06/02.
     *   It starts at 11:00 2012/06/01 and ends at 17:00 2012/06/02
     * - `T2` has availability from 15:00 till 19:00 on 2012/06/01 and from 09:00 till 14:00 on 2012/06/02.
     *   It starts at 15:00 2012/06/01 and ends at 14:00 2012/06/02
     *
     * So the allocation information for the period 2012/06/01 - 2012/06/03 (note the 03 in day - it means 2012/06/02 inclusive)
     * will looks like the following (to better understand this example you might want to draw all the information on the paper):
     *

    [
        {
            startDate           : new Date(2012, 5, 1, 11),
            endDate             : new Date(2012, 5, 1, 15),
            totalAllocation     : 50,
            assignments         : [ assignmentForTask1 ],
            assignmentsHash     : { 'T1' : assignmentForTask1 },
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 1
        },
        {
            startDate           : new Date(2012, 5, 1, 15),
            endDate             : new Date(2012, 5, 1, 16),
            totalAllocation     : 100,
            assignments         : [ assignmentForTask1, assignmentForTask2 ],
            assignmentsHash     : {
                'T1' : assignmentForTask1,
                'T2' : assignmentForTask2
            },
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 2
        },
        {
            startDate           : new Date(2012, 5, 1, 16),
            endDate             : new Date(2012, 5, 1, 17),
            totalAllocation     : 50,
            assignments         : [ assignmentForTask2 ],
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 2
        },
        {
            startDate           : new Date(2012, 5, 2, 12),
            endDate             : new Date(2012, 5, 2, 13),
            totalAllocation     : 50,
            assignments         : [ assignmentForTask2 ],
            assignmentsHash     : { 'T2' : assignmentForTask2 },
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 2
        },
        {
            startDate           : new Date(2012, 5, 2, 13),
            endDate             : new Date(2012, 5, 2, 14),
            totalAllocation     : 100,
            assignments         : [ assignmentForTask1, assignmentForTask2 ],
            assignmentsHash     : {
                'T1' : assignmentForTask1,
                'T2' : assignmentForTask2
            },
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 2
        },
        {
            startDate           : new Date(2012, 5, 2, 14),
            endDate             : new Date(2012, 5, 2, 15),
            totalAllocation     : 50,
            assignments         : [ assignmentForTask1 ],
            assignmentsHash     : { 'T1' : assignmentForTask1 },
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 1
        },
    ]

     *
     * As you can see its quite detailed information - every distinct timeframe is included in the report.
     * You can aggregate this information as you need.
     *
     * Setting the `includeAllIntervals` option to true, will include intervals w/o assignments in the report, so the in the
     * example above, the report will start with:
     *

    [
        {
            startDate           : new Date(2012, 5, 1, 00),
            endDate             : new Date(2012, 5, 1, 10),
            totalAllocation     : 0,
            assignments         : [],
            assignmentsHash     : {},
            inResourceCalendar  : false,
            inTasksCalendar     : false,
            inTask              : 0
        },
        {
            startDate           : new Date(2012, 5, 1, 10),
            endDate             : new Date(2012, 5, 1, 11),
            totalAllocation     : 0,
            assignments         : [],
            assignmentsHash     : {},
            inResourceCalendar  : true,
            inTasksCalendar     : false,
            inTask              : 0
        },
        {
            startDate           : new Date(2012, 5, 1, 11),
            endDate             : new Date(2012, 5, 1, 15),
            totalAllocation     : 50,
            assignments         : [ assignmentForTask1 ],
            assignmentsHash     : { 'T1' : assignmentForTask1 }
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 1
        },
        ...
    ]


     *
     * @param {Object} options Object with the following properties:
     *
     * - "startDate" - start date for the report timeframe
     * - "endDate" - end date for the report timeframe
     * - "includeAllIntervals" - whether to include the intervals w/o assignments in the report
     * - "includeResCalIntervals" - whether to include the intervals of resource calendar in the report
     */
    getAllocationInfo : function (options) {
        var info        = [];

        this.forEachAvailabilityIntervalWithTasks(options, function (intervalStartDate, intervalEndDate, currentAssignments, meta) {
            var totalAllocation     = 0,
                assignments         = [],
                assignmentsHash     = {};

            if (meta.inResourceCalendar && meta.inTasksCalendar && meta.inTask) {
                for (var i in currentAssignments) {
                    totalAllocation += currentAssignments[ i ].units;
                    assignments.push(currentAssignments[ i ].assignment);
                    assignmentsHash[i] = currentAssignments[ i ].assignment;
                }
            }

            info.push(Ext.apply({
                startDate           : new Date(intervalStartDate),
                endDate             : new Date(intervalEndDate),

                totalAllocation     : totalAllocation,
                assignments         : assignments,
                assignmentsHash     : assignmentsHash
            }, meta));
        });

        return info;
    }
});

/**

@class Gnt.model.task.More
@mixin
@protected

Internal mixin class providing additional logic and functionality belonging to the Task model class.

*/
Ext.define('Gnt.model.task.More', {

    /**
     * Increase the indendation level of this task in the tree
     */
    indent: function () {
        var prev = this.previousSibling;

        if (prev) {
            var depStore    = prev.getDependencyStore(),
                deps        = prev.getAllDependencies(depStore);
                
            // drop existing dependencies since parent task cannot have them
            // This could/should be smart and only remove the breaking deps, like from parent to its child 
            if (deps.length) {
                depStore.remove(deps);
            }
            
            prev.appendChild(this);

            prev.set('leaf', false);
            prev.expand();
        }
    },

    /**
     * Decrease the indendation level of this task in the tree
     */
    outdent: function () {
        var parent = this.parentNode;

        if (parent && !parent.isRoot()) {
            if (this.convertEmptyParentToLeaf) {
                parent.set('leaf', parent.childNodes.length === 1);
            }

            if (parent.nextSibling) {
                parent.parentNode.insertBefore(this, parent.nextSibling);
            } else {
                parent.parentNode.appendChild(this);
            }

            // recalculate previous parents
            if (this.getTaskStore().recalculateParents && parent.childNodes.length) {
                parent.childNodes[0].recalculateParents();
            }
        }
    },

    /**
     * Returns all dependencies of this task (both incoming and outgoing)
     *
     * @return {Gnt.model.Dependency[]}
     */
    getAllDependencies: function (dependencyStore) {
        return this.predecessors.concat(this.successors);
    },

    /**
     * Returns true if this task has at least one incoming dependency
     *
     * @return {Boolean}
     */
    hasIncomingDependencies: function () {
        return this.predecessors.length > 0;
    },

    /**
     * Returns true if this task has at least one outgoing dependency
     *
     * @return {Boolean}
     */
    hasOutgoingDependencies: function () {
        return this.successors.length > 0;
    },

    /**
     * Returns all incoming dependencies of this task
     *
     * @param {Boolean} [doNotClone=false] Whether to **not** create a shallow copy of the underlying {@link Gnt.model.Task#predecessors} property.
     * Passing `true` is more performant, but make sure you don't modify the array in this case. 
     *
     * @return {Gnt.model.Dependency[]}
     */
    getIncomingDependencies: function (doNotClone) {
        return doNotClone ? this.predecessors : this.predecessors.slice();
    },


    /**
     * Returns all outcoming dependencies of this task
     *
     * @param {Boolean} [doNotClone=false] Whether to **not** create a shallow copy of the underlying {@link Gnt.model.Task#successors} property.
     * Passing `true` is more performant, but make sure you don't modify the array in this case. 
     *
     * @return {Gnt.model.Dependency[]}
     */
    getOutgoingDependencies: function (doNotClone) {
        return doNotClone ? this.successors : this.successors.slice();
    },


    /**
     * @private
     * Internal method, constrains the task according to its incoming dependencies
     * @param {Gnt.data.TaskStore} taskStore The task store
     * @return {Boolean} true if the task was updated as a result.
     */
    constrain: function (taskStore) {
        if (this.isManuallyScheduled()) {
            return false;
        }

        var changed             = false;

        taskStore               = taskStore || this.getTaskStore();

        var constrainContext    = this.getConstrainContext(taskStore);

        if (constrainContext) {
            var startDate       = constrainContext.startDate;
            var endDate         = constrainContext.endDate;

            if (startDate && startDate - this.getStartDate() !== 0) {
                this.setStartDate(startDate, true, taskStore.skipWeekendsDuringDragDrop);

                changed         = true;
            } else if (endDate && endDate - this.getEndDate() !== 0) {
                this.setEndDate(endDate, true, taskStore.skipWeekendsDuringDragDrop);

                changed         = true;
            }
        }

        return changed;
    },


    getConstrainContext: function (providedTaskStore) {
        var incomingDependencies = this.getIncomingDependencies(true);

        if (!incomingDependencies.length) {
            return null;
        }
        
        var DepType             = Gnt.model.Dependency.Type,
            earliestStartDate   = new Date(0),
            earliestEndDate     = new Date(0),
            projectCalendar     = this.getProjectCalendar(),
            ownCalendar         = this.getCalendar(),
            constrainingTask;
            
        var dependenciesCalendar    = (providedTaskStore || this.getTaskStore()).dependenciesCalendar;
        

        Ext.each(incomingDependencies, function (dependency) {
            var fromTask = dependency.getSourceTask();

            if (fromTask) {
                var calendar;
                
                if (dependenciesCalendar == 'project') 
                    calendar    = projectCalendar;
                else if (dependenciesCalendar == 'source')
                    calendar    = fromTask.getCalendar();
                else if (dependenciesCalendar == 'target')
                    calendar    = ownCalendar;
                else
                    throw "Unsupported value for `dependenciesCalendar` config option";
                
                var lag         = dependency.getLag() || 0,
                    lagUnit     = dependency.getLagUnit(),
                    start       = fromTask.getStartDate(),
                    end         = fromTask.getEndDate();

                switch (dependency.getType()) {
                    case DepType.StartToEnd:
                        start   = calendar.skipWorkingTime(start, lag, lagUnit);
                        if (earliestEndDate < start) {
                            earliestEndDate     = start;
                            constrainingTask    = fromTask;
                        }
                        break;

                    case DepType.StartToStart:
                        start   = calendar.skipWorkingTime(start, lag, lagUnit);
                        if (earliestStartDate < start) {
                            earliestStartDate   = start;
                            constrainingTask    = fromTask;
                        }
                        break;

                    case DepType.EndToStart:
                        end     = calendar.skipWorkingTime(end, lag, lagUnit);
                        if (earliestStartDate < end) {
                            earliestStartDate   = end;
                            constrainingTask    = fromTask;
                        }
                        break;

                    case DepType.EndToEnd:
                        end     = calendar.skipWorkingTime(end, lag, lagUnit);
                        if (earliestEndDate < end) {
                            earliestEndDate     = end;
                            constrainingTask    = fromTask;
                        }
                        break;

                    default:
                        throw 'Invalid dependency type: ' + dependency.getType();
                }
            }
        });

        return {
            startDate           : earliestStartDate > 0 ? earliestStartDate : null,
            endDate             : earliestEndDate > 0 ? earliestEndDate : null,

            constrainingTask    : constrainingTask
        };
    },


    /**
    * @private
    * Internal method, called recursively to query for the longest duration of the chain structure
    * @return {Gnt.model.Task[]} chain An array forming a chain of linked tasks
    */
    getCriticalPaths: function () {
        var cPath = [this],
            ctx = this.getConstrainContext();

        while (ctx) {
            cPath.push(ctx.constrainingTask);

            ctx = ctx.constrainingTask.getConstrainContext();
        }

        return cPath;
    },

    /**
     * Cascades changes for a task, and all its dependent tasks. This is more like an system method, you probably 
     * want to use {@link Gnt.data.TaskStore#cascadeChangesForTask} method instead. 
     * 
     * @param {Gnt.data.TaskStore} [taskStore] The taskStore
     * @param {Object} [context] (private)
     * @param {Gnt.model.Dependency} The dependency triggering the cascade
     */
    cascadeChanges: function (taskStore, context, triggeringDependency) {
        context                     = context || { nbrAffected : 0, affected : {} };
        taskStore                   = taskStore || this.getTaskStore();
        
        var currentCascadeBatch     = taskStore.currentCascadeBatch;
        
        if (currentCascadeBatch) {
            if (currentCascadeBatch.visitedCounters[ this.internalId ] > this.predecessors.length) return;
            
            currentCascadeBatch.addVisited(this);
        }
        
        if (this.isLeaf() || taskStore.enableDependenciesForParentTasks) {
            var changed     = this.constrain(taskStore);
    
            if (changed) {
//                if (!context.fromTaskStore && taskStore.recalculateParents) this.recalculateParents();
                
                // update local context
                context.nbrAffected++;
                context.affected[ this.internalId ] = this;
                
                // update batch context
                if (currentCascadeBatch) currentCascadeBatch.addAffected(this);
                
                Ext.each(this.getOutgoingDependencies(true), function (dependency) {
    
                    var toTaskRecord = dependency.getTargetTask();
    
                    if (toTaskRecord && !toTaskRecord.isManuallyScheduled()) {
                        toTaskRecord.cascadeChanges(taskStore, context, dependency);
                    }
                });
            }
        }
        
        return context;
    },

    /**
    * Adds the passed task to the collection of child tasks.
    * @param {Gnt.model.Task} subtask The new subtask
    * @return {Gnt.model.Task} The added subtask task
    */
    addSubtask : function(subtask) {
        this.set('leaf', false);
        this.appendChild(subtask);

        this.expand();

        return subtask;
    },


    /**
    * Adds the passed task as a successor and creates a new dependency between the two tasks.
    * @param {Gnt.model.Task} (optional) successor The new successor
    * @return {Gnt.model.Task} the successor task
    */
    addSuccessor : function (successor) {
        var taskStore   = this.getTaskStore(),
            depStore    = this.getDependencyStore();

        successor               = successor || new this.self();

        successor.calendar      = successor.calendar || this.getCalendar();
        successor.taskStore     = taskStore;

        successor.setStartDate(this.getEndDate(), true, taskStore.skipWeekendsDuringDragDrop);
        successor.setDuration(1, Sch.util.Date.DAY);

        this.addTaskBelow(successor);

        var newDependency = new depStore.model({
             fromTask   : this,
             toTask     : successor,
             type       : depStore.model.Type.EndToStart
        });

        depStore.add(newDependency);

        return successor;
    },

    /**
    * Adds the passed task as a milestone below this task.
    * @param {Gnt.model.Task} (optional) milestone The milestone
    * @return {Gnt.model.Task} the new milestone
    */
    addMilestone : function(milestone) {
        var taskStore = this.getTaskStore();
        milestone = milestone || new this.self();

        var date = this.getEndDate();
        if (date) {
            milestone.calendar = milestone.calendar || this.getCalendar();
            milestone.setStartEndDate(date, date, taskStore.skipWeekendsDuringDragDrop);
        }

        return this.addTaskBelow(milestone);
   },

    /**
    * Adds the passed task as a predecessor and creates a new dependency between the two tasks.
    * @param {Gnt.model.Task} (optional) successor The new successor
    * @return {Gnt.model.Task} the new predecessor
    */
    addPredecessor : function(predecessor) {
        var depStore    = this.getDependencyStore();

        predecessor = predecessor || new this.self();
        predecessor.calendar = predecessor.calendar || this.getCalendar();

        predecessor.beginEdit();
        predecessor.set(this.startDateField, predecessor.calculateStartDate(this.getStartDate(), 1, Sch.util.Date.DAY));
        predecessor.set(this.endDateField, this.getStartDate());
        predecessor.set(this.durationField, 1);
        predecessor.set(this.durationUnitField, Sch.util.Date.DAY);
        predecessor.endEdit();

        this.addTaskAbove(predecessor);

        var newDependency = new depStore.model({
             fromTask   : predecessor,
             toTask     : this,
             type       : depStore.model.Type.EndToStart
        });

        depStore.add(newDependency);

        return predecessor;
    },

    /**
    * Returns all the successor tasks of this task
    *
    * @return {Gnt.model.Task[]}
    */
    getSuccessors: function () {
        var deps    = this.successors,
            res     = [];

        for (var i = 0, len = deps.length; i < len; i++) {
            var task = deps[i].getTargetTask();

            if (task) res.push(task);
        }

        return res;
    },

    /**
    * Returns all the predecessor tasks of a this task.
    *
    * @return {Gnt.model.Task[]}
    */
    getPredecessors: function () {
        var deps    = this.predecessors,
            res     = [];

        for (var i = 0, len = deps.length; i < len; i++) {
            var task = deps[i].getSourceTask();

            if (task) res.push(task);
        }

        return res;
    },

    /**
     * Adds the passed task (or creates a new task) before itself
     * @param {Gnt.model.Task} (optional) The task to add
     * @return {Gnt.model.Task} the newly added task
     */
    addTaskAbove : function (task) {
        task = task || new this.self();

        return this.parentNode.insertBefore(task, this);
    },

    /**
     * Adds the passed task (or creates a new task) after itself
     * @param {Gnt.model.Task} task (optional) The task to add
     * @return {Gnt.model.Task} the newly added task
     */
    addTaskBelow : function (task) {
        task = task || new this.self();

        if (this.nextSibling) {
            return this.parentNode.insertBefore(task, this.nextSibling);
        } else {
            return this.parentNode.appendChild(task);
        }
    },

    // Returns true if this task model is 'above' the passed task model
    isAbove : function(otherTask) {
        var me          = this,
            minDepth    = Math.min(me.data.depth, otherTask.data.depth);

        var current     = this;

        // Walk upwards until tasks are on the same level
        while (current.data.depth > minDepth) {
            current     = current.parentNode;

            if (current == otherTask) return false;
        }
        while (otherTask.data.depth > minDepth) {
            otherTask   = otherTask.parentNode;

            if (otherTask == me) return true;
        }

        // At this point, depth of both tasks should be identical.
        // Walk up to find common parent, to be able to compare indexes
        while (otherTask.parentNode !== current.parentNode) {
            otherTask   = otherTask.parentNode;
            current     = current.parentNode;
        }

        return otherTask.data.index > current.data.index;
    },

    /**
     * Cascades the children of a task. The given function is not called for this node itself.
     * @param {Function} fn The function to call for each child
     * @param {Object} scope The 'this' object to use for the function, defaults to the current node.
     */
    cascadeChildren : function(fn, scope) {
        var me = this;

        if (me.isLeaf()) return;
        
        var childNodes      = this.childNodes;
        
        for (var i = 0, len = childNodes.length; i < len; i++) childNodes[ i ].cascadeBy(fn, scope);
    },
    

    getViolatedConstraints : function () {
        if (!this.get('leaf') || this.isManuallyScheduled()) return false;

        var value   = this.getEarlyStartDate();

        if (this.getStartDate() < value) {
            return [{
                task        : this,
                startDate   : value
            }];
        }

        return null;
    },

    resolveViolatedConstraints : function (errors) {
        errors = errors || this.getViolatedConstraints();

        if (!errors) return;

        if (!Ext.isArray(errors)) errors = [errors];

        var store   = this.getTaskStore();

        for (var error, i = 0, l = errors.length; i < l; i++) {
            error   = errors[i];

            if (error.startDate) {
                error.task.setStartDate(error.startDate, true, store.skipWeekendsDuringDragDrop);
            } else if (error.endDate) {
                error.task.setEndDate(error.endDate, true, store.skipWeekendsDuringDragDrop);
            }
        }
    },

    /**
     * Returns the _slack_ (or _float_) of this task.
     * The _slack_ is the amount of time that this task can be delayed without causing a delay
     * to any of its successors.
     *
     * @param {String} unit The time unit used to calculate the slack.
     * @return {Number} The _slack_ of this task.
     */
    getSlack : function (unit) {
        unit = unit || Sch.util.Date.DAY;

        var earlyStart  = this.getEarlyStartDate(),
            lateStart   = this.getLateStartDate();

        if (!earlyStart || !lateStart) return null;

        // slack taking into account only working period of time
        return this.getCalendar().calculateDuration(this.getEarlyStartDate(), this.getLateStartDate(), unit);
    },

    /**
     * Returns the _early start date_ of this task.
     * The _early start date_ is the earliest possible start date of a task.
     * This value is calculated based on the earliest end dates of the task predecessors.
     * If the task has no predecessors, its start date is the early start date.
     *
     * @return {Date} The early start date.
     */
    getEarlyStartDate : function () {
        var store = this.getTaskStore();
        if (!store) return this.getEndDate();

        var internalId = this.internalId;
        if (store.earlyStartDates[internalId]) return store.earlyStartDates[internalId];

        var dt, result = 0, i, l;

        // for a parent task we take the minimum Early Start from its children
        if (this.childNodes.length) {

            for (i = 0, l = this.childNodes.length; i < l; i++) {
                dt = this.childNodes[i].getEarlyStartDate();
                if (dt < result || !result) result = dt;
            }

            store.earlyStartDates[internalId] = result;

            return result;
        }

        // for manually scheduled task we simply return its start date
        if (this.isManuallyScheduled())  {
            result = store.earlyStartDates[internalId] = this.getStartDate();
            return result;
        }

        var deps = this.getIncomingDependencies(true),
            fromTask;

        if (!deps.length) {
            result = store.earlyStartDates[internalId] = this.getStartDate();
            return result;
        }

        var depType     = Gnt.model.Dependency.Type,
            cal         = this.getCalendar(),
            projectCal  = this.getProjectCalendar(),
            lag;

        // Early Start Date is the largest of Early Finish Dates of the preceding tasks
        for (i = 0, l = deps.length; i < l; i++) {

            fromTask = deps[i].getSourceTask();

            if (fromTask) {
                switch (deps[i].getType()) {
                    case depType.StartToStart: // start-to-start
                        dt  = fromTask.getEarlyStartDate();
                        break;
                    case depType.StartToEnd: // start-to-end
                        dt  = fromTask.getEarlyStartDate();
                        // minus duration to get start
                        dt  = cal.calculateStartDate(dt, this.getDuration(), this.getDurationUnit());
                        break;
                    case depType.EndToStart: // end-to-start
                        dt  = fromTask.getEarlyEndDate();
                        break;
                    case depType.EndToEnd: // end-to-end
                        dt  = fromTask.getEarlyEndDate();
                        // minus duration to get start
                        dt  = cal.calculateStartDate(dt, this.getDuration(), this.getDurationUnit());
                        break;
                }

                // plus dependency Lag
                lag = deps[i].getLag();
                if (lag) dt = projectCal.skipWorkingTime(dt, lag, deps[i].getLagUnit());
                dt = projectCal.skipNonWorkingTime(dt, true);
            }

            if (dt > result) result = dt;
        }

        // store found value into the cache
        store.earlyStartDates[internalId] = result;

        return store.earlyStartDates[internalId];
    },

    /**
     * Returns the _early end date_ of the task.
     * The _early end date_ is the earliest possible end date of the task.
     * This value is calculated based on the earliest end dates of predecessors.
     * If the task has no predecessors then its end date is used as its earliest end date.
     *
     * @return {Date} The early end date.
     */
    getEarlyEndDate : function () {
        var store = this.getTaskStore();
        if (!store) return this.getEndDate();

        var internalId = this.internalId;
        if (store.earlyEndDates[internalId]) return store.earlyEndDates[internalId];

        var result = 0;
        // for parent task we take maximum Early Finish from its children
        if (this.childNodes.length) {
            var dt, i, l;

            for (i = 0, l = this.childNodes.length; i < l; i++) {
                dt = this.childNodes[i].getEarlyEndDate();
                if (dt > result) result = dt;
            }

            store.earlyEndDates[internalId] = result;

            return result;
        }

        // for manually scheduled task we simply return its end date
        if (this.isManuallyScheduled())  {
            result = store.earlyEndDates[internalId] = this.getEndDate();
            return result;
        }

        // Early Finish Date is Early Start Date plus duration
        var value = this.getEarlyStartDate();
        if (!value) return null;

        result = store.earlyEndDates[internalId] = this.getCalendar().calculateEndDate(value, this.getDuration(), this.getDurationUnit());

        return result;
    },

    /**
     * Returns the _late end date_ of the task.
     * The _late end date_ is the latest possible end date of the task.
     * This value is calculated based on the latest start dates of its successors.
     * If the task has no successors, the project end date is used as its latest end date.
     *
     * @return {Date} The late end date.
     */
    getLateEndDate : function () {
        var store = this.getTaskStore();
        if (!store) return this.getEndDate();

        var internalId = this.internalId;
        if (store.lateEndDates[internalId]) return store.lateEndDates[internalId];

        var dt, result = 0, i, l;

        // for parent task we take maximum Late Finish from its children
        if (this.childNodes.length) {
            for (i = 0, l = this.childNodes.length; i < l; i++) {
                dt = this.childNodes[i].getLateEndDate();
                if (dt > result) result = dt;
            }

            store.lateEndDates[internalId] = result;

            return result;
        }

        // for manually scheduled task we simply return its end date
        if (this.isManuallyScheduled())  {
            result = store.lateEndDates[internalId] = this.getEndDate();
            return result;
        }

        var deps = this.getOutgoingDependencies(true);

        if (!deps.length) {
            result = store.lateEndDates[internalId] = store.getProjectEndDate();
            return result;
        }

        var depType     = Gnt.model.Dependency.Type,
            cal         = this.getCalendar(),
            projectCal  = this.getProjectCalendar(),
            toTask, lag;

        // Late Finish Date is the smallest of Late Start Dates of succeeding tasks
        for (i = 0, l = deps.length; i < l; i++) {
            toTask = deps[i].getTargetTask();

            if (toTask) {
                switch (deps[i].getType()) {
                    case depType.StartToStart: // start-to-start
                        dt  = toTask.getLateStartDate();
                        // plus duration to get end
                        dt  = cal.calculateEndDate(dt, this.getDuration(), this.getDurationUnit());
                        break;
                    case depType.StartToEnd: // start-to-end
                        dt  = toTask.getLateEndDate();
                        // plus duration to get end
                        dt  = cal.calculateEndDate(dt, this.getDuration(), this.getDurationUnit());
                        break;
                    case depType.EndToStart: // end-to-start
                        dt  = toTask.getLateStartDate();
                        break;
                    case depType.EndToEnd: // end-to-end
                        dt  = toTask.getLateEndDate();
                        break;
                }

                // minus dependency Lag
                lag = deps[i].getLag();
                if (lag) dt  = projectCal.skipWorkingTime(dt, -lag, deps[i].getLagUnit());
                dt = projectCal.skipNonWorkingTime(dt, false);

                if (dt < result || !result) result = dt;
            }
        }

        // cache found value
        store.lateEndDates[internalId] = result || store.getProjectEndDate();

        return store.lateEndDates[internalId];
    },

    /**
     * Returns the _late start date_ of the task.
     * The _late start date_ is the latest possible start date of this task.
     * This value is calculated based on the latest start dates of its successors.
     * If the task has no successors, this value is calculated as the _project end date_ minus the task duration
     * (_project end date_ is the latest end date of all the tasks in the taskStore).
     *
     * @return {Date} The late start date.
     */
    getLateStartDate : function () {
        var store = this.getTaskStore();
        if (!store) return this.getStartDate();

        var internalId = this.internalId;
        if (store.lateStartDates[internalId]) return store.lateStartDates[internalId];

        var result;
        // for parent task we take minimum Late Start from its children
        if (this.childNodes.length) {
            var dt, i, l;

            for (i = 0, l = this.childNodes.length; i < l; i++) {
                dt = this.childNodes[i].getLateStartDate();
                if (dt < result || !result) result = dt;
            }

            store.lateStartDates[internalId] = result;

            return result;
        }

        // for manually scheduled task we simply return its start date
        if (this.isManuallyScheduled())  {
            result = store.lateStartDates[internalId] = this.getStartDate();
            return result;
        }

        // Late Start Date is Late Finish Date minus duration
        var value = this.getLateEndDate();
        if (!value) return null;

        result = store.lateStartDates[internalId] = this.getCalendar().calculateStartDate(value, this.getDuration(), this.getDurationUnit());

        return result;
    },

    resetEarlyDates : function () {
        var store = this.getTaskStore();
        if (!store) return;

        var internalId = this.internalId;
        store.earlyStartDates[internalId]    = null;
        store.earlyEndDates[internalId]      = null;
    },

    resetLateDates : function () {
        var store = this.getTaskStore();
        if (!store) return;

        var internalId = this.internalId;
        store.lateStartDates[internalId]    = null;
        store.lateEndDates[internalId]      = null;
    },

    
    getTopParent : function (all) {
        var root    = this.getTaskStore().getRootNode(),
            p       = this,
            path    = [ this ],
            result;

        while (p) {
            if (p === root) return all ? path : result;
            
            path.push(p);

            result  = p;
            p       = p.parentNode;
        }
    }
});

/**

@class Gnt.model.Task
@extends Sch.model.Range

This class represents a single task in your Gantt chart.

The inheritance hierarchy of this class includes {@link Sch.model.Customizable} and {@link Ext.data.Model} classes.
This class will also receive a set of methods and additional fields that stem from the {@link Ext.data.NodeInterface}.
Please refer to the documentation of those classes to become familiar with the base interface of this class.

By default, a Task has the following fields as seen below.

Fields
------

- `Id` - (mandatory) a unique identifier of the task
- `Name` - the name of the task (task title)
- `StartDate` - the start date of the task in the ISO 8601 format. See {@link Ext.Date} for a formats definitions.
- `EndDate` - the end date of the task in the ISO 8601 format, **see "Start and End dates" section for important notes**
- `Duration` - the numeric part of the task duration (the number of units)
- `DurationUnit` - the unit part of the task duration (corresponds to units defined in `Sch.util.Date`), defaults to "d" (days). Valid values are:
     - "ms" (milliseconds)
     - "s" (seconds)
     - "mi" (minutes)
     - "h" (hours)
     - "d" (days)
     - "w" (weeks)
     - "mo" (months)
     - "q" (quarters)
     - "y" (years)
- `Effort` - the numeric part of the task effort (the number of units). The effort of the "parent" tasks will be automatically set to the sum
of efforts of their "child" tasks
- `EffortUnit` - the unit part of the task effort (corresponds to units defined in `Sch.util.Date`), defaults to "h" (hours). Valid values are:
     - "ms" (milliseconds)
     - "s" (seconds)
     - "mi" (minutes)
     - "h" (hours)
     - "d" (days)
     - "w" (weeks)
     - "mo" (months)
     - "q" (quarters)
     - "y" (years)
- `PercentDone` - the current status of a task, expressed as the percentage completed (integer from 0 to 100)
- `Cls` - A CSS class that will be applied to each rendered task DOM element
- `BaselineStartDate` - the baseline start date of the task in the ISO 8601 format. See {@link Ext.Date} for a formats definitions.
- `BaselineEndDate` - the baseline end date of the task in the ISO 8601 format, **see "Start and End dates" section for important notes**
- `BaselinePercentDone` - the baseline status of a task, expressed as the percentage completed (integer from 0 to 100)
- `CalendarId` - the id of the calendar, assigned to task. Allows you to set the time when task can be performed.
Should be only provided for specific tasks - all tasks by default are assigned to the project calendar, provided as the
{@link Gnt.data.TaskStore#calendar} option.
- `SchedulingMode` - the field, defining the scheduling mode for the task. Based on this field some fields of the task
will be "fixed" (should be provided) and some - computed. See {@link #schedulingModeField} for details.
- `ManuallyScheduled` - **deprecated field**, use `SchedulingMode = Manual` instead. When set to `true`,
the `StartDate` of the task will not be changed by any of its incoming dependencies.
Additionally, a manually scheduled task can be scheduled to start/end on a weekend or a calendar holiday, iow - will ignore
any holidays when scheduling.
 `Note` A freetext note about the task.

If you want to add new fields or change the name/options for the existing fields,
you can do that by subclassing this class (see example below).

Subclassing the Task class
--------------------

The name of any field can be customized in the subclass. Please refer to {@link Sch.model.Customizable} for details.

    Ext.define('MyProject.model.Task', {
        extend      : 'Gnt.model.Task',

        nameField           : 'myName',
        percentDoneField    : 'percentComplete',

        isAlmostDone : function () {
            return this.get('percentComplete') > 80;
        },
        ...
    });

Creating a new Task instance programmatically
--------------------

To create a new task programmatically, simply call the Gnt.model.Task constructor and pass in any default field values.

    var newTask = new Gnt.model.Task({
        Name            : 'An awesome task',
        PercentDone     : 80, // So awesome it's almost done
        ...
    });

    // To take weekends and non-working time into account, the new task needs a reference to the task store (which has access to the global calendar)
    newTask.taskStore = taskStore;

    // Initialize new task to today
    newTask.setStartDate(new Date());

    // This is a leaf task
    newTask.set('leaf', true);

    // Now it will appear in the UI if the Gantt panel is rendered
    taskStore.getRootNode().appendChild(newTask);


Start and End dates
-------------------

For all tasks, the range between start date and end date is supposed to be not-inclusive on the right side: StartDate <= date < EndDate.
So, for example, the task which starts at 2011/07/18 and has 2 days duration, should have the end date: 2011/07/20, **not** 2011/07/19 23:59:59.

Such convention simplifies the calculations, since you don't have to constantly change the end date to ends with those "59:59" but should always be
considered, when writing the application. For example a 1 day task, which starts at 2011/07/18 00:00:00, will end at 2011/07/19 00:00:00, and so on.


Conversion to "days" duration unit
-----------------------------------

Some duration units cannot be converted to "days" consistently. For example a month may have 28, 29, 30 or 31 days. The year may have 365 or 366 days and so on.
So in such conversion operations, we will always assume that a task with a duration of 1 month will have a duration of 30 days.
This is {@link Gnt.data.Calendar#daysPerMonth a configuration option} of the calendar class.

Task API
-------

One important thing to consider is that, if you are using the availability/scheduling modes feature, then you need to use the task API call to update the fields like `StartDate / EndDate / Duration`.
Those calls will calculate the correct value of each the field, taking into account the information from calendar/assigned resources.

Server-side integration
-----------------------

Also, at least for now you should not use the "save" method of the model available in Ext 4:

    task.save() // WON'T WORK

This is because there are some quirks in using CRUD for Ext tree stores. These quirks are fixed in the TaskStore. To save the changes in task to server
use the "sync" method of the task store:

    taskStore.sync() // OK

*/
Ext.define('Gnt.model.Task', {
    extend              : 'Sch.model.Range',

    requires            : [
        'Sch.util.Date',
        'Ext.data.NodeInterface'
    ],

    mixins : [
        'Gnt.model.task.More'
    ],

    idProperty          : "Id",

    customizableFields     : [
        { name: 'Id' },
        { name: 'Duration', type: 'number', useNull: true },
        { name: 'Effort', type: 'number', useNull: true },
        { name: 'EffortUnit', type: 'string', defaultValue: 'h'},
        { name: 'CalendarId', type: 'string'},
        { name: 'Note', type: 'string'},

        {
            name: 'DurationUnit',
            type: 'string',
            defaultValue: "d",
            // make sure the default value is applied when user provides empty value for the field, like "" or null
            convert: function (value) {
                return value || "d";
            }
        },
        { name: 'PercentDone', type: 'number', defaultValue: 0 },

        // @deprecated
        { name: 'ManuallyScheduled', type: 'boolean', defaultValue: false },
        { name: 'SchedulingMode', type: 'string', defaultValue: 'Normal' },

        { name: 'BaselineStartDate', type: 'date', dateFormat: 'c' },
        { name: 'BaselineEndDate', type: 'date', dateFormat: 'c' },
        { name: 'BaselinePercentDone', type: 'int', defaultValue: 0 },
        { name: 'Draggable', type: 'boolean', persist: false, defaultValue : true },   // true or false
        { name: 'Resizable', persist: false },                                         // true, false, 'start' or 'end'

        // Two fields which specify the relations between "phantom" tasks when they are
        // being sent to the server to be created (e.g. when you create a new task containing a new child task).
        { name : 'PhantomId',          type: 'string'},
        { name : 'PhantomParentId',    type: 'string'},

        // Override NodeInterface defaults
        { name: 'index', type : 'int', persist : true }
    ],

    /**
     * @cfg {String} draggableField The name of the field specifying if the event should be draggable in the timeline
     */
    draggableField          : 'Draggable',

    /**
     * @cfg {String} resizableField The name of the field specifying if/how the event should be resizable.
     */
    resizableField          : 'Resizable',

    /**
     * @cfg {String} nameField The name of the field that holds the task name. Defaults to "Name".
     */
    nameField               : 'Name',

    /**
     * @cfg {String} durationField The name of the field holding the task duration.
     */
    durationField           : 'Duration',

    /**
     * @cfg {String} durationUnitField The name of the field holding the task duration unit.
     */
    durationUnitField       : 'DurationUnit',

    /**
     * @cfg {String} effortField The name of the field holding the value of task effort.
     */
    effortField             : 'Effort',

    /**
     * @cfg {String} effortUnitField The name of the field holding the task effort unit.
     */
    effortUnitField         : 'EffortUnit',


    /**
     * @cfg {String} percentDoneField The name of the field specifying the level of completion.
     */
    percentDoneField        : 'PercentDone',

    /**
     * @cfg {String} manuallyScheduledField The name of the field defining if a task is manually scheduled or not.
     * @deprecated
     * **This field is deprecated** in favor of "schedulingModeField".
     * To specify that task is manually scheduled set the value of "schedulingModeField" to "Manual"
     */
    manuallyScheduledField  : 'ManuallyScheduled',

    /**
     * @cfg {String} schedulingModeField The name of the field defining the scheduling mode of the task. Should be one of the
     * following strings:
     *
     * - `Normal` is the default (and backward compatible) mode. It means the task will be scheduled based only on information
     * about its start/end dates and project calendar. The individual calendars of tasks and resources will be ignored,
     * the effort and assigned resources of the task won't have any influence on its scheduling.
     *
     * - `FixedDuration` mode means, that task has fixed start and end dates, but its effort will be computed dynamically,
     * based on the assigned resources information. Typical example of such task is - meeting. Meetings typically have
     * pre-defined start and end dates and the more people are participating in the meeting, the more effort is spent on the task.
     * When duration of such task increases, its effort is increased too (and vice-versa).
     *
     * - `EffortDriven` mode means, that task has fixed effort and computed duration. The more resources will be assigned
     * to this task, the less the duration will be. The typical example will be a "paint the walls" task -
     * several painters will complete it faster.
     *
     * - `DynamicAssignment` mode can be used when both duration and effort of the task are fixed. The computed value in this
     * case will be - the assignment units of the resources assigned. In this mode, the assignment level of all assigned resources
     * will be updated to evenly distribute the task's workload among them.
     *
     * - `Manual` mode disables any additional calculations and the task will be scheduled based on only information about
     * its start/end dates. Any incoming dependencies won't affect the task.
     */
    schedulingModeField     : 'SchedulingMode',

    /**
     * @cfg {String} calendarIdField The name of the field defining the id of the calendar for this specific task. Task calendar has the highest priority.
     */
    calendarIdField         : 'CalendarId',

    /**
     * @cfg {String} baselineStartDateField The name of the field that holds the task baseline start date.
     */
    baselineStartDateField  : 'BaselineStartDate',

    /**
     * @cfg {String} baselineEndDateField The name of the field that holds the task baseline end date.
     */
    baselineEndDateField    : 'BaselineEndDate',

    /**
     * @cfg {String} baselinePercentDoneField The name of the field specifying the baseline level of completion.
     */
    baselinePercentDoneField    : 'BaselinePercentDone',

    /**
     * @cfg {String} noteField The name of the field specifying the task note.
     */
    noteField        : 'Note',

    /**
     * @cfg {Gnt.data.Calendar} calendar
     * Optional. An explicitly provided {@link Gnt.data.Calendar calendar} instance. Usually will be retrieved by the task from the {@link Gnt.data.TaskStore task store}.
     */
    calendar                : null,

    /**
     * @cfg {Gnt.data.DependencyStore} dependencyStore
     * Optional. An explicitly provided {@link Gnt.data.DependencyStore} with dependencies information. Usually will be retrieved by the task from the {@link Gnt.data.TaskStore task store}.
     */
    dependencyStore         : null,

    /**
     * @cfg {Gnt.data.TaskStore} taskStore
     * Optional. An explicitly provided Gnt.data.TaskStore with tasks information. Usually will be set by the {@link Gnt.data.TaskStore task store}.
     */
    taskStore               : null,

    /**
     * @cfg {String} phantomIdField The name of the field specifying the phantom id when this task is being 'realized' by the server.
     */
    phantomIdField          : 'PhantomId',

    /**
     * @cfg {String} phantomIdField The name of the field specifying the parent task phantom id when this task is being 'realized' by the server.
     */
    phantomParentIdField    : 'PhantomParentId',

    normalized              : false,

    recognizedSchedulingModes   : [ 'Normal', 'Manual', 'FixedDuration', 'EffortDriven', 'DynamicAssignment' ],

    /**
     * @cfg {Boolean} convertEmptyParentToLeaf
     *
     * This configuration option allows you to control whether an empty parent task should be converted into a leaf. Note, that
     * it's not a new field, but a regular configuration property of this class.
     *
     * Usually you will want to enable/disable it for the whole class:
     *

    Ext.define('MyApp.model.Task', {
        extend                      : 'Gnt.model.Task',

        convertEmptyParentToLeaf    : false
    })

     */
    convertEmptyParentToLeaf    : true,

    /**
     * @cfg {Boolean} autoCalculateEffortForParentTask
     *
     * This configuration option enables auto-calculation of the effort value for the parent task. When this option is enabled,
     * effort value of the parent tasks becomes not editable.
     *
     * Usually you will want to enable/disable it for the whole class:
     *

    Ext.define('MyApp.model.Task', {
        extend                              : 'Gnt.model.Task',

        autoCalculateEffortForParentTask    : false
    })

     *
     */
    autoCalculateEffortForParentTask        : true,

    /**
     * @cfg {Boolean} autoCalculatePercentDoneForParentTask
     *
     * This configuration option enables auto-calculation of the percent done value for the parent task. When this option is enabled,
     * percent done value of the parent tasks becomes not editable.
     *
     * Usually you will want to enable/disable it for the whole class:
     *

    Ext.define('MyApp.model.Task', {
        extend                                  : 'Gnt.model.Task',

        autoCalculatePercentDoneForParentTask   : false
    })

     *
     */
    autoCalculatePercentDoneForParentTask   : true,



    isHighlighted               : false,

    calendarWaitingListener     : null,

    childTasksDuration          : null,
    completedChildTasksDuration : null,
    
    totalCount                  : null,
    
    /**
     * @property {Array[Gnt.model.Dependency]} predecessors An array of dependencies, which are predecessors for this task. 
     * To access this property safely you can use {@link #getIncomingDependencies} method.
     */
    predecessors                : null,
    
    /**
     * @property {Array[Gnt.model.Dependency]} successors An array of dependencies, which are successors for this task. 
     * To access this property safely you can use {@link #getOutgoingDependencies} method.
     */
    successors                  : null,
    
    // special flag, that prevents parent from being converted into leafs when using "replaceChild" method
    // see `data_components/077_task_replace_child.t.js`
    removeChildIsCalledFromReplaceChild     : false,


    constructor : function () {
//        // hack that significantly speed up initial rendering, because
//        // thousands of expensive `getModifiedFieldNames` calls (due to `isDate` check) will be skipped
//        this.getModifiedFieldNames = function () {
//            if (this.__isFilling__) return [];
//
//            delete this.getModifiedFieldNames;
//
//            return this.getModifiedFieldNames.apply(this, arguments);
//        };

        this.callParent(arguments);

        if (this.phantom) {
            this.data[this.phantomIdField] = this.internalId;

            // @BW-COMPAT
            this._phantomId = this.internalId;
        }

        this.predecessors   = [];
        this.successors     = [];
    },


    // should be called once after initial loading - will convert the "EndDate" field to "Duration"
    // the model should have the link to calendar
    normalize: function () {
        var duration        = this.getDuration(),
            durationUnit    = this.getDurationUnit(),
            startDate       = this.getStartDate(),
            endDate         = this.getEndDate(),
            schedulingMode  = this.getSchedulingMode(),
            data            = this.data;
            
        var endDateField    = this.endDateField;
        var effortField     = this.effortField;

        if (endDate && this.inclusiveEndDate) {
            // End date supplied, if end dates are inclusive we need to adjust them -
            // but only IF:
            //      * The end-date dateFormat does not contain any hour info, OR
            //      * The end-date dateFormat does contain any hour info AND it has no hours/minutes/seconds/ms

            var format = this.fields.getByKey(endDateField).dateFormat;

            var doAdjust = (format && !Ext.Date.formatContainsHourInfo(format)) ||
                (endDate.getHours() === 0 && endDate.getMinutes() === 0 && endDate.getSeconds() === 0 && endDate.getMilliseconds() === 0);

            if (doAdjust) {
                if (Ext.isNumber(duration)) {
                    // Recalculate end date based on duration
                    endDate = data[ endDateField ] = this.calculateEndDate(startDate, duration, durationUnit);
                } else {
                    // Simply add 1 day to end date
                    endDate = data[ endDateField ] = Ext.Date.add(endDate, Ext.Date.DAY, 1);
                }
            }
        }

        // for all scheduling modes
        if (duration == null && startDate && endDate) {
            duration    = data[ this.durationField ] = this.calculateDuration(startDate, endDate, durationUnit);
        }

        if ((schedulingMode == 'Normal' || this.isManuallyScheduled()) && endDate == null && startDate && Ext.isNumber(duration)) {
            endDate     = data[ endDateField ] = this.calculateEndDate(startDate, duration, durationUnit);
        }

        // accessing the field value directly here, since we are interested in "raw" value
        // `getEffort` now returns 0 for empty effort values
        var effort          = this.get(effortField),
            effortUnit      = this.getEffortUnit();

        if (schedulingMode == 'FixedDuration') {
            if (endDate == null && startDate && Ext.isNumber(duration)) endDate = data[ endDateField ] = this.calculateEndDate(startDate, duration, durationUnit);

            if (effort == null && startDate && endDate) {
                data[ effortField ] = this.calculateEffort(startDate, endDate, effortUnit);
            }
        } else if (schedulingMode == 'EffortDriven') {
            if (effort == null && startDate && endDate) {
                data[ effortField ] = this.calculateEffort(startDate, endDate, effortUnit);
            }

            if (endDate == null && startDate && effort) {
                data[ endDateField ]  = this.calculateEffortDrivenEndDate(startDate, effort, effortUnit);

                // for "effortDriven" task, user can only provide StartDate and Effort - that's all we need
                if (duration == null) {
                    data[ this.durationField ] = this.calculateDuration(startDate, data[ endDateField ], durationUnit);
                }
            }
        } else {
            if (endDate == null && startDate && Ext.isNumber(duration)) endDate = data[ endDateField ] = this.calculateEndDate(startDate, duration, durationUnit);
        }

        var calendarId      = this.getCalendarId();

        if (calendarId) this.setCalendarId(calendarId, true);

        this.normalized = true;
    },


    // recursive task
    normalizeParent : function () {
        var childNodes              = this.childNodes;

        var totalEffortInMS         = 0;
        var totalDurationInMS       = 0;
        var completedDurationInMS   = 0;

        var autoCalculatePercentDoneForParentTask   = this.autoCalculatePercentDoneForParentTask;
        var autoCalculateEffortForParentTask        = this.autoCalculateEffortForParentTask;

        for (var i = 0; i < childNodes.length; i++) {
            var child               = childNodes[ i ];
            var isLeaf              = child.isLeaf();

            if (!isLeaf) child.normalizeParent();

            if (autoCalculateEffortForParentTask) {
                totalEffortInMS         += child.getEffort('MILLI');
            }

            if (autoCalculatePercentDoneForParentTask) {
                var durationInMS        = isLeaf ? child.getDuration('MILLI') || 0 : child.childTasksDuration;

                totalDurationInMS       += durationInMS;
                completedDurationInMS   += isLeaf ? durationInMS * (child.getPercentDone() || 0) : child.completedChildTasksDuration;
            }
        }

        if (autoCalculatePercentDoneForParentTask) {
            this.childTasksDuration             = totalDurationInMS;
            this.completedChildTasksDuration    = completedDurationInMS;

            var newPercentDone          = totalDurationInMS ? completedDurationInMS / totalDurationInMS : 0;

            if (this.getPercentDone() != newPercentDone)    this.data[ this.percentDoneField ] = newPercentDone;
        }

        if (autoCalculateEffortForParentTask) {
            if (this.getEffort('MILLI') != totalEffortInMS) this.data[ this.effortField ] = this.getProjectCalendar().convertMSDurationToUnit(totalEffortInMS, this.getEffortUnit());
        }
    },


    // We'll be using `internalId` for Id substitution when dealing with phantom records
    getInternalId: function(){
        return this.getId() || this.internalId;
    },


    /**
     * Returns the {@link Gnt.data.Calendar calendar} instance, associated with this task. If task has no own calendar, the project calendar will
     * be returned instead. See also `ownCalendarOnly` parameter and {@link #getOwnCalendar}, {@link #getProjectCalendar} methods.
     *
     * @param {Boolean} ownCalendarOnly When set to true, return only own calendar of this task and `null` if task has no calendar
     *
     * @return {Gnt.data.Calendar} calendar
     */
    getCalendar: function (ownCalendarOnly) {
        return ownCalendarOnly ? this.getOwnCalendar() : this.getOwnCalendar() || this.getProjectCalendar();
    },


    /**
     * Returns the {@link Gnt.data.Calendar calendar} instance, associated with this task (if any). See also {@link #calendarIdField}.
     *
     * @return {Gnt.data.Calendar} calendar
     */
    getOwnCalendar : function () {
        var calendarId    = this.get(this.calendarIdField);

        return calendarId ? Gnt.data.Calendar.getCalendar(calendarId) : this.calendar;
    },


    /**
     * Returns the {@link Gnt.data.Calendar calendar} instance, associated with the project of this task (with the TaskStore instance
     * this task belongs to).
     *
     * @return {Gnt.data.Calendar} calendar
     */
    getProjectCalendar: function () {
        var store       = this.getTaskStore(true);
        var calendar    = store && store.getCalendar() || this.parentNode && this.parentNode.getProjectCalendar() || this.isRoot() && this.calendar;

        if (!calendar) {
            Ext.Error.raise("Can't find a project calendar in `getProjectCalendar`");
        }

        return calendar;
    },


    /**
     * Sets the {@link Gnt.data.Calendar calendar}, associated with this task. Calendar must have a {@link Gnt.data.Calendar#calendarId calendarId} property
     * defined, which will be saved in the `CalendarId` field of this task.
     *
     * @param {Gnt.data.Calendar/String} calendar A calendar instance or string with calendar id
     */
    setCalendar: function (calendar) {
        var isCalendarInstance  = calendar instanceof Gnt.data.Calendar;

        if (isCalendarInstance && !calendar.calendarId) throw new Error("Can't set calendar w/o `calendarId` property");

        this.setCalendarId(isCalendarInstance ? calendar.calendarId : calendar);
    },


    setCalendarId : function (calendarId, isInitial) {
        if (calendarId instanceof Gnt.data.Calendar) calendarId = calendarId.calendarId;

        var prevCalendarId  = this.getCalendarId();

        if (prevCalendarId != calendarId || isInitial) {
            if (this.calendarWaitingListener) {
                this.calendarWaitingListener.destroy();
                this.calendarWaitingListener = null;
            }

            var listeners       = {
                calendarchange  : this.adjustToCalendar,
                scope           : this
            };

            var prevInstance        = this.calendar || Gnt.data.Calendar.getCalendar(prevCalendarId);

            // null-ifying the "explicit" property - it should not be used at all generally, only "calendarId"
            this.calendar   = null;

            prevInstance && prevInstance.un(listeners);

            this.set(this.calendarIdField, calendarId);

            var calendarInstance    = Gnt.data.Calendar.getCalendar(calendarId);

            if (calendarInstance) {
                calendarInstance.on(listeners);

                if (!isInitial) this.adjustToCalendar();
            } else {
                this.calendarWaitingListener = Ext.data.StoreManager.on('add', function (index, item, key) {
                    calendarInstance    = Gnt.data.Calendar.getCalendar(calendarId);

                    if (calendarInstance) {
                        this.calendarWaitingListener.destroy();
                        this.calendarWaitingListener = null;

                        calendarInstance.on(listeners);

                        this.adjustToCalendar();
                    }
                }, this, { destroyable : true });
            }
        }
    },


    /**
     * Returns the dependency store, associated with this task.
     *
     * @return {Gnt.data.DependencyStore} The dependency store instance
     */
    getDependencyStore: function () {
        var dependencyStore = this.dependencyStore || this.getTaskStore().dependencyStore;

        if (!dependencyStore) {
            Ext.Error.raise("Can't find a dependencyStore in `getDependencyStore`");
        }

        return dependencyStore;
    },


    /**
     * Returns the resource store, associated with this task.
     *
     * @return {Gnt.data.Resource} The resource store instance
     */
    getResourceStore : function () {
        return this.getTaskStore().getResourceStore();
    },


    /**
     * Returns the assignment store, associated with this task.
     *
     * @return {Gnt.data.AssignmentStore} The assignment store instance
     */
    getAssignmentStore : function () {
        return this.getTaskStore().getAssignmentStore();
    },


    /**
     * Returns the {@link Gnt.data.TaskStore task store} instance, associated with this task
     *
     * @return {Gnt.data.TaskStore} task store
     */
    getTaskStore: function (ignoreAbsense) {
        if (this.taskStore) return this.taskStore;

        var taskStore = (this.stores[0] && this.stores[0].treeStore) || this.parentNode && this.parentNode.getTaskStore(ignoreAbsense);

        if (!taskStore && !ignoreAbsense) {
            Ext.Error.raise("Can't find a taskStore in `getTaskStore`");
        }

        this.taskStore = taskStore;

        return taskStore;
    },

    /**
     * Provides a reference to a {@link Gnt.data.TaskStore task store} instance, which the task will use to access the global
     * {@link Gnt.data.Calendar calendar}. Calling this does *not* add the model to the task store. Call this method if you want to use
     * methods like setStartDate or setEndDate that should take the store calendar into account.
     *
     * @param {Gnt.data.TaskStore} the task store
     */
    setTaskStore: function (taskStore) {
        this.taskStore = taskStore;
    },


    /**
     * Returns true if the task is manually scheduled.
     *
     * @return {Boolean} The value of the ManuallyScheduled field
     */
    isManuallyScheduled: function () {
        return this.get(this.schedulingModeField) === 'Manual' || this.get(this.manuallyScheduledField);
    },

    /**
     * Sets the task manually scheduled status.
     * If that field was set to "Manual", calling this method with false value will set the scheduling mode to "Normal".
     *
     * @param {Boolean} The new value of the SchedulingMode field
     */
    setManuallyScheduled: function (value) {
        if (value) {
            this.set(this.schedulingModeField, 'Manual');
        } else {
            if (this.get(this.schedulingModeField) == 'Manual') {
                this.set(this.schedulingModeField, 'Normal');
            }
        }

        return this.set(this.manuallyScheduledField, value);
    },


    /**
     * @method getSchedulingMode
     *
     * Returns the scheduling mode of this task
     *
     * @return {String} scheduling mode string
     */


    /**
     * Sets the scheduling mode for this task.
     *
     * @param {String} value Name of the scheduling mode. See {@link #schedulingModeField} for details.
     */
    setSchedulingMode : function (value) {
        if (!Ext.Array.contains(this.recognizedSchedulingModes, value)) throw "Unrecognized scheduling mode: " + value;

        this.beginEdit();

        this.set(this.schedulingModeField, value);

        if (value === 'FixedDuration') {
            this.updateEffortBasedOnDuration();
        }

        if (value === 'EffortDriven') {
            this.updateDurationBasedOnEffort();
        }

        this.endEdit();
    },


    /**
     * @method getStartDate
     *
     * Returns the start date of this task
     *
     * @return {Date} start date
     */


    /**
     * @ignore
     */
    skipNonWorkingTime : function (date, isForward) {
        var skipped     = false;

        // resetting the date to the earliest availability interval
        // there's a possibility (when there are no assigned resources) that iterator function will never been called
        // in such case fallback to the `skipNonWorkingTime` of the tasks own calendar or project calendar
        this.forEachAvailabilityIntervalWithResources(
            isForward ? { startDate : date } : { endDate : date, isForward : false },

            function (intervalStartDate, intervalEndDate, currentResources) {
                date        = isForward ? intervalStartDate : intervalEndDate;
                skipped     = true;

                return false;
            }
        );

        return skipped ? new Date(date) : this.getCalendar().skipNonWorkingTime(date, isForward);
    },


    /**
     * Depending from the arguments, set either `StartDate + EndDate` fields of this task, or `StartDate + Duration`
     * considering the weekends/holidays rules. The modifications are wrapped with `beginEdit/endEdit` calls.
     *
     * @param {Date} date Start date to set
     * @param {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the task), `false` to change the duration ("resize" the task).
     * Default is `true`
     * @param {Boolean} skipNonWorkingTime Pass `true` to automatically move the start date to the earliest available working time (if it falls on non-working time).
     * Default is `false`
     * @param {Boolean} moveParentAsGroup Pass `true` to also update the start dates of the child tasks, keeping their relative positions.
     * Pass `false` to only update the start date of the parent task itself, not modifying any other task. Default value is `true`
     */
    setStartDate: function (date, keepDuration, skipNonWorkingTime, moveParentAsGroup) {
        moveParentAsGroup       = moveParentAsGroup !== false;
        var duration, endDate;

        this.beginEdit();

        var currentStartDate    = this.getStartDate();

        if (!date) {
            this.set(this.durationField, null);
            this.set(this.startDateField, null);
        } else {
            var calendar        = this.getCalendar();

            if (skipNonWorkingTime && !this.isManuallyScheduled()) {
                // for milestones we skip non-working backwards, for normal tasks - forward
                date            = this.skipNonWorkingTime(date, !this.isMilestone());
            }

            var taskStore       = this.getTaskStore(true);
            var schedulingMode  = this.getSchedulingMode();

            this.set(this.startDateField, date);

            // if there's no task store, move parent as a single task
            // same for the case when parent has no child tasks
            if (this.isLeaf() || !taskStore || !taskStore.moveParentAsGroup || !moveParentAsGroup || !this.childNodes.length) {
                // leaf branch
                if (keepDuration !== false) {
                    if (schedulingMode == 'EffortDriven') {
                        this.set(this.endDateField, this.calculateEffortDrivenEndDate(date, this.getEffort()));
                    } else {
                        duration    = this.getDuration();

                        if (Ext.isNumber(duration)) {
                            this.set(this.endDateField, this.calculateEndDate(date, duration, this.getDurationUnit()));
                        }
                    }
                } else {
                    endDate         = this.getEndDate();

                    if (endDate) {
                        this.set(this.durationField, this.calculateDuration(date, endDate, this.getDurationUnit()));
                    }
                }
            } else if (date != currentStartDate) {
                // parent task branch
                var cascadedTasksByInternalId       = {};
                
                taskStore.startBatchCascade();
                
                taskStore.suspendAutoRecalculateParents++;
                // suspend the auto-cascading because we'll do it manually if needed
                // (we need to get the tasks, affected by the cascade operation)
                taskStore.suspendAutoCascade++;

                var parentsContext                  = taskStore.getParentsContext();

                this.cascadeChildren(function (task) {
                    var isLeaf      = task.isLeaf();

                    // in case a parent task has no children it should be treated as leaf
                    if (isLeaf || !task.childNodes.length) {
                        // do not try to re-position the tasks, affected by cascading
                        if (!cascadedTasksByInternalId[ task.internalId ]) {
                            var offsetFromParent    = task.calculateDuration(currentStartDate, task.getStartDate());

                            // this won't cascade because cascading is suspended
                            task.setStartDate(task.calculateEndDate(date, offsetFromParent), true, skipNonWorkingTime, false);

                            if (taskStore.cascadeChanges) {
                                // cascading manually, saving affected tasks
                                var context         = taskStore.cascadeChangesForTask(task, true);

                                Ext.apply(cascadedTasksByInternalId, context.affected);
                            }
                        }
                    }

                    if (!isLeaf) {
                        taskStore.addTaskToParentsContext(parentsContext, task);
                    }
                });
                
                if (taskStore.recalculateParents || taskStore.cascadeChanges) {
                    taskStore.addTaskToParentsContext(parentsContext, this);

                    taskStore.recalculateAffectedParents(cascadedTasksByInternalId, parentsContext);
                }

                taskStore.suspendAutoRecalculateParents--;
                taskStore.suspendAutoCascade--;
                
                taskStore.endBatchCascade();
            }
        }
        // eof "has `date`" branch

        duration            = this.getDuration();
        endDate             = this.getEndDate();

        if (date && endDate && (duration === undefined || duration === null)) {
            this.set(this.durationField, this.calculateDuration(date, endDate, this.getDurationUnit()));
        }

        this.onPotentialEffortChange();

        this.endEdit();
    },


    /**
     * @method getEndDate
     *
     * Returns the end date of this task
     *
     * @return {Date} end date
     */


    // Note, that "setEndDate" for parent task is currently quite limited and won't set the correct end date
    // in case if some child tasks has dependencies between them, and cascading those dependencies reduces
    // the duration of parent task. In that case the end date of parent task will be reduced too.
    // To handle this case properly we need the "backward-cascade".
    /**
     * Depending from the arguments, set either `StartDate + EndDate` fields of this task, or `EndDate + Duration`
     * considering the weekends/holidays rules. The modifications are wrapped with `beginEdit/endEdit` calls.
     *
     * @param {Date} date End date to set
     * @param {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the task), `false` to change the duration ("resize" the task).
     * Default is `true`
     *
     * @param {Boolean} skipNonWorkingTime Pass `true` to automatically move the end date to the previous working day (if it falls on weekend/holiday).
     * Default is `false`
     */
    setEndDate: function (date, keepDuration, skipNonWorkingTime, moveParentAsGroup) {
        moveParentAsGroup       = moveParentAsGroup !== false;
        var duration, startDate;

        this.beginEdit();
        
        var currentEndDate    = this.getEndDate();

        if (!date) {
            this.set(this.durationField, null);
            this.set(this.endDateField, null);
        } else {
            var calendar    = this.getCalendar();

            startDate       = this.getStartDate();
            // task end date cannot be less than its start date
            if (date < startDate && keepDuration === false) {
                date        = startDate;
            }

            if (skipNonWorkingTime && !this.isManuallyScheduled()) {
                date        = this.skipNonWorkingTime(date, false);
            }
            
            var taskStore   = this.getTaskStore(true);
            
            if (this.isLeaf() || !taskStore || !taskStore.moveParentAsGroup || !moveParentAsGroup || !this.childNodes.length) {
                if (keepDuration !== false) {
                    duration    = this.getDuration();
    
                    if (Ext.isNumber(duration)) {
                        this.set(this.startDateField, this.calculateStartDate(date, duration, this.getDurationUnit()));
                        this.set(this.endDateField, date);
                    } else {
                        this.set(this.endDateField, date);
                    }
                } else {
                    var wasMilestone    = this.isMilestone();
    
                    // if end date after adjusting to calendar is less than start date
                    // then it's going to be a milestone and we set start date equal to adjusted end date
                    if (date < startDate) {
                        this.set(this.startDateField, date);
                    }
    
                    this.set(this.endDateField, date);
    
                    if (startDate) {
                        this.set(this.durationField, this.calculateDuration(startDate, date, this.getDurationUnit()));
    
                        // if we converted to regular task from milestone
                        // let's make sure that task start is adjusted to the calendar
                        if (wasMilestone && !this.isMilestone()) {
                            var properStartDate = this.skipNonWorkingTime(startDate, true);
                            if (properStartDate - startDate !== 0) {
                                // set start date adjusted to the calendar
                                this.set(this.startDateField, properStartDate);
                            }
                        }
                    }
                }
            } else if (date != currentEndDate) {
                var cascadedTasksByInternalId       = {};
                
                taskStore.startBatchCascade();
                
                taskStore.suspendAutoRecalculateParents++;
                // suspend the auto-cascading because we'll do it manually if needed
                // (we need to get the tasks, affected by the cascade operation)
                taskStore.suspendAutoCascade++;
                
                var parentsContext                  = taskStore.getParentsContext();
                
                this.cascadeChildren(function (task) {
                    var isLeaf      = task.isLeaf();
                    
                    // in case a parent task has no children it should be treated as leaf
                    if (isLeaf || !task.childNodes.length) {
                        // do not try to re-position the tasks, affected by cascading
                        if (!cascadedTasksByInternalId[ task.internalId ]) {
                            var offsetFromParent    = task.calculateDuration(task.getEndDate(), currentEndDate);
                            
                            // this won't cascade because cascading is suspended
                            task.setEndDate(task.calculateStartDate(date, offsetFromParent), true, skipNonWorkingTime, false);
                            
                            if (taskStore.cascadeChanges) {
                                // cascading manually, saving affected tasks
                                var context         = taskStore.cascadeChangesForTask(task, true);
                                
                                Ext.apply(cascadedTasksByInternalId, context.affected);
                            }
                        }
                    } 
                    
                    if (!isLeaf) {
                        taskStore.addTaskToParentsContext(parentsContext, task);
                    }
                });
                
                if (taskStore.recalculateParents || taskStore.cascadeChanges) {
                    taskStore.addTaskToParentsContext(parentsContext, this);
                    
                    taskStore.recalculateAffectedParents(cascadedTasksByInternalId, parentsContext);
                }
                
                taskStore.suspendAutoRecalculateParents--;
                taskStore.suspendAutoCascade--;
                
                taskStore.endBatchCascade();
            }
        }

        duration            = this.getDuration();
        startDate           = this.getStartDate();

        if (date && startDate && (duration === undefined || duration === null)) {
            this.set(this.durationField, this.calculateDuration(startDate, date, this.getDurationUnit()));
        }

        this.onPotentialEffortChange();

        this.endEdit();
    },


    /**
     * Sets the `StartDate / EndDate / Duration` fields of this task, considering the availability/holidays information.
     * The modifications are wrapped with `beginEdit/endEdit` calls.
     *
     * @param {Date} startDate Start date to set
     * @param {Date} endDate End date to set
     * @param {Boolean} skipNonWorkingTime Pass `true` to automatically move the start/end dates to the next/previous working day (if they falls on weekend/holiday).
     * Default is `false`
     */
    setStartEndDate: function (startDate, endDate, skipNonWorkingTime) {
        this.beginEdit();

        if (skipNonWorkingTime && !this.isManuallyScheduled()) {
            startDate       = startDate && this.skipNonWorkingTime(startDate, true);
            endDate         = endDate && this.skipNonWorkingTime(endDate, false);

            if (endDate < startDate) {
                startDate = endDate;
            }
        }

        this.set(this.startDateField, startDate);
        this.set(this.endDateField, endDate);
        this.set(this.durationField, this.calculateDuration(startDate, endDate, this.getDurationUnit()));

        this.onPotentialEffortChange();

        this.endEdit();
    },


    /**
     * Returns the duration of the task expressed in the unit passed as the only parameter (or as specified by the DurationUnit for the task).
     *
     * @param {String} unit Unit to return the duration in. Defaults to the `DurationUnit` field of this task
     *
     * @return {Number} duration
     */
    getDuration: function (unit) {
        if (!unit) return this.get(this.durationField);

        var calendar        = this.getProjectCalendar(),
            durationInMS    = calendar.convertDurationToMs(this.get(this.durationField), this.get(this.durationUnitField));

        return calendar.convertMSDurationToUnit(durationInMS, unit);
    },


    /**
     * Returns the effort of the task expressed in the unit passed as the only parameter (or as specified by the EffortUnit for the task).
     *
     * @param {String} unit Unit to return the effort in. Defaults to the `EffortUnit` field of this task
     *
     * @return {Number} effort
     */
    getEffort: function (unit) {
        var fieldValue      = this.get(this.effortField) || 0;

        if (!unit) return fieldValue;

        var calendar        = this.getProjectCalendar(),
            durationInMS    = calendar.convertDurationToMs(fieldValue, this.getEffortUnit());

        return calendar.convertMSDurationToUnit(durationInMS, unit);
    },


    /**
     * Sets the `Effort + EffortUnit` fields of this task. In case the task has the `EffortDriven`
     * {@link #schedulingModeField scheduling mode} will also update the duration of the task accordingly.
     * In case of `DynamicAssignment` mode - will update the assignments.
     *
     * The modifications are wrapped with `beginEdit/endEdit` calls.
     *
     * @param {Number} number The number of duration units
     * @param {String} unit The unit of the duration. Defaults to the `DurationUnit` field of this task
     */
    setEffort: function (number, unit) {
        unit = unit || this.get(this.effortUnitField);

        this.beginEdit();

        this.set(this.effortField, number);
        this.set(this.effortUnitField, unit);

        if (this.getSchedulingMode() === 'EffortDriven') {
            this.updateDurationBasedOnEffort();
        }

        if (this.getSchedulingMode() === 'DynamicAssignment') {
            this.updateAssignments();
        }

        this.endEdit();
    },


    /**
     * Returns the "raw" calendar duration (difference between end and start date) of this task in the given units.
     *
     * Please refer to the "Task durations" section for additional important details about duration units.
     *
     * @param {String} unit Unit to return return the duration in. Defaults to the `DurationUnit` field of this task
     *
     * @return {Number} duration
     */
    getCalendarDuration: function (unit) {
        return this.getProjectCalendar().convertMSDurationToUnit(this.getEndDate() - this.getStartDate(), unit || this.get(this.durationUnitField));
    },


    /**
     * Sets the `Duration + DurationUnit + EndDate` fields of this task, considering the weekends/holidays rules.
     * The modifications are wrapped with `beginEdit/endEdit` calls.
     *
     * May also update additional fields, depending from the {@link #schedulingModeField scheduling mode}.
     *
     * @param {Number} number The number of duration units
     * @param {String} unit The unit of the duration. Defaults to the `DurationUnit` field of this task
     */
    setDuration: function (number, unit) {
        unit = unit || this.get(this.durationUnitField);

        var wasMilestone = this.isMilestone();

        this.beginEdit();

        // Provide now as start date if it isn't already set
        if (Ext.isNumber(number) && !this.getStartDate()) {
            var today = new Date();
            Ext.Date.clearTime(today);
            this.setStartDate(today);
        }

        var newEndDate = null;

        if (Ext.isNumber(number)) {
            newEndDate = this.calculateEndDate(this.getStartDate(), number, unit);
        }

        this.set(this.endDateField, newEndDate);
        this.set(this.durationField, number);
        this.set(this.durationUnitField, unit);

        // if task is switched to/from milestone then we also need
        // to check if start/end dates are adjusted to the calendar
        if (this.isMilestone() != wasMilestone) {
            // if it's not a milestone now
            if (wasMilestone) {
                // check if start date is adjusted to calendar
                var startDate       = this.getStartDate();
                if (startDate) {
                    var properStartDate = this.skipNonWorkingTime(startDate, true);
                    if (properStartDate - startDate !== 0) {
                        // set start date adjusted to the calendar
                        this.set(this.startDateField, properStartDate);
                    }
                }
            // if it's a milestone
            } else if (newEndDate) {
                // skip non-working time backward
                var properEndDate   = this.skipNonWorkingTime(newEndDate, false);
                if (properEndDate - newEndDate !== 0) {
                    // set start/end dates adjusted to the calendar
                    this.set(this.startDateField, properEndDate);
                    this.set(this.endDateField, properEndDate);
                }
            }
        }

        this.onPotentialEffortChange();

        this.endEdit();
    },


    calculateStartDate : function (endDate, duration, unit) {
        unit = unit || this.getDurationUnit();

        if (!duration) return endDate;

        if (this.isManuallyScheduled()) {
            return Sch.util.Date.add(endDate, unit, -duration);
        } else {
            // if there are any assignments, need to take them into account when calculating the duration
            if (this.getTaskStore(true) && this.hasResources()) {

                var remainingDurationInMS   = this.getProjectCalendar().convertDurationToMs(duration, unit || this.getDurationUnit());

                var startDate;

                this.forEachAvailabilityIntervalWithResources({ endDate : endDate, isForward : false }, function (intervalStartDate, intervalEndDate, currentResources) {
                    var intervalDuration    = intervalEndDate - intervalStartDate;

                    if (intervalDuration >= remainingDurationInMS) {

                        startDate             = new Date(intervalEndDate - remainingDurationInMS);

                        return false;

                    } else {
                        remainingDurationInMS   -= intervalDuration;
                    }
                });

                return startDate;

            } else {
                // otherwise just consult the calendar
                return this.getCalendar().calculateStartDate(endDate, duration, unit);
            }
        }
    },


    endEdit : function(silent, modifiedFieldNames) {
        var savedDirty  = this.dirty;

        this.dirty      = false;

        // if record becomes dirty once, every further "endEdit" will trigger an "update" event, even if
        // no changes were made in the model (like "model.set('foo', model.get('foo')),
        // this happens because of this check in the Ext.data.Model:
        //
        //                changed = me.dirty || modifiedFieldNames.length > 0;
        //                if (changed) {
        //                    me.afterEdit(modifiedFieldNames);
        //                }
        //
        // in the same time, the number of modified fields is sufficient indicator whether "update" should
        // be fired, so we suppress "me.dirty" check
        this.callParent(arguments);

        this.dirty      = savedDirty;
    },


    calculateEndDate : function (startDate, duration, unit) {
        unit = unit || this.getDurationUnit();

        if (!duration) return startDate;

        if (this.isManuallyScheduled()) {
            return Sch.util.Date.add(startDate, unit, duration);
        } else {
            var schedulingMode  = this.getSchedulingMode();

            // if there are any assignments, need to take them into account when calculating the duration
            // but only for "normal" scheduling mode
            // for "EffortDriven" one should use "calculateEffortDrivenEndDate"
            // for "FixedDuration/DynamicAssignment" assignments should not affect the end date of the task
            if (
                this.getTaskStore(true) && this.hasResources() &&
                    schedulingMode != 'FixedDuration' && schedulingMode != 'DynamicAssignment' && schedulingMode != 'EffortDriven'
            ) {
                var remainingDurationInMS   = this.getProjectCalendar().convertDurationToMs(duration, unit || this.getDurationUnit());

                var endDate;

                this.forEachAvailabilityIntervalWithResources({ startDate : startDate }, function (intervalStartDate, intervalEndDate, currentResources) {
                    var intervalDuration    = intervalEndDate - intervalStartDate;

                    if (intervalDuration >= remainingDurationInMS) {

                        endDate             = new Date(intervalStartDate + remainingDurationInMS);

                        return false;

                    } else {
                        remainingDurationInMS   -= intervalDuration;
                    }
                });

                return endDate;

            } else {
                // otherwise just consult the calendar
                return this.getCalendar().calculateEndDate(startDate, duration, unit);
            }
        }
    },


    calculateDuration : function (startDate, endDate, unit) {
        unit = unit || this.getDurationUnit();

        if (!startDate || !endDate) {
            return 0;
        }

        if (this.isManuallyScheduled()) {
            return this.getProjectCalendar().convertMSDurationToUnit(endDate - startDate, unit);
        } else {
            // if there are any assignments, need to take them into account when calculating the duration
            if (this.getTaskStore(true) && this.hasResources()) {
                var durationInMS    = 0;

                this.forEachAvailabilityIntervalWithResources({ startDate : startDate, endDate : endDate }, function (intervalStartDate, intervalEndDate, currentResources) {
                    durationInMS    += intervalEndDate - intervalStartDate;
                });

                return this.getProjectCalendar().convertMSDurationToUnit(durationInMS, unit);
            } else {
                // otherwise just consult the calendar
                return this.getCalendar().calculateDuration(startDate, endDate, unit);
            }
        }
    },


    isCalendarApplicable : function (calendarId) {
        var startDate   = this.getStartDate();

        if (!startDate) return true;

        var taskStore   = this.getTaskStore(true);
        if (!taskStore) return true;

        var endDate     = Sch.util.Date.add(startDate, 'd', (taskStore && taskStore.availabilitySearchLimit) || 5*365);

        var assignments         = this.getAssignments();
        var resourcesCalendars  = [];

        Ext.each(assignments, function (assignment) {
            var resource    = assignment.getResource();

            if (resource) {
                resourcesCalendars.push(resource.getCalendar());
            }
        });

        if (!resourcesCalendars.length) return true;

        var calendar = Gnt.data.Calendar.getCalendar(calendarId);

        for (var i = 0, l = resourcesCalendars.length; i < l; i++) {
            if (calendar.isAvailabilityIntersected(resourcesCalendars[i], startDate, endDate)) return true;
        }

        return false;
    },


    // iterates over the common availability intervals for tasks and resources in between `startDate/endDate`
    // note, that function will receive start/end dates as number, not dates (for optimization purposes)
    // this method is not "normalized" intentionally because of performance considerations
    forEachAvailabilityIntervalWithResources : function (options, func, scope) {
        scope                       = scope || this;

        var me                      = this;

        var startDate               = options.startDate;
        var endDate                 = options.endDate;

        // isForward by default
        var isForward               = options.isForward !== false;

        if (isForward ? !startDate : !endDate) {
            throw new Error("At least `startDate` or `endDate` is required, depending from the `isForward` option");
        }

        var cursorDate              = new Date(isForward ? startDate : endDate);
        var includeEmptyIntervals   = options.includeEmptyIntervals;

        var taskCalendar            = this.getOwnCalendar();
        var hasTaskCalendar         = Boolean(taskCalendar);

        var projectCalendar         = this.getProjectCalendar();

        var resources, resourcesCalendars, assignments;

        // user has provided the resources to use for iteration
        if (options.resources) {
            resources                   = options.resources;
            assignments                 = [];
            resourcesCalendars          = [];

            Ext.each(resources, function (resource) {
                resourcesCalendars.push(resource.getCalendar());
                assignments.push(me.getAssignmentFor(resource));
            });

        } else {
            // otherwise retrieve all assigned resources
            assignments                 = this.getAssignments();

            resources                   = [];
            resourcesCalendars          = [];

            Ext.each(assignments, function (assignment) {
                var resource    = assignment.getResource();

                if (resource) {
                    resources.push(resource);
                    resourcesCalendars.push(resource.getCalendar());
                }
            });
        }

        // if there are no resources - then iterator should not be called by contract, just return
        if (!resources.length) return;

        var DATE            = Sch.util.Date;

        var i, k, interval, intervalStartDate, intervalEndDate;

        var store           = this.getTaskStore(true);

        // if no boundary we still have to specify some limit
        if (isForward) {
            if (!endDate) {
                endDate     = DATE.add(startDate, 'd', options.availabilitySearchLimit || store.availabilitySearchLimit || 5*365);
            }
        } else {
            if (!startDate) {
                startDate   = DATE.add(endDate, 'd', - (options.availabilitySearchLimit || store.availabilitySearchLimit || 5*365));
            }
        }

        while (isForward ? cursorDate < endDate : cursorDate > startDate) {
            var pointsByTime        = {};
            var pointTimes          = [];

            if (hasTaskCalendar) {
                var taskIntervals       = taskCalendar.getAvailabilityIntervalsFor(cursorDate - (isForward ? 0 : 1));

                // using "for" instead of "each" should be blazing fast! :)
                // the order of intervals processing doesn't matter here, since we are just collecting the "points of interest"
                for (k = 0; k < taskIntervals.length; k++) {
                    interval            = taskIntervals[ k ];
                    intervalStartDate   = interval.startDate - 0;
                    intervalEndDate     = interval.endDate - 0;

                    if (!pointsByTime[ intervalStartDate ]) {
                        pointsByTime[ intervalStartDate ] = [];

                        pointTimes.push(intervalStartDate);
                    }
                    pointsByTime[ intervalStartDate ].push({
                        type            : '00-taskAvailailabilityStart',
                        typeBackward    : '01-taskAvailailabilityStart'
                    });

                    pointTimes.push(intervalEndDate);

                    pointsByTime[ intervalEndDate ] = pointsByTime[ intervalEndDate ] || [];
                    pointsByTime[ intervalEndDate ].push({
                        type            : '01-taskAvailailabilityEnd',
                        typeBackward    : '00-taskAvailailabilityEnd'
                    });
                }
            }

            // using "for" instead of "each" should be blazing fast! :)
            for (i = 0; i < resourcesCalendars.length; i++) {
                var resourceIntervals       = resourcesCalendars[ i ].getAvailabilityIntervalsFor(cursorDate - (isForward ? 0 : 1));

                // using "for" instead of "each" should be blazing fast! :)
                // the order of intervals processing doesn't matter here, since we are just collecting the "points of interest"
                for (k = 0; k < resourceIntervals.length; k++) {
                    interval            = resourceIntervals[ k ];
                    intervalStartDate   = interval.startDate - 0;
                    intervalEndDate     = interval.endDate - 0;

                    if (!pointsByTime[ intervalStartDate ]) {
                        pointsByTime[ intervalStartDate ] = [];

                        pointTimes.push(intervalStartDate);
                    }
                    pointsByTime[ intervalStartDate ].push({
                        type            : '02-resourceAvailailabilityStart',
                        typeBackward    : '03-resourceAvailailabilityStart',
                        assignment      : assignments[ i ],
                        resourceId      : resources[ i ].getInternalId(),
                        units           : assignments[ i ].getUnits()
                    });

                    if (!pointsByTime[ intervalEndDate ]) {
                        pointsByTime[ intervalEndDate ] = [];

                        pointTimes.push(intervalEndDate);
                    }
                    pointsByTime[ intervalEndDate ].push({
                        type            : '03-resourceAvailailabilityEnd',
                        typeBackward    : '02-resourceAvailailabilityEnd',
                        assignment      : assignments[ i ],
                        resourceId      : resources[ i ].getInternalId(),
                        units           : assignments[ i ].getUnits()
                    });
                }
            }

            pointTimes.sort();

            var inTask              = false;
            var currentResources    = {};
            var resourceCounter     = 0;
            var points, point;

            if (isForward) {
                for (i = 0; i < pointTimes.length; i++) {
                    points          = pointsByTime[ pointTimes[ i ] ];

                    points.sort(function (a, b) { return a.type < b.type ? 1 : -1; });

                    for (k = 0; k < points.length; k++) {
                        point           = points[ k ];

                        if (point.type == '00-taskAvailailabilityStart') {
                            inTask      = true;
                        }

                        if (point.type == '01-taskAvailailabilityEnd') {
                            inTask      = false;
                        }

                        if (point.type == '02-resourceAvailailabilityStart') {
                            currentResources[ point.resourceId ] = point;
                            resourceCounter++;
                        }

                        if (point.type == '03-resourceAvailailabilityEnd') {
                            delete currentResources[ point.resourceId ];
                            resourceCounter--;
                        }
                    }

                    if ((inTask || !hasTaskCalendar) && (resourceCounter || includeEmptyIntervals)) {
                        intervalStartDate       = pointTimes[ i ];
                        intervalEndDate         = pointTimes[ i + 1 ];

                        // availability interval is out of [ startDate, endDate )
                        if (intervalStartDate >= endDate || intervalEndDate <= startDate) continue;

                        if (intervalStartDate < startDate) intervalStartDate = startDate - 0;
                        if (intervalEndDate > endDate) intervalEndDate = endDate - 0;

                        if (func.call(scope, intervalStartDate, intervalEndDate, currentResources) === false) return false;
                    }
                }
            } else {
                for (i = pointTimes.length - 1; i >= 0; i--) {
                    points          = pointsByTime[ pointTimes[ i ] ];

                    points.sort(function (a, b) { return a.typeBackward < b.typeBackward ? 1 : -1; });

                    for (k = 0; k < points.length; k++) {
                        point           = points[ k ];

                        if (point.typeBackward == '00-taskAvailailabilityEnd') {
                            inTask      = true;
                        }

                        if (point.typeBackward == '01-taskAvailailabilityStart') {
                            inTask      = false;
                        }

                        if (point.typeBackward == '02-resourceAvailailabilityEnd') {
                            currentResources[ point.resourceId ] = point;
                            resourceCounter++;
                        }

                        if (point.typeBackward == '03-resourceAvailailabilityStart') {
                            delete currentResources[ point.resourceId ];
                            resourceCounter--;
                        }
                    }

                    if ((inTask || !hasTaskCalendar) && (resourceCounter || includeEmptyIntervals)) {
                        intervalStartDate       = pointTimes[ i - 1 ];
                        intervalEndDate         = pointTimes[ i ];

                        // availability interval is out of [ startDate, endDate )
                        if (intervalStartDate > endDate || intervalEndDate <= startDate) continue;

                        if (intervalStartDate < startDate) intervalStartDate = startDate - 0;
                        if (intervalEndDate > endDate) intervalEndDate = endDate - 0;

                        if (func.call(scope, intervalStartDate, intervalEndDate, currentResources) === false) return false;
                    }
                }
            }
            // eof backward branch

            // does not perform cloning internally!
            cursorDate       = isForward ? DATE.getStartOfNextDay(cursorDate) : DATE.getEndOfPreviousDay(cursorDate);
        }
        // eof while
    },
    // eof forEachAvailabilityIntervalWithResources


    calculateEffortDrivenEndDate : function (startDate, effort, unit) {
        var effortInMS      = this.getProjectCalendar().convertDurationToMs(effort, unit || this.getEffortUnit());

        var endDate         = new Date(startDate);

        this.forEachAvailabilityIntervalWithResources({ startDate : startDate }, function (intervalStartDate, intervalEndDate, currentResources) {
            var totalUnits          = 0;

            for (var i in currentResources) totalUnits += currentResources[ i ].units;

            var intervalDuration    = intervalEndDate - intervalStartDate;
            var availableEffort     = totalUnits * intervalDuration / 100;

            if (availableEffort >= effortInMS) {

                endDate             = new Date(intervalStartDate + effortInMS / availableEffort * intervalDuration);

                return false;

            } else {
                effortInMS          -= availableEffort;
            }
        });

        return endDate;
    },


    // this method has a contract that all child parents should already have refeshed data, so it should be called
    // in the "bubbling" order - starting from deeper nodes to closer to root
    refreshCalculatedParentNodeData : function () {
        var earliest                    = new Date(9999, 0, 0),
            latest                      = new Date(0);

        var autoCalculatePercentDoneForParentTask   = this.autoCalculatePercentDoneForParentTask;
        var autoCalculateEffortForParentTask        = this.autoCalculateEffortForParentTask;

        var changedFields               = {};

        if (this.childNodes.length > 0 && (autoCalculateEffortForParentTask || autoCalculatePercentDoneForParentTask)) {
            var totalEffortInMS         = 0;
            var totalDurationInMS       = 0;
            var completedDurationInMS   = 0;

            for (var k = 0, len = this.childNodes.length; k < len; k++) {
                var childNode           = this.childNodes[ k ];
                var isLeaf              = childNode.isLeaf();

                if (autoCalculateEffortForParentTask) totalEffortInMS += childNode.getEffort('MILLI');

                if (autoCalculatePercentDoneForParentTask) {
                    var durationInMS        = isLeaf ? childNode.getDuration('MILLI') || 0 : childNode.childTasksDuration;

                    totalDurationInMS       += durationInMS;
                    completedDurationInMS   += isLeaf ? durationInMS * (childNode.getPercentDone() || 0) : childNode.completedChildTasksDuration;
                }
            }

            if (autoCalculateEffortForParentTask && this.getEffort('MILLI') != totalEffortInMS) {
                changedFields.Effort        = true;
                this.setEffort(this.getProjectCalendar().convertMSDurationToUnit(totalEffortInMS, this.getEffortUnit()));
            }

            if (autoCalculatePercentDoneForParentTask) {
                this.childTasksDuration             = totalDurationInMS;
                this.completedChildTasksDuration    = completedDurationInMS;

                var newPercentDone          = totalDurationInMS ? completedDurationInMS / totalDurationInMS : 0;

                if (this.getPercentDone() != newPercentDone) {
                    changedFields.PercentDone       = true;
                    this.setPercentDone(newPercentDone);
                }
            }
        }


        var startChanged, endChanged;

        if (!this.isRoot() && this.childNodes.length > 0) {

            if (!this.isManuallyScheduled()) {

                for (var i = 0, l = this.childNodes.length; i < l; i++) {
                    var r       = this.childNodes[i];

                    earliest    = Sch.util.Date.min(earliest, r.getStartDate() || earliest);
                    latest      = Sch.util.Date.max(latest, r.getEndDate() || latest);
                }

                startChanged    = changedFields.StartDate = earliest - new Date(9999, 0, 0) !== 0 && this.getStartDate() - earliest !== 0;
                endChanged      = changedFields.EndDate = latest - new Date(0) !== 0 && this.getEndDate() - latest !== 0;

                // special case to only trigger 1 update event and avoid extra "recalculateParents" calls
                // wrapping with `beginEdit / endEdit` is not an option, because they do not nest (one "endEdit" will "finalize" all previous "beginEdit")
                if (startChanged && endChanged) {
                    this.setStartEndDate(earliest, latest, false);
                } else if (startChanged) {
                    this.setStartDate(earliest, false, false, false);
                } else if (endChanged) {
                    this.setEndDate(latest, false, false, false);
                }
            }
        }

        return changedFields;
    },


    recalculateParents: function () {
        var parent          = this.parentNode;

        if (parent) {
            var changedFields   = parent.refreshCalculatedParentNodeData();
            var startChanged    = changedFields.StartDate;
            var endChanged      = changedFields.EndDate;

            // if `startChanged` or `endChanged` is true, then propagation to parent task has alreday happened in the
            // `onTaskUpdated` method of the TaskStore (during setStart/EndDate call), otherwise need to propagate it manually
            //
            // In the case of cascading, the store listeners are temporarily disabled so we should bubble up if there's a change
            if ((this.getTaskStore().cascading && (startChanged || endChanged)) || (!startChanged && !endChanged)) {
                if (!parent.isRoot()) parent.recalculateParents();
            }
        }
    },


    /**
     * Returns true if this task is a milestone (has the same start and end dates).
     *
     * @param {Boolean} isBaseline Whether to check for baseline dates instead of "normal" dates. If this argument is provided with
     * "true" value, this method returns the result from the {@link #isBaselineMilestone} method.
     *
     * @return {Boolean}
     */
    isMilestone: function (isBaseline) {
        return isBaseline ? this.isBaselineMilestone() : this.getDuration() === 0;
    },

    /**
     * Converts this task to a milestone (start date will match the end date).
     *
     * @return {Boolean}
     */
    convertToMilestone: function() {
        if (!this.isMilestone()) {
            this.setStartDate(this.getEndDate(), false);
            this.setDuration(0);
        }
    },

    /**
     * Converts a milestone task to a regular task with a duration of 1 [durationUnit].
     *
     * @return {Boolean}
     */
    convertToRegular: function() {
        if (this.isMilestone()) {
            var unit = this.get(this.durationUnitField);
            this.setDuration(1, unit);

            var newStart = this.calculateStartDate(this.getStartDate(), 1, unit);
            // we set the `moveParentAsGroup` flag to false, because in this case we don't want/need to
            // change any of child tasks
            this.setStartDate(newStart, true, false, false);
        }
    },

    /**
     * Returns true if this task is a "baseline" milestone (has the same start and end baseline dates) or false if it's not or the dates are wrong.
     *
     * @return {Boolean}
     */
    isBaselineMilestone: function() {
        var baseStart = this.getBaselineStartDate(),
            baseEnd   = this.getBaselineEndDate();

        if (baseStart && baseEnd){
            return baseEnd - baseStart === 0;
        }
        return false;
    },


    // Tested in 064_model_binding_to_taskstore.t.js
    // @OVERRIDE
    // TODO remove "isFillingRoot" from task store
    afterEdit: function (modifiedFieldNames) {

        // If a node is bound to a store, 'update' will be fired from the task store.
        // Required because of the Ext lazy loading of tree nodes.
        // See http://www.sencha.com/forum/showthread.php?180406-4.1B2-TreeStore-inconsistent-firing-of-update
        if (this.stores.length > 0 || !this.normalized) {
            this.callParent(arguments);
        } else {
            var taskStore = this.taskStore || this.getTaskStore(true);

            if (taskStore && !taskStore.isFillingRoot) {
                taskStore.afterEdit(this, modifiedFieldNames);
            }
            this.callParent(arguments);
        }
    },


    // Tested in 064_model_binding_to_taskstore.t.js
    // @OVERRIDE
    // TODO remove "isFillingRoot" from task store
    afterCommit: function () {
        this.callParent(arguments);

        // If a node is bound to a store, 'update' will be fired from the task store.
        // Required because of the Ext lazy loading of tree nodes.
        // See http://www.sencha.com/forum/showthread.php?180406-4.1B2-TreeStore-inconsistent-firing-of-update
        if (this.stores.length > 0 || !this.normalized) {
            return;
        }

        var taskStore = this.taskStore || this.getTaskStore(true);

        if (taskStore && !taskStore.isFillingRoot) {
            taskStore.afterCommit(this);
        }
    },


    // Tested in 064_model_binding_to_taskstore.t.js
    // @OVERRIDE
    // TODO remove "isFillingRoot" from task store
    afterReject: function () {

        // If a node is bound to a store, 'update' will be fired from the task store.
        // Required because of the Ext lazy loading of tree nodes.
        // See http://www.sencha.com/forum/showthread.php?180406-4.1B2-TreeStore-inconsistent-firing-of-update
        if (this.stores.length > 0) {
            this.callParent(arguments);
        } else {
            var taskStore = this.getTaskStore(true);

            if (taskStore && !taskStore.isFillingRoot) {
                taskStore.afterReject(this);
            }
            this.callParent(arguments);
        }
    },

    /**
     * Returns the duration unit of the task.
     * @return {String} the duration unit
     */
    getDurationUnit: function () {
        return this.get(this.durationUnitField) || 'd';
    },

    /**
     * @method setDurationUnit
     *
     * Updates the duration unit of the task.
     *
     * @param {String} unit New duration unit
     * @return {String} the duration unit
     */


    /**
     * Returns the effort unit of the task.
     * @return {String} the effort unit
     */
    getEffortUnit: function () {
        return this.get(this.effortUnitField) || 'h';
    },

    /**
     * @method setEffortUnit
     *
     * Updates the effort unit of the task.
     *
     * @param {String} unit New effort unit
     * @return {String} the effort unit
     */



    /**
     * @method setPercentDone
     *
     * Sets the percent complete value of the task
     *
     * @param {Number} value The new value
     */

    /**
     * @method getPercentDone
     *
     * Gets the percent complete value of the task
     * @return {Number} The percent complete value of the task
     */

    /**
     * @method getCls
     *
     * Returns the name of field holding the CSS class for each rendered task element
     *
     * @return {String} cls The cls field
     */

    /**
     * @method getBaselineStartDate
     *
     * Returns the baseline start date of this task
     *
     * @return {Date} The baseline start date
     */

    /**
     * @method setBaselineStartDate
     *
     * Sets the baseline start date of this task
     *
     * @param {Date} date
     */

    /**
     * @method getBaselineEndDate
     *
     * Returns the baseline end date of this task
     *
     * @return {Date} The baseline end date
     */

    /**
     * @method setBaselineEndDate
     *
     * Sets the baseline end date of this task
     *
     * @param {Date} date
     */

    /**
     * @method setBaselinePercentDone
     *
     * Sets the baseline percent complete value
     *
     * @param {Int} value The new value
     */

    /**
     * Gets the baseline percent complete value
     * @return {Int} The percent done level of the task
     */
    getBaselinePercentDone : function() {
        return this.get(this.baselinePercentDoneField) || 0;
    },

    /**
     * Returns true if the Task can be persisted (e.g. task and resource are not 'phantoms')
     *
     * @return {Boolean} true if this model can be persisted to server.
     */
    isPersistable : function() {
        var parent = this.parentNode;

        return !parent.phantom;
    },

    /**
     * Returns an array of Gnt.model.Resource instances assigned to this Task.
     *
     * @return {[Gnt.model.Resource]} resources
     */
    getResources : function () {
        var assignmentStore     = this.getAssignmentStore(),
            id                  = this.getInternalId();

        var resources = [];

        if (assignmentStore) {
            assignmentStore.each(function (assignment) {
                if (assignment.getTaskId() == id) {
                    resources.push(assignment.getResource());
                }
            });
        }

        return resources;
    },


    /**
     * Returns an array of Gnt.model.Assignment instances associated with this Task.
     *
     * @return {[Gnt.model.Assignment]} resources
     */
    getAssignments : function () {
        var assignmentStore = this.getAssignmentStore(),
            id              = this.getInternalId();

        var assignments     = [];

        if (assignmentStore) {
            assignmentStore.each(function (assignment) {
                if (assignment.getTaskId() == id) {
                    assignments.push(assignment);
                }
            });
        }

        return assignments;
    },


    /**
     * Returns true if this task has any assignments. **Note**, that this function returns `true` even if all assignment records are invalid
     * (ie pointing to non-existing resource in the resource store).
     *
     * @return {Boolean}
     */
    hasAssignments : function () {
        var assignmentStore = this.getAssignmentStore(),
            id              = this.getInternalId();

        var hasAssignments  = false;

        if (assignmentStore) {
            assignmentStore.each(function (assignment) {
                if (assignment.getTaskId() == id) {

                    hasAssignments = true;
                    return false;
                }
            });
        }

        return hasAssignments;
    },


    /**
     * Returns true if this task has any assignments with valid resources. Returns `true` only if at least one assignment record is valid -
     * pointing to existed resource record in the resource store.
     *
     * @return {Boolean}
     */
    hasResources : function () {
        var assignmentStore = this.getAssignmentStore(),
            id              = this.getInternalId();

        var hasResources    = false;

        if (assignmentStore) {
            assignmentStore.each(function (assignment) {
                if (assignment.getTaskId() == id && assignment.getResource()) {
                    hasResources    = true;
                    return false;
                }
            });
        }

        return hasResources;
    },




    /**
     * If given resource is assigned to this task, returns a Gnt.model.Assignment record.
     * Otherwise returns `null`
     *
     * @param {Gnt.model.Resource/Number} resourceOrId The instance of {@link Gnt.model.Resource} or resource id
     *
     * @return {Gnt.model.Assignment} resources
     */
    getAssignmentFor : function (resource) {
        var assignmentStore = this.getAssignmentStore(),
            id              = this.getInternalId(),
            resourceId      = resource instanceof Gnt.model.Resource ? resource.getInternalId() : resource;

        var found;

        if (assignmentStore) {
            assignmentStore.each(function (assignment) {
                if (assignment.getTaskId() == id && assignment.getResourceId() == resourceId) {
                    found = assignment;

                    return false;
                }
            });
        }

        return found || null;
    },

    /**
     * @method isAssignedTo
     * Returns true if the task is assigned to a certain resource.
     *
     * @param {Sch.model.Resource} resource The resource to query for
     * @return {Boolean}
     */
    isAssignedTo: function (resource) {
        return !!this.getAssignmentFor(resource);
    },


    unassign : function () {
        return this.unAssign.apply(this, arguments);
    },


    /**
     * Un-assign a resource from this task
     *
     * @param {Gnt.model.Resource/Number} resource An instance of the {@link Gnt.model.Resource} class or a resource id
     */
    unAssign : function (resource) {
        var assignmentStore = this.getAssignmentStore();
        var taskId          = this.getInternalId();
        var resourceId      = resource instanceof Gnt.model.Resource ? resource.getInternalId() : resource;

        var index           = assignmentStore.findBy(function(as) {
            return as.getResourceId() == resourceId &&
                as.getTaskId() == taskId;
        });

        if (index >= 0) {
            assignmentStore.removeAt(index);
        }
    },


    /**
     * Assigns this task to the passed Resource or Resource Id.
     *
     * @param {Gnt.model.Resource/Mixed} resourceOrId The instance of a {@link Gnt.model.Resource resource} or its id.
     * @param {Number} units The integer value for the {@link #unitsField Units field} of the assignment record.
     */
    assign : function (resource, units) {
        var taskStore       = this.getTaskStore(),
            id              = this.getInternalId(),
            assignmentStore = taskStore.getAssignmentStore(),
            resourceStore   = taskStore.getResourceStore();

        var resourceId      = resource instanceof Gnt.model.Resource ? resource.getInternalId() : resource;

        assignmentStore.each(function (assignment) {

            if (assignment.getTaskId() == id && assignment.getResourceId() == resourceId) {
                throw "Resource can't be assigned twice to the same task";
            }
        });

        // add resource to the resource store if its not there (probably a phantom resource record)
        if (resource instanceof Gnt.model.Resource && resourceStore.indexOf(resource) == -1) {
            resourceStore.add(resource);
        }

        var newAssignment   = new Gnt.model.Assignment({
            TaskId        : id,
            ResourceId    : resourceId,
            Units         : units
        });

        assignmentStore.add(newAssignment);

        return newAssignment;
    },


    // side-effects free method - suitable for use in "normalization" stage
    // calculates the effort based on the assignments information
    calculateEffort : function (startDate, endDate, unit) {
        // effort calculation requires both dates
        if (!startDate || !endDate) return 0;

        var totalEffort     = 0;

        this.forEachAvailabilityIntervalWithResources({ startDate : startDate, endDate : endDate }, function (intervalStartDate, intervalEndDate, currentAssignments) {
            var totalUnits          = 0;

            for (var i in currentAssignments) totalUnits += currentAssignments[ i ].units;

            totalEffort             += (intervalEndDate - intervalStartDate) * totalUnits / 100;
        });

        return this.getProjectCalendar().convertMSDurationToUnit(totalEffort, unit || this.getEffortUnit());
    },


    updateAssignments : function () {
        var totalDurationByResource     = {};

        var startDate                   = this.getStartDate();
        var endDate                     = this.getEndDate();

        // do nothing if task is not scheduled
        if (!startDate || !endDate) return;

        var totalTime                   = 0;

        this.forEachAvailabilityIntervalWithResources({ startDate : startDate, endDate : endDate }, function (intervalStartDate, intervalEndDate, currentAssignments) {

            for (var resourceId in currentAssignments) {
                totalTime               += intervalEndDate - intervalStartDate;
            }
        });

        // no available resources?
        if (!totalTime) {
            return;
        }

        var effortInMS      = this.getEffort(Sch.util.Date.MILLI);

        Ext.Array.each(this.getAssignments(), function (assignment) {
            assignment.setUnits(effortInMS / totalTime * 100);
        });
    },


    updateEffortBasedOnDuration : function () {
        this.setEffort(this.calculateEffort(this.getStartDate(), this.getEndDate()));
    },


    updateDurationBasedOnEffort : function () {
        this.setEndDate(this.calculateEffortDrivenEndDate(this.getStartDate(), this.getEffort(), this.getEffortUnit()), false);
    },


    onPotentialEffortChange : function () {
        switch (this.getSchedulingMode()) {
            case 'FixedDuration'        : this.updateEffortBasedOnDuration(); break;
            case 'DynamicAssignment'    : this.updateAssignments(); break;
        }
    },


    onAssignmentMutation : function () {
        switch (this.getSchedulingMode()) {
            case 'FixedDuration'    : this.updateEffortBasedOnDuration(); break;
            case 'EffortDriven'     : this.updateDurationBasedOnEffort(); break;
        }
    },


    onAssignmentStructureMutation : function () {
        switch (this.getSchedulingMode()) {
            case 'FixedDuration' : this.updateEffortBasedOnDuration(); break;

            case 'EffortDriven' :
                // previously we used just this.updateDurationBasedOnEffort() call here to update EndDate & Duration
                // but we also have to update startDate because duration can change
                // and for milestones we should set startDate to the end of last working period
                var endDate = this.calculateEffortDrivenEndDate(this.getStartDate(), this.getEffort(), this.getEffortUnit());

                this.setStartEndDate(this.getStartDate(), endDate, this.getTaskStore().skipWeekendsDuringDragDrop);
                break;

            case 'DynamicAssignment' : this.updateAssignments(); break;
        }
    },


    adjustToCalendar : function() {
        if (this.get('leaf') && !this.isManuallyScheduled()) {
            this.setStartDate(this.getStartDate(), true, this.getTaskStore().skipWeekendsDuringDragDrop);

            var taskStore       = this.getTaskStore(true);

            // if we respect dependencies
            if (taskStore && taskStore.cascadeChanges) {
                var errors  = this.getViolatedConstraints();
                if (errors) {
                    for (var i = 0, l = errors.length, error; i < l; i++) {
                        error   = errors[i];
                        // for all errors except very first one we don't specify parameter
                        // to force resolveViolatedConstraints() method to re-check constrain errors for corresponding task
                        // since errors except very first can be already fixed after first error resolving
                        this.resolveViolatedConstraints(!i ? error : null);
                    }
                }
            }
        }
    },


    /**
     * Checks if the given task field is editable. You can subclass this class and override this method to provide your own logic.
     *
     * It takes the scheduling mode of the task into account. For example for "FixedDuration" mode, the "Effort"
     * field is calculated and should not be updated by user directly.
     *
     * @param {String} fieldName Name of the field
     * @return {Boolean} Boolean value, indicating whether the given field is editable
     */
    isEditable : function (fieldName) {
        if (!this.isLeaf()) {
            if (fieldName === this.effortField && this.autoCalculateEffortForParentTask) return false;
            if (fieldName === this.percentDoneField && this.autoCalculatePercentDoneForParentTask) return false;
        }

        if ((fieldName === this.durationField || fieldName === this.endDateField) && this.getSchedulingMode() === 'EffortDriven') {
            return false;
        }

        if (fieldName === this.effortField && this.getSchedulingMode() === 'FixedDuration') {
            return false;
        }

        return true;
    },


    /**
     * @method isDraggable
     *
     * Returns true if event can be drag and dropped
     * @return {Mixed} The draggable state for the event.
     */
    isDraggable: function () {
        return this.getDraggable();
    },

    /**
     * @method setDraggable
     *
     * Sets the new draggable state for the event
     * @param {Boolean} draggable true if this event should be draggable
     */

    /**
     * @method isResizable
     *
     * Returns true if event can be resized, but can additionally return 'start' or 'end' indicating how this event can be resized.
     * @return {Mixed} The resource Id
     */
    isResizable: function () {
        return this.getResizable();
    },

    /**
     * @method getWBSCode
     *
     * Returns WBS code of task.
     * @return {String} The WBS code string
     */
    getWBSCode: function () {
        var indexes = [],
            task    = this;

        while (!task.data.root) {
            indexes.push(task.data.index + 1);
            task = task.parentNode;
        }

        return indexes.reverse().join('.');
    },


    resetTotalCount : function() {
        var task = this;

        while (task) {
            task.totalCount = null;
            task = task.parentNode;
        }
    },

    /**
     * Returns total count of child nodes and their children.
     *
     * @return {Number} Total count of child nodes
     */
    getTotalCount : function() {
        if (this.totalCount == null) {
            var childNodes  = this.childNodes;
            
            this.totalCount = childNodes.length;

            for (var i = 0, l = childNodes.length; i < l; i++) {
                this.totalCount += childNodes[i].getTotalCount();
            }
        }

        return this.totalCount;
    },

    /**
     * Returns count of all predecessors nodes (including their children).
     *
     * @return {Number}
     */
    getPredecessorsCount : function() {
        var task = this.previousSibling,
            count = this.data.index;

        while (task) {
            count += task.getTotalCount();
            task = task.previousSibling;
        }

        return count;
    },


    /**
     * @method getSequenceNumber
     *
     * Returns the sequential number of the task. A sequential number means the ordinal position of the task in the total dataset, regardless
     * of its nesting level and collapse/expand state of any parent tasks. The root node has a sequential number equal to 0.
     * 
     * For example, in the following tree data sample sequential numbers are specified in the comments:

        root : {
            children : [
                {   // 1
                    leaf : true
                },
                {       // 2
                    children : [
                        {   // 3
                            children : [
                                {   // 4
                                    leaf : true
                                },
                                {   // 5
                                    leaf : true
                                }
                            ]
                        }]
                },
                {   // 6
                    leaf : true
                }
            ]
        }

     * If we will collapse some of the parent tasks, sequential number of collapsed tasks won't change.
     * 
     * See also {@link Gnt.data.TaskStore#getBySequenceNumber}.
     *
     * @return {Number} The code
     */
    getSequenceNumber: function () {
        var code   = 0,
            task   = this;

        while (!task.data.root) {
            code += task.getPredecessorsCount() + 1;
            task = task.parentNode;
        }

        return code;
    },

    // generally should be called on root node only
    getBySequenceNumber : function (number) {
        var resultNode = null,
            childNode, totalCount;

        if (number === 0) {
            resultNode = this;
        } else if (number > 0 && number <= this.getTotalCount()) {
            number--;
            
            for (var i = 0, l = this.childNodes.length; i < l; i++) {
                childNode       = this.childNodes[i];
                totalCount      = childNode.getTotalCount();
                
                if (number > totalCount) 
                    number      -= totalCount + 1;
                else {
                    childNode   = this.childNodes[i];
                    resultNode  = childNode.getBySequenceNumber(number);
                    break;
                }
            }
        }

        return resultNode;
    },

    /**
     * @method getDisplayStartDate
     *
     * Returns the formatted start date value to be used in the UI.
     * @param {String} format Date format.
     * @param {Boolean} [adjustMilestones=true] If true, milestones will display one day earlier than the actual raw date.
     * @param {Date} [value=this.getStartDate()] Start date value. If not specified, the Task start date will be used.
     * @return {String} Formatted start date value.
     */
    getDisplayStartDate : function (format, adjustMilestones, value, returnDate, isBaseline) {
        var endDate     = this.getEndDate(),
            startDate   = this.getStartDate();

        // if no value specified then we'll take task start date
        if (arguments.length < 3) {
            value       = this.getStartDate();
            // by default we consider adjustMilestones enabled
            if (arguments.length < 2) adjustMilestones = true;
        }

        if (value && adjustMilestones && this.isMilestone(isBaseline) && value - Ext.Date.clearTime(value, true) === 0 && !Ext.Date.formatContainsHourInfo(format)) {
            value       = Sch.util.Date.add(value, Sch.util.Date.MILLI, -1);
        }

        return returnDate ? value : (value ? Ext.util.Format.date(value, format) : '');
    },

    /**
     * @method getDisplayEndDate
     *
     * Returns the formatted end date value to be used in the UI.
     * **Note** that the end date of tasks in the gantt chart is not inclusive, however, this method will compensate the value.
     * For example, if you have a 1 day task which starts at **2011-07-20T00:00:00** and ends at **2011-07-21T00:00:00** (remember end date is not inclusive),
     * this method will return **2011-07-20** if called with 'Y-m-d'.

            var task = new Gnt.model.Task({
                StartDate : new Date(2011, 6, 20),
                EndDate   : new Date(2011, 6, 21)
            });

            // below code will display "2011/07/20"
            alert(task.getDisplayEndDate("Y/m/d"));

     * @param {String} format Date format (required).
     * @param {Boolean} [adjustMilestones=true] If true, milestones will display one day earlier than the actual raw date.
     * @param {Date} [value=this.getEndDate()] End date value. If not specified, the Task end date will be used.
     * @return {String} Formatted end date value.
     */
    getDisplayEndDate : function (format, adjustMilestones, value, returnDate, isBaseline) {
        if (arguments.length < 3) {
            value       = this.getEndDate();
            if (arguments.length < 2) adjustMilestones = true;
        }

        if (value && (!this.isMilestone(isBaseline) || adjustMilestones) && value - Ext.Date.clearTime(value, true) === 0 && !Ext.Date.formatContainsHourInfo(format)) {
            value       = Sch.util.Date.add(value, Sch.util.Date.MILLI, -1);
        }

        return returnDate ? value : (value ? Ext.util.Format.date(value, format) : '');
    },

    /**
     * @method setResizable
     *
     * Sets the new resizable state for the event. You can specify true/false, or 'start'/'end' to only allow resizing one end of an event.
     * @param {Boolean} resizable true if this event should be resizable
     */

    // http://www.sencha.com/forum/showthread.php?210476-4.1.1-RC1-TreeStore-root-node-issue&p=814781#post814781
    // @OVERRIDE
    getId : function() {
        var id = this.data[this.idProperty];
        return id && id !== 'root' ? id : null;
    }
}, function () {
    // Do this first to be able to override NodeInterface methods
    Ext.data.NodeInterface.decorate(this);

    // http://www.sencha.com/forum/showthread.php?268313-quot-append-quot-quot-remove-quot-events-premature-fire-in-TreeStore
    if (Ext.getVersion('extjs').isGreaterThan('4.2.0.663')) {

        var bubbledEvents = {
            idchanged     : true,
            append        : true,
            remove        : true,
            move          : true,
            insert        : true,
            beforeappend  : true,
            beforeremove  : true,
            beforemove    : true,
            beforeinsert  : true,
            expand        : true,
            collapse      : true,
            beforeexpand  : true,
            beforecollapse: true,
            sort          : true,
            rootchange    : true
        };

        this.override({

            // @OVERRIDE
            // in 4.2.1 order of events firing was broken in fireEventArgs that's why we put old fireEventArgs method
            // reported here: http://www.sencha.com/forum/showthread.php?268313-4.2.1-quot-append-quot-quot-remove-quot-events-premature-fire-in-TreeStore
            fireEventArgs: function(eventName, args) {
                // Use the model prototype directly. Ie71fe62108a7c88379f4043584d9deabb1c0fd5ef we have a BaseModel and then a SubModel,
                // if we access the superclass fireEventArgs it will just refer to the same method
                // and we end up in an infinite loop.
                var fireEventArgs = Ext.data.Model.prototype.fireEventArgs,
                    result, eventSource, rootNode;

                // The event bubbles (all native NodeInterface events do)...
                if (bubbledEvents[eventName]) {
                    for (eventSource = this; result !== false && eventSource; eventSource = (rootNode = eventSource).parentNode) {
                        if (eventSource.hasListeners[eventName]) {
                            result = fireEventArgs.call(eventSource, eventName, args);
                        }
                    }

                    // When we reach the root node, go up to the Ext.data.Tree, and then the Ext.data.TreeStore
                    eventSource = rootNode.rootOf;
                    if (result !== false && eventSource) {
                        if (eventSource.hasListeners[eventName]) {
                            result = eventSource.fireEventArgs.call(eventSource, eventName, args);
                        }
                        eventSource = eventSource.treeStore;
                        if (result !== false && eventSource) {
                            if (eventSource.hasListeners[eventName]) {
                                result = eventSource.fireEventArgs.call(eventSource, eventName, args);
                            }
                        }
                    }
                    return result;
                }
                // Event does not bubble - call superclass fireEventArgs method
                else {
                    return fireEventArgs.apply(this, arguments);
                }
            }
        });
    }

    this.override({

        // @OVERRIDE
        remove : function() {
            var parent      = this.parentNode;
            var taskStore   = this.getTaskStore();

            var value       = this.callParent(arguments);

            // If the parent has no other children, change it to a leaf task
            if (taskStore.recalculateParents) {
                if (parent.convertEmptyParentToLeaf && parent.childNodes.length === 0) {
                    parent.set('leaf', true);
                }
                else if (!parent.isRoot() && parent.childNodes.length > 0) {
                    parent.childNodes[0].recalculateParents();
                }
            }

            return value;
        },

        // @OVERRIDE
        insertBefore : function(node) {
            if (this.phantom) {
                this.data[this.phantomIdField] = node.data[this.phantomParentIdField] = this.internalId;
            }

            this.resetTotalCount();
            return this.callParent(arguments);
        },

        // @OVERRIDE
        appendChild : function(node) {
            if (this.phantom) {
                var nodes = node instanceof Array ? node : [node];

                for (var i = 0; i < nodes.length; i++) {
                    this.data[this.phantomIdField] = nodes[i].data[this.phantomParentIdField] = this.internalId;
                }
            }
            this.resetTotalCount();

            return this.callParent(arguments);
        },

        removeChild : function(node) {
            this.resetTotalCount();
            
            var needToConvertToLeaf     = !this.removeChildIsCalledFromReplaceChild && this.convertEmptyParentToLeaf && this.childNodes.length == 1;
            
            // need to reset the flag early, because the removal operation may cause some side effects (event listeners)
            // flag should be already reset in those listeners
            this.removeChildIsCalledFromReplaceChild    = false;
            
            var value                   = this.callParent(arguments);

            // If the parent has no other children, change it to a leaf task
            if (this.getTaskStore().recalculateParents) {
                if (needToConvertToLeaf) {
                    this.set('leaf', true);
                } else 
                    if (!this.isRoot() && this.childNodes.length > 0) {
                        this.childNodes[0].recalculateParents();
                    }
            }

            return value;
        },
        
        replaceChild : function () {
            // flag will be reset in the `removeChild` override
            this.removeChildIsCalledFromReplaceChild    = true;
            
            this.callParent(arguments);
        },

        removeAll : function() {
            this.resetTotalCount();
            this.callParent(arguments);
        },

        // @OVERRIDE
        createNode : function(node) {
            node = this.callParent(arguments);

            if (!node.normalized) {
                var prevUpdateInfo  = node.updateInfo;

                node.updateInfo = function () {
                    prevUpdateInfo.apply(this, arguments);

                    delete node.updateInfo;

                    // normalization needs to fully set up node, this happens after 1) createNode 2) updateNodeInfo
                    node.normalize();
                };
            }

            return node;
        }
    });
});


/*
 * @class Gnt.util.DurationParser
 * @private
 * Internal class handling the duration parsing.

 Recognizable values for duration unit part are (the trailing `..` symbols means anything will match):

- Milliseconds: `ms` or `mil..`
- Seconds: `s` or `sec..`
- Minutes: `m` or `min..`
- Hours: `h` or `hr` or `hour..`
- Days: `d` or `day..`
- Weeks: `w` or `wk` or `week..`
- Months: `mo..` or `mnt..`
- Quarters: `q` or `quar..` or `qrt..`
- Years: `y` or `yr..` or `year..`

You can change that using the `unitsRegex` configuration option.

 */
Ext.define("Gnt.util.DurationParser", {
    requires        : ["Sch.util.Date"],

    mixins          : ['Gnt.mixin.Localizable'],

    parseNumberFn   : null,
    durationRegex   : null,

    /**
     * @cfg {Boolean} Set to `false` to disable parsing duration values with decimals component
     */
    allowDecimals   : true,

    /**
     * @cfg {Object} unitsRegex An object, with keys that correspond to duration units and values containing regular expressions used to match the duration unit part of the text value.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - unitsRegex : {
                - MILLI       : /^ms$|^mil/i,
                - SECOND      : /^s$|^sec/i,
                - MINUTE      : /^m$|^min/i,
                - HOUR        : /^h$|^hr$|^hour/i,
                - DAY         : /^d$|^day/i,
                - WEEK        : /^w$|^wk|^week/i,
                - MONTH       : /^mo|^mnt/i,
                - QUARTER     : /^q$|^quar|^qrt/i,
                - YEAR        : /^y$|^yr|^year/i
            }
     */

    constructor : function(config) {
        Ext.apply(this, config);

        if (this.unitsRegex) Ext.apply(this.l10n.unitsRegex, this.unitsRegex);

        if (!this.durationRegex) {
            this.durationRegex = this.allowDecimals ? /^\s*([\-+]?\d+(?:[.,]\d+)?)\s*(\w+)?/i : /^\s*([\-+]?\d+)(?![.,])\s*(\w+)?/i;
        }
    },

    parse : function (value) {
        var match               = this.durationRegex.exec(value);

        if (value == null || !match) return null;

        var durationValue       = this.parseNumberFn(match[ 1 ]);

        var durationUnitName    = match[ 2 ];
        var durationUnit;

        if (durationUnitName) {
            Ext.iterate(this.L('unitsRegex'), function (name, regex) {

                if (regex.test(durationUnitName)) {
                    durationUnit    = Sch.util.Date.getUnitByName(name);

                    return false;
                }
            });

            if (!durationUnit) return null;
        }

        return {
            value   : durationValue,
            unit    : durationUnit
        };
    }
});

/*
 * @class Gnt.util.DependencyParser
 * @private
 * Internal class handling the dependency related functionality.
 */
Ext.define("Gnt.util.DependencyParser", {
    requires        : [
        'Gnt.util.DurationParser'
    ],
    
    separator       : /\s*;\s*/,
    parseNumberFn   : null,
    dependencyRegex : /(-?\d+)(SS|SF|FS|FF)?([\+\-].*)?/i,

    types           : ["SS", "SF", "FS", "FF"],

    constructor : function(config) {
        this.durationParser = new Gnt.util.DurationParser(config);
        Ext.apply(this, config);
    },

    /**
     * Returns an object with the following properties (or null if the parsing fails):
            {
                taskId  : 3,    // Int, always present
                type    : "FS", // String, always present
                lag     : 3,    // Int, optional
                lagUnit : 'd'   // String, optional
            }
    **/
    parse : function (value) {
        if (!value) {
            return [];
        }
        
        var parts   = value.split(this.separator);
        var result  = [];
        var depRe   = this.dependencyRegex;

        for (var i = 0; i < parts.length; i++) {
            var part        = parts[ i ];
            
            // allow ";" at the end of the string - will lead to empty element
            if (!part && i == parts.length - 1) continue;
            
            var match       = depRe.exec(part);
            var data        = {};

            if (!match) {
                // Tolerate no sloppy input
                return null;
            }
        
            data.taskId     = parseInt(match[ 1 ], 10);
            
            data.type       = Ext.Array.indexOf(this.types, (match[ 2 ] || "FS").toUpperCase());
            var lagValue    = match[ 3 ];

            if (lagValue) {
                var lag = this.durationParser.parse(lagValue);
            
                if (!lag) {
                    // Tolerate no sloppy input
                    return null;
                }

                data.lag        = lag.value;
                data.lagUnit    = lag.unit || 'd';
            }

            result.push(data);
        }
        
        return result;
    }
});

Ext.define('Gnt.util.Data', {

    requires    : ['Ext.data.Model'],

    singleton   : true,

    // Copies a collection of records performing a copy of each model.
    // Each model in the resulting set keeps a link to its original instance in the originalRecord property.
    // Copied models have their "phantom" property set to false.
    // To apply changes made in the copy to its original data, {@link #applyCloneChanges} can be used.
    //
    // @param {Ext.data.Store/Ext.util.MixedCollection/Ext.data.Model[]} dataSet Collection of records to copy.
    // @param {Function} [fn] The function to be called at each model copying iteration.
    // @param {Ext.data.Model} fn.cloned The newly created copy of the model.
    // @param {Ext.data.Model} fn.original The original model.
    // @param {Mixed} [scope] The scope for fn function call. By default it`s the dataSet.
    // @return {Ext.data.Model[]} Array of cloned records.
    cloneModelSet : function (dataSet, fn, scope) {
        var data = [],
            cloned;

        var process = function (record) {
            // clone the record
            cloned          = record.copy();
            // generate new id
            Ext.data.Model.id(cloned);
            cloned.phantom  = false;
            // keep link to original record
            cloned.originalRecord  = record;

            // if callback is set
            if (fn) {
                if (fn.call(scope || dataSet, cloned, record) === false) return;
            }

            data.push(cloned);
        };

        if (dataSet.each) {
            dataSet.each(process);
        } else {
            Ext.Array.each(dataSet, process);
        }

        return data;
    },

    applyCloneChanges : function (cloneStore, originalStore, fn, scope) {
        var toRemove    = [];

        // suspend automatic sync calls we will call sync() manually in the end of changes applying
        if (originalStore.autoSync) originalStore.suspendAutoSync();

        // first apply deleted records
        var removed = cloneStore.getRemovedRecords();
        for (var i = 0, l = removed.length; i < l; i++) {
            if (removed[i].originalRecord) {
                toRemove.push(removed[i].originalRecord);
            }
        }

        if (toRemove.length) {
            originalStore.remove(toRemove);

            cloneStore.removed.length = 0;
        }

        // let`s get updated & added records
        var modified    = cloneStore.getModifiedRecords(),
            originalRecord, data, toAdd, added;

        // and loop over them
        for (i = 0, l = modified.length; i < l; i++) {

            // original instance of modified record
            originalRecord  = modified[i].originalRecord;
            // new data
            data            = modified[i].getData();

            delete data[modified[i].idProperty];

            // if it`s modification of existing record
            if (originalRecord) {
                // let`s update it
                originalRecord.beginEdit();
                for (var field in data) {
                    originalRecord.set(field, data[field]);
                }

                // if custom callback specified
                if (fn) {
                    fn.call(scope || modified[i], data, modified[i]);
                }

                originalRecord.endEdit();
            // new record creation
            } else {
                // if custom callback specified
                if (fn) {
                    fn.call(scope || modified[i], data, modified[i]);
                }

                added   = originalStore.add(data);

                // let`s bind our record to effective one
                modified[i].originalRecord = added && added[0];
            }

            modified[i].commit(true);
        }

        // enable autoSync back and call sync to persist changes
        if (originalStore.autoSync) {
            originalStore.resumeAutoSync();
            originalStore.sync();
        }

    }

});

// We need to override `onNodeRemove` to not remove a node from nodes hash (only in case of moving node from one parent to another)
// to not cause `getNodeById` calls failure.
// This failure happens when we call `getNodeById` during `appenChild` (or `insertBefore`) call since there
// we first remove node from previous parent and then append it to the new one.
// And when we call `getNodeById` between that two steps we cannot find the node (which actually still belongs to the tree).
// We faced this issue in relateion with recalculating of early/late dates.
//
// http://www.sencha.com/forum/showthread.php?270802-4.2.1-NodeInterface-removeContext-needs-to-be-passed-as-an-arg
Ext.define('Gnt.patches.Tree', {
    override      : 'Ext.data.Tree',

    onNodeRemove: function(parent, node, isMove) {
        if (!isMove) this.unregisterNode(node, true);
    }
});

/**

@class Gnt.data.Calendar
@extends Ext.data.Store
@aside guide gantt_calendars

A class representing a customizable calendar with weekends, holidays and availability information for any day.
Internally, it's just a subclass of the Ext.data.Store class which should be loaded with a collection
of {@link Gnt.model.CalendarDay} instances. Additionally, calendars may have parent-child relations, allowing "child" calendars to "inherit"
all special dates from its "parent" and add its own. See {@link #parent} property for details.

* **Note, that this calendar class is configured for backward compatibility and sets whole 24 hours of every day except weekends,
as available time. If you are looking for a calendar with regular business hours and availability, use {@link Gnt.data.calendar.BusinessTime}**

A calendar can be instantiated like this:

    var calendar        = new Gnt.data.Calendar({
        data    : [
            {
                Date            : new Date(2010, 0, 13),
                Cls             : 'gnt-national-holiday'
            },
            {
                Date            : new Date(2010, 1, 1),
                Cls             : 'gnt-company-holiday'
            },
            {
                Date            : new Date(2010, 0, 16),
                IsWorkingDay    : true
            }
        ]
    });

It can then be provided as a {@link Gnt.data.TaskStore#calendar configuration option} for the {@link Gnt.data.TaskStore}. Note that the calendar should be
loaded prior to loading the taskStore where it's consumed.

Please refer to the {@link Gnt.model.CalendarDay} class to know with what data calendar can be loaded with.

To edit the data in the calendar visually you can use {@link Gnt.widget.calendar.Calendar}

*/
Ext.define('Gnt.data.Calendar', {
    extend      : 'Ext.data.Store',

    requires    : [
        'Ext.Date',
        'Gnt.model.CalendarDay',
        'Sch.model.Range',
        'Sch.util.Date'
    ],

    model       : 'Gnt.model.CalendarDay',

    /**
     * Number of days per month. Will be used when converting the big duration units like month/year to days.
     *
     * @cfg {Number} daysPerMonth
     */
    daysPerMonth        : 30,

    /**
     * Number of days per week. Will be used when converting the duration in weeks to days.
     *
     * @cfg {Number} daysPerWeek
     */
    daysPerWeek         : 7,

    /**
     * Number of hours per day. Will be used when converting the duration in days to hours. 
     * 
     * **Please note**, that this config is used for duration convertion and not anything else. If you need to change
     * the number of working hours in the day, update the {@link #defaultAvailability}
     *
     * @cfg {Number} hoursPerDay
     */
    hoursPerDay         : 24,

    unitsInMs           : null,

    defaultNonWorkingTimeCssCls     : 'gnt-holiday',

    /**
     * @cfg {Boolean} weekendsAreWorkdays Setting this option to `true` will treat *all* days as working. Default value is `false`.
     * This option can also be specified as the {@link Gnt.panel.Gantt#weekendsAreWorkdays config} of the gantt panel.
     */
    weekendsAreWorkdays             : false,

    /**
     * @cfg {Number} weekendFirstDay The index of the first day in weekend, 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on.
     * Default value is 6 - Saturday
     */
    weekendFirstDay                 : 6,

    /**
     * @cfg {Number} weekendSecondDay The index of the second day in weekend, 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on.
     * Default value is 0 - Sunday
     */
    weekendSecondDay                : 0,

    holidaysCache                   : null,
    availabilityIntervalsCache      : null,
    daysIndex                       : null,

    // a "cached" array of WEEKDAY days
    weekAvailability                : null,

    // the "very default" availability array, calculated based on `defaultAvailability` property
    defaultWeekAvailability         : null,

    nonStandardWeeksByStartDate     : null,
    nonStandardWeeksStartDates      : null,

    /**
     * @cfg {String} calendarId The unique id for the calendar. Providing the `calendarId` will register thi calendar in the calendars registry
     * and it can be retrieved later with {@link #getCalendar}. Generally only required if want to use {@link #parent parent-child relations} between the calendars,
     * or assign this calendar to a particular task or resource.
     *
     * Note, that when loading the calendar using ExtJS proxy this field will not be set.
     */
    calendarId                      : null,

    /**
     * @cfg {String/Gnt.data.Calendar} parent The parent calendar. Can be provided as the calendar id or calendar instance itself. If this property is provided
     * or set with {@link #setParent} method, this calendar becomes a "child" of the specified calendar. This means that it will "inherit" all day overrides, week days and
     * week day overrides from its "parent". In the same time, special days, defined in this calendar take priority over the ones from the "parent".
     *
     * You can use this feature if you'd like to create a single "main" calendar for the whole project, and then allow some task or resource to
     * have slightly different calendar (with an additional day off for example). You will not have to re-create all special days in the calendar of such task/resource - just
     * set the "main" calendar as a "parent" for it.
     */
    parent                          : null,

    /**
     * @cfg {Array[String]} defaultAvailability The array of default availability intervals (in the format of the `Availability` field
     * in the {@link Gnt.model.CalendarDay}) for each working weekday (Monday-Friday). Defaults to whole day (00-24) for backward compatibility.
     */
    defaultAvailability             : [ '00:00-24:00' ],

    /**
     * @cfg {String} name The name of this calendar
     */
    name                            : null,


    suspendCacheUpdate              : 0,


    statics: {
        /**
         * Returns the registered calendar with the given id.
         *
         * @param {String} id The calendar id
         * @return {Gnt.data.Calendar}
         */
        getCalendar: function (id) {
            if (id instanceof Gnt.data.Calendar) return id;

            return Ext.data.StoreManager.lookup('GNT_CALENDAR:' + id);
        },


        /**
         * Returns an array of all registered calendars.
         *
         * @return {Array[ Gnt.data.Calendar ]}
         */
        getAllCalendars : function () {
            var result  = [];

            Ext.data.StoreManager.each(function (store) {
                if (store instanceof Gnt.data.Calendar) {
                    result.push(store);
                }
            });

            return result;
        }
    },


    constructor : function (config) {
        config      = config || {};

        var parent      = config.parent;
        delete config.parent;

        var calendarId  = config.calendarId;
        delete config.calendarId;

        this.callParent(arguments);

        this.setParent(parent);
        this.setCalendarId(calendarId);

        this.unitsInMs = {
            MILLI       : 1,
            SECOND      : 1000,
            MINUTE      : 60 * 1000,
            HOUR        : 60 * 60 * 1000,
            DAY         : this.hoursPerDay * 60 * 60 * 1000,
            WEEK        : this.daysPerWeek * this.hoursPerDay * 60 * 60 * 1000,
            MONTH       : this.daysPerMonth * this.hoursPerDay * 60 * 60 * 1000,
            QUARTER     : 3 * this.daysPerMonth * 24 * 60 * 60 * 1000,
            YEAR        : 4 * 3 * this.daysPerMonth * 24 * 60 * 60 * 1000
        };

        this.defaultWeekAvailability        = this.getDefaultWeekAvailability();

        // traditional "on-demand" caching seems to be not so efficient for calendar (in theory)
        // calculating any cached property, like, "weekAvailability" or "nonStandardWeeksStartDates" will require full calendar scan each time
        // so we update ALL cached values on any CRUD operations
        this.on({
            // TODO ignore changes of "Name/Cls" field?
            update      : this.clearCache,
            datachanged : this.clearCache,
            clear       : this.clearCache,

            load        : this.clearCache,
            scope       : this
        });

        this.clearCache();
    },


    /**
     * Returns the {@link #calendarId} of the current calendar
     * @return {}
     */
    getCalendarId : function () {
        return this.calendarId;
    },


    /**
     * Sets the {@link #calendarId} of the current calendar and register it in the calendar registry.
     *
     * @param {String} id
     */
    setCalendarId : function (id) {
        // allow "0" as the calendarId
        if (this.calendarId != null) Ext.data.StoreManager.unregister(this);

        this.calendarId     = id;

        if (id != null) {
            this.storeId    = 'GNT_CALENDAR:' + id;
            Ext.data.StoreManager.register(this);
        } else
            this.storeId    = null;

        var proxy           = this.proxy;

        if (proxy && proxy.extraParams) proxy.extraParams.calendarId    = id;
    },


    getDefaultWeekAvailability : function () {
        var availability        = this.defaultAvailability;
        var weekendFirstDay     = this.weekendFirstDay;
        var weekendSecondDay    = this.weekendSecondDay;

        var res                 = [];

        for (var i = 0; i < 7; i++) {
            res.push(
                this.weekendsAreWorkdays || i != weekendFirstDay && i != weekendSecondDay ?
                    new Gnt.model.CalendarDay({ Type : 'WEEKDAY', Weekday : i, Availability : Ext.Array.clone(availability), IsWorkingDay : true })
                        :
                    new Gnt.model.CalendarDay({ Type : 'WEEKDAY', Weekday : i, Availability : []  })
            );
        }

        return res;
    },


    // will scan through all calendar days in the store and save references to special ones to the properties, for speedup
    clearCache : function () {
        if (this.suspendCacheUpdate > 0) return;

        this.holidaysCache                  = {};
        this.availabilityIntervalsCache     = {};

        var daysIndex                       = this.daysIndex                    = {};

        var weekAvailability                = this.weekAvailability             = [];
        var nonStandardWeeksStartDates      = this.nonStandardWeeksStartDates   = [];
        var nonStandardWeeksByStartDate     = this.nonStandardWeeksByStartDate  = {};

        this.each(function (calendarDay) {
            // backward compat
            var id                  = calendarDay.getId();
            var overrideMatch       = /^(\d)-(\d\d\d\d\/\d\d\/\d\d)-(\d\d\d\d\/\d\d\/\d\d)$/.exec(id);
            var weekDayMatch        = /^WEEKDAY:(\d+)$/.exec(id);

            var type                = calendarDay.getType();

            var weekDay             = calendarDay.getWeekday();

            if (type == 'WEEKDAYOVERRIDE' || overrideMatch) {
                var startDate, endDate;

                if (type == 'WEEKDAYOVERRIDE') {
                    startDate       = calendarDay.getOverrideStartDate();
                    endDate         = calendarDay.getOverrideEndDate();
                }

                // backward compat
                if (overrideMatch) {
                    startDate       = Ext.Date.parse(overrideMatch[ 2 ], 'Y/m/d');
                    endDate         = Ext.Date.parse(overrideMatch[ 3 ], 'Y/m/d');
                    weekDay         = overrideMatch[ 1 ];
                }

                // allow partially defined days - they will not be included in calculations
                if (startDate && endDate && weekDay != null) {
                    var startDateNum            = startDate - 0;

                    if (!nonStandardWeeksByStartDate[ startDateNum ]) {
                        nonStandardWeeksByStartDate[ startDateNum ] = {
                            startDate           : new Date(startDate),
                            endDate             : new Date(endDate),
                            name                : calendarDay.getName(),
                            weekAvailability    : [],
                            // main day representing the week override itself - for example for overrides w/o any re-defined availability
                            mainDay             : null
                        };

                        nonStandardWeeksStartDates.push(startDateNum);
                    }

                    if (weekDay >= 0)
                        nonStandardWeeksByStartDate[ startDateNum ].weekAvailability[ weekDay ] = calendarDay;
                    else
                        nonStandardWeeksByStartDate[ startDateNum ].mainDay = calendarDay;
                }

            } else if (type == 'WEEKDAY' || weekDayMatch) {
                if (weekDayMatch) weekDay = weekDayMatch[ 1 ];

                // again - only fully defined records will be taken into account
                if (weekDay != null) {
                    if (weekDay < 0 || weekDay > 6) { throw new Error("Incorrect week day index"); }

                    weekAvailability[ weekDay ] = calendarDay;
                }
            } else {
                var date            = calendarDay.getDate();

                if (date) daysIndex[ date - 0 ] = calendarDay;
            }
        });

        nonStandardWeeksStartDates.sort();

        this.fireEvent('calendarchange', this);
    },


    /**
     * Returns `true` or `false` depending whether the given time span intersects with one of the defined week day overrides.
     *
     * @param {Date} startDate The start date of the time span
     * @param {Date} endDate The end date of the time span
     *
     * @return {Boolean}
     */
    intersectsWithCurrentWeeks : function (startDate, endDate) {
        var result                          = false;

        this.forEachNonStandardWeek(function (week) {
            var weekStartDate       = week.startDate;
            var weekEndDate         = week.endDate;

            if (weekStartDate <= startDate && startDate < weekEndDate || weekStartDate < endDate && endDate <= weekEndDate) {
                result      = true;

                // stop the iteration
                return false;
            }
        });

        return result;
    },


    /**
     * Adds a week day override ("non-standard" week) to the calendar. As a reminder, week day override consists from up to 7 days,
     * that re-defines the default week days availability only within certain time span.
     *
     * @param {Date} startDate The start date of the time span
     * @param {Date} endDate The end date of the time span
     * @param {Array[ Gnt.model.CalendarDay/Array[ String ] ]} weekAvailability The array indexed from 0 to 7, containing items for week days.
     * Index 0 corresponds to Sunday, 1 to Monday, etc. Some items can be not defined or set to `null`, indicating that override does not
     * change this week day. Item can be - an instance of {@link Gnt.model.CalendarDay} (only `Availability` field needs to be set), or
     * an array of strings, defining the availability (see the description of the `Availability` field in the {@link Gnt.model.CalendarDay}).
     * @param {String} name The name of this week day override
     */
    addNonStandardWeek : function (startDate, endDate, weekAvailability, name) {
        startDate       = Ext.Date.clearTime(new Date(startDate));
        endDate         = Ext.Date.clearTime(new Date(endDate));

        if (this.intersectsWithCurrentWeeks(startDate, endDate)) {
            throw new Error("Can not add intersecting week");
        }

        var DayModel    = this.model;
        var days        = [];

        Ext.Array.each(weekAvailability, function (day, index) {
            if (day instanceof Gnt.model.CalendarDay) {
                day.setType('WEEKDAYOVERRIDE');
                day.setOverrideStartDate(startDate);
                day.setOverrideEndDate(endDate);
                day.setWeekday(index);
                day.setName(name || 'Week override');

                days.push(day);
            } else if (Ext.isArray(day)) {
                var newDay = new DayModel();

                newDay.setType('WEEKDAYOVERRIDE');
                newDay.setOverrideStartDate(startDate);
                newDay.setOverrideEndDate(endDate);
                newDay.setWeekday(index);
                newDay.setName(name || 'Week override');
                newDay.setAvailability(day);

                days.push(newDay);
            }
        });

        var mainDay     = new DayModel();

        mainDay.setType('WEEKDAYOVERRIDE');
        mainDay.setOverrideStartDate(startDate);
        mainDay.setOverrideEndDate(endDate);
        mainDay.setWeekday(-1);
        mainDay.setName(name || 'Week override');

        days.push(mainDay);

        this.add(days);
    },


    /**
     * Returns an object describing a week day override ("non-standard" week), that starts at the given date or `null` if there's no any.
     *
     * @param {Date} startDate The start date of the week day override
     *
     * @return {Object} An object with the following properties
     * @return {Object} return.name A "Name" field of the week days in the override
     * @return {Date} return.startDate An "OverrideStartDate" field of the week days in the override
     * @return {Date} return.endDate An "OverrideEndDate" field of the week days in the override
     * @return {Array[Gnt.model.CalendarDay]} return.weekAvailability An array with the week days, defined by this override. May be filled only partially if
     * week day override does not contain all days.
     * @return {Gnt.model.CalendarDay} return.mainDay A "main" day instance for this override
     */
    getNonStandardWeekByStartDate : function (startDate) {
        return this.nonStandardWeeksByStartDate[ Ext.Date.clearTime(new Date(startDate)) - 0 ] || null;
    },


    /**
     * Returns an object describing a week day override ("non-standard" week), that contains the given date or `null` if there's no any.
     *
     * @param {Date} startDate The date that falls within some of the week day overrides
     *
     * @return {Object} An object describing week day override. See {@link #getNonStandardWeekByStartDate} method for details.
     */
    getNonStandardWeekByDate : function (timeDate) {
        timeDate        = Ext.Date.clearTime(new Date(timeDate)) - 0;

        var nonStandardWeeksStartDates      = this.nonStandardWeeksStartDates;
        var nonStandardWeeksByStartDate     = this.nonStandardWeeksByStartDate;

        for (var i = 0; i < nonStandardWeeksStartDates.length; i++){
            var week                = nonStandardWeeksByStartDate[ nonStandardWeeksStartDates[ i ] ];

            // since `nonStandardWeeksStartDates` are sorted inc and week overrides do not intersect
            // we can shorcut in this case
            if (week.startDate > timeDate) break;

            if (week.startDate <= timeDate && timeDate <= week.endDate) {
                return week;
            }
        }

        return null;
    },


    /**
     * Removes all calendar day instances, that forms a week day override ("non-standard" week) with the given start date.
     *
     * @param {Date} startDate The start date of the week day override
     */
    removeNonStandardWeek : function (startDate) {
        startDate       = Ext.Date.clearTime(new Date(startDate)) - 0;

        var week        = this.getNonStandardWeekByStartDate(startDate);

        if (!week) return;

        this.remove(Ext.Array.clean(week.weekAvailability).concat(week.mainDay));
    },


    /**
     * Iterator for each week day override, defined in this calendar.
     *
     * @param {Function} func The function to call for each override. It will receive a single argument - object, describing the override.
     * See {@link #getNonStandardWeekByStartDate} for details. Returning `false` from the function stops the iterator.
     * @param {Object} scope The scope to execute the `func` with.
     *
     * @return {Boolean} `false` if any of the function calls have returned `false`
     */
    forEachNonStandardWeek : function (func, scope) {
        var me                              = this;
        var nonStandardWeeksStartDates      = this.nonStandardWeeksStartDates;
        var nonStandardWeeksByStartDate     = this.nonStandardWeeksByStartDate;

        for (var i = 0; i < nonStandardWeeksStartDates.length; i++) {
            if (func.call(scope || me, nonStandardWeeksByStartDate[ nonStandardWeeksStartDates[ i ] ]) === false) return false;
        }
    },


    /**
     * Updates the default availability information based on the value provided.
     *
     * @param {Boolean} value true if weekends should be regarded as working time.
     */
    setWeekendsAreWorkDays : function(value) {
        if (value !== this.weekendsAreWorkdays) {
            this.weekendsAreWorkdays = value;

            // Must generate new defaultWeekAvailability
            this.defaultWeekAvailability = this.getDefaultWeekAvailability();

            this.clearCache();
        }
    },

    /**
     * Returns true if weekends are regarded as working time.
     *
     * @return {Boolean} true if weekends should be regarded as working time.
     */
    areWeekendsWorkDays : function() {
        return this.weekendsAreWorkdays;
    },

    /**
     * Returns a corresponding {@link Gnt.model.CalendarDay} instance for the given date. First, this method checks for {@link #getOverrideDay day overrides}
     * (either in this or parent calendars), then for week days (again, in this or parent calendars) and finally fallbacks to the
     * calendar day with the {@link #defaultAvailability} availability.
     *
     * @param {Date} timeDate A date (can contain time portion which will be ignored)
     *
     * @return {Gnt.model.CalendarDay}
     */
    getCalendarDay : function (timeDate) {
        timeDate        = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;

        return this.getOverrideDay(timeDate) || this.getWeekDay(timeDate.getDay(), timeDate) || this.getDefaultCalendarDay(timeDate.getDay());
    },


    /**
     * Returns a day override corresponding to the given date (possibly found in the parent calendars) or `null` if the given date
     * has no overrides in this calendar and all its parents.
     *
     * @param {Date} timeDate The date to check for day overrides for
     * @return {Gnt.model.CalendarDay}
     */
    getOverrideDay : function (timeDate) {
        return this.getOwnCalendarDay(timeDate) || this.parent && this.parent.getOverrideDay(timeDate) || null;
    },


    /**
     * Returns an "own" day override corresponding to the given date. That is - day override defined in the current calendar only.
     *
     * @param {Date} timeDate The date to check for day overrides for
     * @return {Gnt.model.CalendarDay}
     */
    getOwnCalendarDay : function (timeDate) {
        timeDate        = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;

        return this.daysIndex[ Ext.Date.clearTime(timeDate, true) - 0 ];
    },


    /**
     * Returns a "special" week day corresponding to the given date. Under "special" week day we mean a calendar day with the `Type = WEEKDAY` or `WEEKDAYOVERRIDE`.
     * See the {@link Gnt.model.CalendarDay} class for details. If the concrete date is given as 2nd argument, this method will
     * first check for any week overrides passing on it.
     *
     * If not found in current calendar, this method will consult parent. If no "special" week day found neither in this calendar, no parents - it returns `null`.
     *
     * @param {Number} weekDayIndex The index of the week day to retrieve (0-Sunday, 1-Monday, etc)
     * @param {Date} [timeDate] The date for which the week day is being retrieved.
     * @return {Gnt.model.CalendarDay}
     */
    getWeekDay : function (weekDayIndex, timeDate) {
        // if 2nd argument is provided then try to search in non-standard weeks first
        if (timeDate) {
            var week        = this.getNonStandardWeekByDate(timeDate);

            if (week && week.weekAvailability[ weekDayIndex ]) return week.weekAvailability[ weekDayIndex ];
        }

        return this.weekAvailability[ weekDayIndex ] || this.parent && this.parent.getWeekDay(weekDayIndex, timeDate) || null;
    },


    /**
     * Returns a "default" calendar day instance, corresponding to the one, generated from {@link #defaultAvailability}. By default all working days in the week
     * corresponds to the day with {@link #defaultAvailability} set in the `Availability` field and non-working days has empty `Availability`.
     *
     * @param {Number} weekDayIndex The index of the "default" week day to retrieve (0-Sunday, 1-Monday, etc)
     * @return {}
     */
    getDefaultCalendarDay : function (weekDayIndex) {
        if (!this.hasOwnProperty('defaultAvailability') && !this.hasOwnProperty('weekendsAreWorkdays') && this.parent) {
            return this.parent.getDefaultCalendarDay(weekDayIndex);
        }

        return this.defaultWeekAvailability[ weekDayIndex ];
    },


    /**
     * Returns a boolean indicating whether a passed date falls on the weekend or holiday.
     *
     * @param {Date} timeDate A given date (can contain time portion)
     *
     * @return {Boolean}
     */
    isHoliday : function (timeDate) {
        var secondsSinceEpoch       = timeDate - 0;
        var holidaysCache           = this.holidaysCache;

        if (holidaysCache[ secondsSinceEpoch ] != null) {
            return holidaysCache[ secondsSinceEpoch ];
        }

        timeDate        = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;

        var day         = this.getCalendarDay(timeDate);

        if (!day) throw "Can't find day for " + timeDate;

        return holidaysCache[ secondsSinceEpoch ] = !day.getIsWorkingDay();
    },


    /**
     * Returns `true` if given date passes on the weekend and `false` otherwise. Weekend days can be re-defined with the {@link #weekendFirstDay} and {@link #weekendSecondDay} options.
     *
     * @param {Date} timeDate The date to check
     * @return {Boolean}
     */
    isWeekend : function (timeDate) {
        var dayIndex = timeDate.getDay();
        return dayIndex === this.weekendFirstDay || dayIndex === this.weekendSecondDay;
    },


    /**
     * Returns a boolean indicating whether a passed date is a working day.
     *
     * @param {Date} date A given date (can contain time portion which will be ignored)
     *
     * @return {Boolean}
     */
    isWorkingDay : function (date) {
        return !this.isHoliday(date);
    },


    /**
     * Convert the duration given in milliseconds to a given unit. Uses the {@link #daysPerMonth} configuration option.
     *
     * @param {Number} durationInMs Duration in milliseconds
     * @param {String} unit Duration unit to which the duration should be converted
     *
     * @return {Number} converted value
     */
    convertMSDurationToUnit : function (durationInMs, unit) {
        return durationInMs / this.unitsInMs[ Sch.util.Date.getNameOfUnit(unit) ];
    },


    /**
     * Convert the duration given in some unit to milliseconds. Uses the {@link #daysPerMonth} configuration option.
     *
     * @param {Number} durationInMs
     * @param {String} unit
     *
     * @return {Number} converted value
     */
    convertDurationToMs : function (duration, unit) {
        return duration * this.unitsInMs[ Sch.util.Date.getNameOfUnit(unit) ];
    },


    /**
     * Returns an array of ranges for non-working days between `startDate` and `endDate`. For example normally, given a full month,
     * it will return an array from 4 `Sch.model.Range` instances, containing ranges for the weekends. If some holiday lasts for several days
     * and all {@link Gnt.model.CalendarDay} instances have the same `Cls` value then all days will be combined in single range.
     *
     * @param {Date} startDate - A start date of the timeframe to extract the holidays from
     * @param {Date} endDate - An end date of the timeframe to extract the holidays from
     *
     * @return {Array[Sch.model.Range]}
     */
    getHolidaysRanges : function (startDate, endDate, includeWeekends) {
        if (startDate > endDate) {
            Ext.Error.raise("startDate can't be bigger than endDate");
        }

        startDate       = Ext.Date.clearTime(startDate, true);
        endDate         = Ext.Date.clearTime(endDate, true);

        var ranges          = [],
            currentRange,
            date;

        for (date = startDate; date < endDate; date = Sch.util.Date.getNext(date, Sch.util.Date.DAY, 1)) {

            if (this.isHoliday(date) || (this.weekendsAreWorkdays && includeWeekends && this.isWeekend(date))) {
                var day         = this.getCalendarDay(date);
                var cssClass    = day && day.getCls() || this.defaultNonWorkingTimeCssCls;

                var nextDate    = Sch.util.Date.getNext(date, Sch.util.Date.DAY, 1);

                // starts new range
                if (!currentRange) {
                    currentRange    = {
                        StartDate   : date,
                        EndDate     : nextDate,
                        Cls         : cssClass
                    };
                } else {
                    // checks if the range is still the same
                    if (currentRange.Cls == cssClass) {
                        currentRange.EndDate    = nextDate;
                    } else {
                        ranges.push(currentRange);

                        currentRange    = {
                            StartDate   : date,
                            EndDate     : nextDate,
                            Cls         : cssClass
                        };
                    }
                }
            } else {
                if (currentRange) {
                    ranges.push(currentRange);
                    currentRange = null;
                }
            }
        }

        if (currentRange) {
            ranges.push(currentRange);
        }

        var models = [];

        Ext.each(ranges, function (range) {
            models.push(Ext.create("Sch.model.Range", {
                StartDate       : range.StartDate,
                EndDate         : range.EndDate,
                Cls             : range.Cls
            }));
        });

        return models;
    },


    /**
     * This an iterator that is monotonically passes through the all availability intervals (working time intervals) in the given date range.
     *
     * For example if the default availability in this calendar is [ '09:00-13:00', '14:00-18:00' ] and this function is called, like this:
     *
     *      calendar.forEachAvailabilityInterval(
     *           //             midnight  Friday                 midnight Tuesday
     *          { startDate : new Date(2013, 1, 8), endDate : new Date(2013, 1, 12) },
     *          function (startDate, endDate) { ... }
     *      )
     * then the provided function will be called 4 times with the following arguments:
     *
     *      startDate : new Date(2013, 1, 8, 9),    endDate : new Date(2013, 1, 8, 13)
     *      startDate : new Date(2013, 1, 8, 14),   endDate : new Date(2013, 1, 8, 18)
     *      startDate : new Date(2013, 1, 11, 9),   endDate : new Date(2013, 1, 11, 13)
     *      startDate : new Date(2013, 1, 11, 14),  endDate : new Date(2013, 1, 11, 18)
     *
     *
     * @param {Object} options An object with the following properties:
     * @param {Date} options.startDate A start date of the date range. Can be omitted, if `isForward` flag is set to `false`. In this case iterator
     * will not stop until the call to `func` will return `false`.
     * @param {Date} options.endDate An end date of the date range. Can be omitted, if `isForward` flag is set to `true`. In this case iterator
     * will not stop until the call to `func` will return `false`.
     * @param {Boolean} [options.isForward=true] A flag, defining the direction, this iterator advances in. If set to `true` iterations
     * will start from the `startDate` option and will advance in date increasing direction. If set to `false` iterations will start from the `endDate`
     * option and will advance in date decreasing direction.
     * @param {Function} func A function to call for each availability interval, in the given date range. It receives 2 arguments - the start date
     * of the availability interval and the end date.
     * @param {Object} scope A scope to execute the `func` with.
     *
     * @return {Boolean} `false` if any of the calls to `func` has returned `false`
     */
    forEachAvailabilityInterval : function (options, func, scope) {
        scope                       = scope || this;
        var me                      = this;

        var startDate               = options.startDate;
        var endDate                 = options.endDate;

        // isForward by default
        var isForward               = options.isForward !== false;

        if (isForward ? !startDate : !endDate) {
            throw new Error("At least `startDate` or `endDate` is required, depending from the `isForward` option");
        }

        var cursorDate              = new Date(isForward ? startDate : endDate);
        var noBoundary              = isForward ? !endDate : !startDate;

        var DATE                    = Sch.util.Date;
        
        // the Ext.Date.clearTime() method is called a lot during this method (like 200k times for 2k tasks project)
        // sometimes w/o real need for it since we always advance to the next day's boundary
        // this optimization brings it down to ~10k, ~10% speed up in the profiles
        var noNeedToClearTime       = false;

        while (noBoundary || (isForward ? cursorDate < endDate : cursorDate > startDate)) {
            // - 1 for backward direction ensures that we are checking correct day,
            // since the endDate is not inclusive - 02/10/2012 means the end of 02/09/2012
            // for backward direction we always clear time, because intervals are cached by the beginning of the day
            var intervals           = this.getAvailabilityIntervalsFor(cursorDate - (isForward ? 0 : 1), isForward ? noNeedToClearTime : false);

            // the order of processing is different for forward / backward processing
            for (var i = isForward ? 0 : intervals.length - 1; isForward ? i < intervals.length : i >= 0; isForward ? i++ : i--) {
                var interval                = intervals[ i ];
                var intervalStartDate       = interval.startDate;
                var intervalEndDate         = interval.endDate;

                // availability interval is out of [ startDate, endDate )
                if (intervalStartDate >= endDate || intervalEndDate <= startDate) continue;

                var countingFrom            = intervalStartDate < startDate ? startDate : intervalStartDate;
                var countingTill            = intervalEndDate > endDate ? endDate : intervalEndDate;

                if (func.call(scope, countingFrom, countingTill) === false) return false;
            }

            cursorDate              = isForward ? DATE.getStartOfNextDay(cursorDate, false, noNeedToClearTime) : DATE.getEndOfPreviousDay(cursorDate, noNeedToClearTime);
            
            noNeedToClearTime       = true;
        }
    },


    /**
     * Calculate the duration in the given `unit` between 2 dates, taking into account the availability/holidays information (non-working time will be excluded from the duration).
     *
     * @param {Date} startDate The start date
     * @param {Date} endDate The end date
     * @param {String} unit One of the units of the {@link Sch.util.Date} class, for example `Sch.util.Date.DAY`.
     *
     * @return {Number} Working time duration between given dates.
     */
    calculateDuration : function (startDate, endDate, unit) {
        var duration        = 0;

        this.forEachAvailabilityInterval({ startDate : startDate, endDate : endDate }, function (intervalStartDate, intervalEndDate) {
            var dstDiff                 = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();

            duration                    += intervalEndDate - intervalStartDate + dstDiff * 60 * 1000;
        });

        return this.convertMSDurationToUnit(duration, unit);
    },


    /**
     * Calculate the end date for the given start date and duration, taking into account the availability/holidays information (non-working time will not be counted as duration).
     *
     * @param {Date} startDate The start date
     * @param {Number} duration The "pure" duration (w/o any non-working time).
     * @param {String} unit One of the units of the {@link Sch.util.Date} class, for example `Sch.util.Date.DAY`.
     *
     * @return {Date} The end date
     */
    calculateEndDate : function (startDate, duration, unit) {
        // if duration is 0 - return the same date
        if (!duration) {
            return new Date(startDate);
        }

        var DATE = Sch.util.Date,
            endDate;

        duration        = this.convertDurationToMs(duration, unit);

        var startFrom   =
            // milestone case, which we don't want to re-schedule to the next business days
            // milestones should start/end in the same day as its incoming dependency
            duration === 0 && Ext.Date.clearTime(startDate, true) - startDate === 0 ?

            DATE.add(startDate, Sch.util.Date.DAY, -1)
                :
            startDate;

        this.forEachAvailabilityInterval({ startDate : startFrom }, function (intervalStartDate, intervalEndDate) {
            var diff                    = intervalEndDate - intervalStartDate;
            var dstDiff                 = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();

            if (diff >= duration) {
                endDate                 = new Date(intervalStartDate - 0 + duration);

                return false;
            } else {
                duration                -= diff + dstDiff * 60 * 1000;
            }
        });

        return endDate;
    },


    /**
     * Calculate the start date for the given end date and duration, taking into account the availability/holidays information (non-working time will not be counted as duration).
     *
     * @param {Date} endDate The end date
     * @param {Number} duration The "pure" duration (w/o any non-working time).
     * @param {String} unit One of the units of the {@link Sch.util.Date} class, for example `Sch.util.Date.DAY`.
     *
     * @return {Date} The start date
     */
    calculateStartDate : function (endDate, duration, unit) {
        // if duration is 0 - return the same date
        if (!duration) {
            return new Date(endDate);
        }

        var startDate;

        duration        = this.convertDurationToMs(duration, unit);

        this.forEachAvailabilityInterval({ endDate : endDate, isForward : false }, function (intervalStartDate, intervalEndDate) {
            var diff                    = intervalEndDate - intervalStartDate;

            if (diff >= duration) {
                startDate               = new Date(intervalEndDate - duration);

                return false;
            } else
                duration                -= diff;
        });

        return startDate;
    },


    /**
     * This method starts from the given `date` and moves forward/backward in time (depending from the `isForward` flag) skiping the non-working time.
     * It returns the nearest edge of the first working time interval it encounters. If the given `date` falls on the working time, then `date` itself is returned.
     *
     * For example, if this function is called with some Saturday as `date` and `isForward` flag is set, it will return the earliest working hours on following Monday.
     * If `isForward` flag will be set to `false` - it will return the latest working hours on previous Friday.
     *
     * @param {Date} date A date (presumably falling on the non-working time).
     * @param {Boolean} isForward Pass `true` to skip the non-working time in forward direction, `false` - in backward
     *
     * @return {Date} Nearest working date.
     */
    skipNonWorkingTime : function (date, isForward) {
        // reseting the date to the earliest availability interval
        this.forEachAvailabilityInterval(
            isForward ? { startDate : date } : { endDate : date, isForward : false },

            function (intervalStartDate, intervalEndDate) {
                date        = isForward ? intervalStartDate : intervalEndDate;

                return false;
            }
        );

        return new Date(date);
    },


    /**
     * This method starts from the given `date` and moves forward/backward in time (depending from the `duration` argument).
     * It stops as soon as it skips the amount of *working* time defined by the `duration` and `unit` arguments. Skipped non-working time simply will not
     * be counted.
     *
     * **Note** that this method behaves differently from the {@link #skipNonWorkingTime} - that method stops as soon as it encounters the non-working time.
     * This method stops as soon as it accumulate enough skipped working time.
     *
     * @param {Date} date A starting point
     * @param {Number} duration The duration of the working time. To skip working time in backward direction pass a negative value.
     * @param {String} unit One of the units of the {@link Sch.util.Date} class, for example `Sch.util.Date.DAY`.
     *
     * @return {Date}
     */
    skipWorkingTime : function(date, duration, unit) {
        return duration >= 0 ? this.calculateEndDate(date, duration, unit) : this.calculateStartDate(date, -duration, unit);
    },


    /**
     * Returns the availability intervals of the concrete day. Potentially can consult a parent calendar.
     *
     * @param {Date} timeDate
     * @return {Array[Object]} Array of objects, like:

    {
        startDate       : new Date(...),
        endDate         : new Date(...)
    }
     */
    getAvailabilityIntervalsFor : function (timeDate, noNeedToClearTime) {
        timeDate        = noNeedToClearTime ? timeDate - 0 : Ext.Date.clearTime(new Date(timeDate)) - 0;

        if (this.availabilityIntervalsCache[ timeDate ]) return this.availabilityIntervalsCache[ timeDate ];

        return this.availabilityIntervalsCache[ timeDate ] = this.getCalendarDay(timeDate).getAvailabilityIntervalsFor(timeDate);
    },


    getByInternalId : function (internalId) {
        return this.data.map[ internalId ];
    },


    getParentableCalendars : function() {
        var me          = this,
            result      = [],
            calendars   = Gnt.data.Calendar.getAllCalendars();

        var isChildOfThis = function (calendar) {
            if (!calendar.parent) return false;

            if (calendar.parent == me) return true;

            return isChildOfThis(calendar.parent);
        };

        Ext.Array.each(calendars, function(calendar){
            if (calendar === me) return;

            if (!isChildOfThis(calendar)) result.push({ Id : calendar.calendarId, Name : calendar.name || calendar.calendarId });
        });

        return result;
    },


    /**
     * Sets the {@link #parent} for this calendar. Pass `null` to remove the parent.
     *
     * @param {Null/String/Gnt.data.Calendar} parentOrId String with {@link #calendarId} value or calendar instance itself.
     */
    setParent : function (parentOrId) {
        var parent          = Gnt.data.Calendar.getCalendar(parentOrId);

        if (parentOrId && !parent) throw new Error("Invalid parent specified for the calendar");

        if (this.parent != parent) {
            var proxy       = this.proxy;

            var listeners   = {
                calendarchange          : this.clearCache,
                scope                   : this
            };

            var oldParent   = this.parent;

            if (oldParent) oldParent.un(listeners);

            this.parent     = parent;

            if (parent) parent.on(listeners);

            if (proxy && proxy.extraParams) proxy.extraParams.parentId  = parent ? parent.calendarId : null;

            this.clearCache();

            /**
             * @event parentchange
             *
             * @param {Gnt.data.Calendar} calendar The calendar which parent has changed
             * @param {Gnt.data.Calendar} newParent The new parent of this calendar (can be `null` if parent is being removed)
             * @param {Gnt.data.Calendar} oldParent The old parent of this calendar (can be `null` if there were no parent)
             */
            this.fireEvent('parentchange', this, parent, oldParent);
        }
    },

    isAvailabilityIntersected : function  (withCalendar, startDate, endDate) {
        var ownWeekDay, ownAvailability,
            testWeekDay, testAvailability;

        // first let's try to find overlapping of weeks (check daily intervals)
        // loop over week days
        for (var i = 0; i < 7; i++) {
            ownWeekDay      = this.getWeekDay(i) || this.getDefaultCalendarDay(i);
            testWeekDay     = withCalendar.getWeekDay(i) || withCalendar.getDefaultCalendarDay(i);

            if (!ownWeekDay || !testWeekDay) continue;

            // get daily intervals
            ownAvailability     = ownWeekDay.getAvailability();
            testAvailability    = testWeekDay.getAvailability();

            // loop over intervals to find overlapping
            for (var j = 0, l = ownAvailability.length; j < l; j++) {
                for (var k = 0, ll = testAvailability.length; k < ll; k++) {
                    if (testAvailability[k].startTime < ownAvailability[j].endTime && testAvailability[k].endTime > ownAvailability[j].startTime) {
                        return true;
                    }
                }
            }
        }

        var result = false;

        this.forEachNonStandardWeek(function (week) {
            if (week.startDate >= endDate) return false;

            if (startDate < week.endDate) {
                result      = true;
                // stop the iteration
                return false;
            }
        });

        return result;
    }

});

/**

@class Gnt.data.calendar.BusinessTime
@extends Gnt.data.Calendar

A class representing a customizable calendar with weekends, holidays and availability information for any day. 

This class is basically a subclass of {@link Gnt.data.Calendar}, configured for normal business hours availability, 
you can fine-tune its setting if needed. Default availability hours for every day are 08:00-12:00 and 13:00-17:00 
(can be configured with {@link #defaultAvailability} property.

See also {@link Gnt.data.Calendar} for additional information.

*/
Ext.define('Gnt.data.calendar.BusinessTime', {
    extend              : 'Gnt.data.Calendar',
    
    /**
     * Number of days per month. Will be used when converting the big duration units like month/year to days.
     * 
     * @cfg {Number} daysPerMonth
     */
    daysPerMonth        : 20,

    /**
     * Number of days per week. Will be used when converting the duration in weeks to days.
     * 
     * @cfg {Number} daysPerWeek
     */
    daysPerWeek         : 5,

    /**
     * Number of hours per day. Will be used when converting the duration in days to hours.
     * 
     * **Please note**, that this config is used for duration convertion and not anything else. If you need to change
     * the number of working hours in the day, update the {@link #defaultAvailability}
     * 
     * @cfg {Number} hoursPerDay
     */
    hoursPerDay         : 8,
    
    /**
     * @cfg {Array[String]} defaultAvailability The array of default availability intervals (in the format of the `Availability` field
     * in the {@link Gnt.model.CalendarDay}) for each working weekday (Monday-Friday). 
     */
    defaultAvailability : [ '08:00-12:00', '13:00-17:00' ]
});
/**

@class Gnt.data.DependencyStore
@extends Ext.data.Store

A class representing the collection of the dependencies between the tasks in the {@link Gnt.data.TaskStore}.

Contains the collection of {@link Gnt.model.Dependency} records.

*/
Ext.define('Gnt.data.DependencyStore', {
    extend          : 'Ext.data.Store',

    model           : 'Gnt.model.Dependency',

    /**
     * @property {Gnt.data.TaskStore} taskStore The task store to which this dependency store is associated.
     * Usually is configured automatically, by the task store itself.
     */
    taskStore       : null,

    methodsCache    : null,

    /**
     * @cfg {Boolean} strictDependencyValidation A boolean flag indicating whether a strict validation of dependencies should be applied.
     * This mode will detect indirect cycles between parent-child relationships.
     * For example, the following cases will be considered as invalid (here `P1`, `P2`, `P3` are parent tasks and `T1`, `T2`, `T3` - their children respectively):

                P1 =========
                T1 ++++++          P2 =========
                                   T2    +++++        P3 ===============
                                                      T3 +++++++++++++++

     * - if we have dependency `P1---->P2` then dependency `T2---->P1` will be invalid
     * - if we have dependency `P1---->T2` then dependency `T2---->T1` will be invalid
     * - if we have dependency `P1---->P2` then dependency `T2---->T1` will be invalid
     * - if we have dependencies `P1---->P2---->P3` then dependency `T3---->T1` will be invalid
     * - if we have dependency `P1---->T2` then dependency `P2---->T1` will be invalid
     * - if we have dependencies `P1---->T2` `P2---->T3` then dependency `P3---->T1` will be invalid
     * - if we have dependencies `T1---->P2` `T2---->P3` then dependency `T3---->P1` will be invalid
     */
    strictDependencyValidation  : false,

    ignoreInitial               : true,

    constructor : function() {
        this.mixins.observable.constructor.apply(this, arguments);

        // subscribing to the CRUD before parent constructor - in theory, that should guarantee, that our listeners
        // will be called first (before any other listeners, that could be provided in the "listeners" config)
        // and state in other listeners will be correct
        this.init();

        this.callParent(arguments);

        this.ignoreInitial      = false;
    },

    init : function() {
        this.methodsCache   = {};

        this.on({
            add         : this.onDependencyAdd,
            update      : this.onDependecyUpdate,
            // seems we can't use "bulkremove" event, because one can listen to `remove` event on the task store
            // and expect correct state in it
            remove      : this.onDependecyRemove,
            clear       : this.onDependencyStoreClear,
            beforesync  : this.onBeforeSyncOperation,

            scope       : this
        });
    },


    onDependencyAdd : function (me, dependencies) {
        // need to ignore the initial "add" events for data provided in the config
        if (this.ignoreInitial) return;

        for (var i = 0; i < dependencies.length; i++) {
            var dependency  = dependencies[ i ];

            var from        = dependency.getSourceTask(),
                to          = dependency.getTargetTask();

            if (from && to) {
                from.successors.push(dependency);
                to.predecessors.push(dependency);
            }
        }

        me.resetMethodsCache();
    },


    onDependecyRemove : function (me, dependency) {
        var taskStore       = this.getTaskStore();

        // dependecies are already removed from the dependecies store and has no reference to it
        // so `getTaskStore` on the dependency instance won't work, need to provide `taskStore`
        var from        = dependency.getSourceTask(taskStore),
            to          = dependency.getTargetTask(taskStore);

        if (from) Ext.Array.remove(from.successors, dependency);
        if (to) Ext.Array.remove(to.predecessors, dependency);

        me.resetMethodsCache();
    },


    onDependecyUpdate : function (me, dependency, operation) {
        if (operation != Ext.data.Model.COMMIT) {
            var taskStore       = this.getTaskStore();
            var previous        = dependency.previous;

            var newFromTask     = dependency.getSourceTask();
            var newToTask       = dependency.getTargetTask();

            if (dependency.fromField in previous) {
                var oldFromTask = taskStore.getById(previous[ dependency.fromField ]);

                oldFromTask && Ext.Array.remove(oldFromTask.successors, dependency);

                newFromTask && newFromTask.successors.push(dependency);
            }

            if (dependency.toField in previous) {
                var oldToTask   = taskStore.getById(previous[ dependency.toField ]);

                // remove from old array
                oldToTask && Ext.Array.remove(oldToTask.predecessors, dependency);

                newToTask && newToTask.predecessors.push(dependency);
            }

            this.resetMethodsCache();
        }
    },


    onDependencyStoreClear : function (me) {
        var taskStore       = me.getTaskStore();

        taskStore && taskStore.fillTasksWithDepInfo();
    },


    onBeforeSyncOperation: function (records) {
        if (records.create) {
            for (var r, i = records.create.length - 1; i >= 0; i--) {
                r = records.create[i];

                // Remove records that cannot yet be persisted (involving phantom tasks)
                if (!r.isPersistable()) {
                    Ext.Array.remove(records.create, r);
                }
            }

            // Prevent empty create request
            if (records.create.length === 0) {
                delete records.create;
            }
        }

        return Boolean((records.create  && records.create.length  > 0) ||
                       (records.update  && records.update.length  > 0) ||
                       (records.destroy && records.destroy.length > 0));
    },

    /**
     * Returns all dependencies of for a certain task (both incoming and outgoing)
     *
     * @param {Gnt.model.Task} task
     *
     * @return {Array[Gnt.model.Dependency]}
     */
    getDependenciesForTask : function (task) {
        return task.successors.concat(task.predecessors);
    },

    /**
     * Returns all incoming dependencies of the given task
     *
     * @param {Gnt.model.Task} task
     *
     * @return {Array[Gnt.model.Dependency]}
     */
    getIncomingDependenciesForTask: function (task, doNotClone) {
        return doNotClone ? task.predecessors : task.predecessors.slice();
    },


    /**
     * Returns all outcoming dependencies of a task
     *
     * @param {Gnt.model.Task} task
     *
     * @return {Array[Gnt.model.Dependency]}
     */
    getOutgoingDependenciesForTask: function (task, doNotClone) {
        return doNotClone ? task.successors : task.successors.slice();
    },

    /**
     * Returns `true` if there is a dependency (either "normal" or "transitive") between tasks
     * with `sourceId` and `targetId`
     *
     * @param {String} sourceId
     * @param {String} targetId
     * @param {Gnt.model.Dependency} [ignoreDepRecord] If provided, this dependency will be ignored during transitivity search.
     *
     * @return {Boolean}
     */
    hasTransitiveDependency: function (sourceId, targetId, ignoreDepRecord, visitedTasks) {
        var cacheKey        = sourceId + '-' + targetId;

        if (this.isCachedResultAvailable('hasTransitiveDependency', cacheKey)) {
            return this.methodsCache.hasTransitiveDependency[ cacheKey ];
        }

        visitedTasks        = visitedTasks || {};

        var me              = this;
        var sourceTask      = this.getTaskStore().getById(sourceId);

        // protection from cycles
        if (visitedTasks[ sourceId ]) return false;

        visitedTasks[ sourceId ] = true;

        if (sourceTask) {
            var successors      = sourceTask.successors;

            for (var i = 0, l = successors.length; i < l; i++) {
                var dependency  = successors[ i ],
                    target      = dependency.getTargetId();

                if ((target === targetId && dependency !== ignoreDepRecord) || me.hasTransitiveDependency(target, targetId, ignoreDepRecord, visitedTasks)) {
                    return this.setCachedResult('hasTransitiveDependency', cacheKey, true);
                }
            }
        }

        return this.setCachedResult('hasTransitiveDependency', cacheKey, false);
    },

    
    getCycle : function (context) {
        context             = context || {};

        Ext.applyIf(context, {
            ignoreTasks     : {},
            visitedTasks    : {},
            path            : [],
            task            : this.getAt(0).getSourceTask()
        });

        var visitedTasks    = context.visitedTasks,
            ignoreTasks     = context.ignoreTasks,
            path            = context.path,
            task            = context.task,
            taskId          = task.getInternalId();

        if (ignoreTasks[taskId]) return;

        path.push(task);

        if (visitedTasks[taskId]) return path;

        visitedTasks[taskId]    = true;

        var successors          = task.successors;

        for (var i = 0, l = successors.length; i < l; i++) {
            context.task    = successors[ i ].getTargetTask();

            var cycle       = this.getCycle(context);

            if (cycle) return cycle;
        }

        path.pop();
        delete visitedTasks[taskId];
    },

    
    // TODO improve so it can detect all cycles
    getCycles : function () {
        var me          = this,
            result      = [],
            ignoreTasks = {};

        this.each(function (dep) {
            var path    = me.getCycle({ task : dep.getSourceTask(), ignoreTasks : ignoreTasks });

            if (path) {
                for (var i = 0, l = path.length; i < l; i++) {
                    ignoreTasks[path[i]]    = true;
                }
                result.push(path);
            }
        });

        return result;
    },


    resetMethodsCache : function () {
        this.methodsCache   = {};
    },


    isCachedResultAvailable : function (method, key) {
        return this.methodsCache[method] && this.methodsCache[method].hasOwnProperty[key];
    },


    getCachedResult : function (method, key) {
        return this.methodsCache[ method ][ key ];
    },


    setCachedResult : function (method, key, value) {
        this.methodsCache[method]       = this.methodsCache[method] || {};
        this.methodsCache[method][key]  = value;

        return value;
    },

    //@private
    getGroupTopTasks : function(sourceGroup, targetGroup) {
        var sourceGroupLength    = sourceGroup.length,
            targetGroupLength    = targetGroup.length,
            i                    = sourceGroupLength,
            j                    = targetGroupLength,
            sourceTopParent, targetTopParent;

        do {
            sourceTopParent     = sourceGroup[i];
            targetTopParent     = targetGroup[j];
            i--;
            j--;
        } while (sourceTopParent == targetTopParent && i >= 0 && j>=0);

        return [sourceTopParent, targetTopParent];
    },

    groupsHasTransitiveDependency : function (sourceId, targetId, ignoreDepRecord, context) {
        context = context || {
            targets         : null,
            visitedTasks    : {}
        };

        var root                = this.getTaskStore().getRootNode(),
            result              = false,
            me                  = this,
            source              = this.getTaskById(sourceId),
            target              = this.getTaskById(targetId),
            visitedTasks        = context.visitedTasks,
            targets             = context.targets;

        if (!context.targetGroup) {
            context.targetGroup     = target.getTopParent(true);
        }

        // get groups top elements based on their intersection
        var groups          = this.getGroupTopTasks(source.getTopParent(true), context.targetGroup),
            sourceTopParent = groups[0],
            targetTopParent = groups[1];

        if (sourceTopParent === source && targetTopParent === target) {
            return this.hasTransitiveDependency(sourceId, targetId);
        }

        var cacheKey            = sourceTopParent.getInternalId() + '-' + targetTopParent.getInternalId() + '-' + (ignoreDepRecord && ignoreDepRecord.getInternalId() || '');

        if (this.isCachedResultAvailable('groupsHasTransitiveDependency', cacheKey)) {
            return this.methodsCache.groupsHasTransitiveDependency[cacheKey];
        }

        // if top target element has changed for this source group
        // then we need to regather "targets" hash
        if (targetTopParent !== context.targetTopParent) {
            context.targetTopParent     = targetTopParent;
            targets                     = context.targets = {};
            // collect children Ids into targets hash
            targetTopParent.cascadeBy(function (task) { targets[ task.getInternalId() ] = true; });
        }

        // for each source group task we check if any of its succeeding task is in "targets" hash
        sourceTopParent.cascadeBy(function (task) {
            if (task !== root) {
                var taskId      = task.getInternalId();

                // data cycles protection
                if (visitedTasks[ taskId ]) return false;

                visitedTasks[ taskId ]  = true;

                var successors          = task.successors;
                for (var i = 0, l = successors.length; i < l; i++) {
                    var dependency  = successors[i],
                        toId        = dependency.getTargetId();
                    // if succeeding task in "targets" then we found transitivity
                    // otherwise we go deeper
                    if ((targets[toId] && dependency !== ignoreDepRecord) ? true : me.groupsHasTransitiveDependency(toId, targetId, ignoreDepRecord, context)) {
                        result  = true;
                        return false;
                    }
                }
            }
        });

        // update cache
        return this.setCachedResult('groupsHasTransitiveDependency', cacheKey, result);
    },

    /**
     * Returns `true` if a proposed (about to be created) link between two tasks is valid. If you'd like to check if existing dependency
     * in the dependency store is valid, use {@link Gnt.model.Dependency#isValid} method.
     *
     * If you subclass this class, you can provide your own version of this method.
     * Don't forget to call the parent implementation if you also want the check for cyclic dependencies etc.
     *
     * These scenarios are considered invalid:
     * - a task linking to itself
     * - a dependency between a child and one of its parents
     * - transitive dependencies, e.g. if A -> B, B -> C, then A -> C is not valid
     *
     * @param {Gnt.model.Dependency/Mixed} dependencyOrFromId Either a dependency or the source task id
     * @param {Mixed} toId The target task id
     * @param {Int} type The type of the dependency
     * @return {Boolean}
     */
    isValidDependency : function (dependencyOrFromId, toId, type, calledFromThisDepModel) {
        // `calledFromThisModel` is used when called from `isValid` method of depedency model
        var fromId, fromTask, toTask;

        var modelInput      = dependencyOrFromId instanceof Gnt.model.Dependency;

        // Normalize input
        if (modelInput) {
            fromId          = dependencyOrFromId.getSourceId();
            fromTask        = this.getTaskById(fromId);
            toId            = dependencyOrFromId.getTargetId();
            toTask          = this.getTaskById(toId);

            // if we've been called with dependencies model as 1st arg (modelInput) and that dependency
            // is already in the dep store, this case is identical to called "isValid" method on the dependency record
            if (dependencyOrFromId.stores.length) calledFromThisDepModel = dependencyOrFromId;
        } else {
            fromId          = dependencyOrFromId;
            fromTask        = this.getTaskById(fromId);
            toTask          = this.getTaskById(toId);
        }

        if (!calledFromThisDepModel && modelInput && !dependencyOrFromId.isValid()) {
            return false;
        } else if (!fromId || !toId || fromId == toId) {
            return false;
        }

        // Not allowed to setup a link between a parent and its child
        if (fromTask && toTask && (fromTask.contains(toTask) || toTask.contains(fromTask))) {
            return false;
        }

        // checking the presence of transitivity in forward direction (fromId -> toId) - prevents actual transitivity
        // checking the presence of transitivity in backward direction (toId -> fromId) - prevents cycles
        // in both cases we ignore the depenedncy itself if its "isValid" method has been called
        if (this.hasTransitiveDependency(fromId, toId, calledFromThisDepModel) || this.hasTransitiveDependency(toId, fromId, calledFromThisDepModel)) {
            return false;
        }

        // if strict dependencies validation mode enabled
        if (this.strictDependencyValidation) {
            // let's check if there is an opposite relation between the tasks parent-child stacks
            if (this.groupsHasTransitiveDependency(toTask.getInternalId(), fromTask.getInternalId(), calledFromThisDepModel)) return false;
        }

        return true;
    },

    /**
     * Returns true if there is a direct dependency between the two tasks. The dependency can be forward (from 1st task to 2nd)
     * or backward (from 2nd to 1st).
     *
     * @param {Mixed/Gnt.model.Task} id1 The id of 1st task
     * @param {Mixed/Gnt.model.Task} id2 The id of 2nd task
     *
     * @return {Boolean}
     */
    areTasksLinked : function (fromTaskOrId, toTaskOrId) {
        var from        = fromTaskOrId instanceof Gnt.model.Task ? fromTaskOrId : this.getTaskStore().getById(fromTaskOrId);
        var to          = toTaskOrId instanceof Gnt.model.Task ? toTaskOrId : this.getTaskStore().getById(toTaskOrId);

        if (!from || !to) return false;

        var cacheKey    = from.getInternalId() + '-' + to.getInternalId();

        if (this.isCachedResultAvailable('areTasksLinked', cacheKey)) {
            return this.methodsCache.areTasksLinked[ cacheKey ];
        }

        // these to object will be indexed not by "internalId" actually, but by the direct "id" property of the
        // dependencies record
        var toTaskPredecessorsByInternalId      = {};
        var toTaskSuccessorsByInternalId        = {};

        for (var i = 0, l = to.predecessors.length; i < l; i++) toTaskPredecessorsByInternalId[ to.predecessors[ i ].id ] = true;
        for (i = 0, l = to.successors.length; i < l; i++) toTaskSuccessorsByInternalId[ to.successors[ i ].id ] = true;

        for (i = 0, l = from.successors.length; i < l; i++) {
            if (toTaskPredecessorsByInternalId[ from.successors[ i ].id ]) {
                return this.setCachedResult('areTasksLinked', cacheKey, true);
            }
        }

        for (i = 0, l = from.predecessors.length; i < l; i++) {
            if (toTaskSuccessorsByInternalId[ from.predecessors[ i ].id ]) {
                return this.setCachedResult('areTasksLinked', cacheKey, true);
            }
        }

        return this.setCachedResult('areTasksLinked', cacheKey, false);
    },

    /**
     * Returns true if there is a direct dependency between the two tasks. The dependency can be forward (from 1st task to 2nd)
     * or backward (from 2nd to 1st).
     *
     * @param {String} id1 The id of 1st task
     * @param {String} id2 The id of 2nd task
     *
     * @return {Boolean}
     */
    getByTaskIds: function (id1, id2) {
        var index = this.findBy(function (dependency) {

            var toId    = dependency.getTargetId(),
                fromId  = dependency.getSourceId();

            if ((fromId === id1 && toId === id2) || (fromId === id2 && toId === id1)) {
                return true;
            }
        });

        return this.getAt(index);
    },


    getTaskById : function (id) {
        return this.getTaskStore().getById(id);
    },


    /**
     * Returns the source task of the dependency
     *
     * @param {Gnt.model.Dependency} The dependency
     * @return {Gnt.model.Task} The source task of this dependency
     */
    getSourceTask : function(dependencyOrId) {
        var id = dependencyOrId instanceof Gnt.model.Dependency ? dependencyOrId.getSourceId() : dependencyOrId;
        return this.getTaskStore().getById(id);
    },

    /**
     * Returns the target task of the dependency
     * @param {Gnt.model.Dependency} The dependency
     * @return {Gnt.model.Task} The target task of this dependency
     */
    getTargetTask : function(dependencyOrId) {
        var id = dependencyOrId instanceof Gnt.model.Dependency ? dependencyOrId.getTargetId() : dependencyOrId;
        return this.getTaskStore().getById(id);
    },


    /**
     * Returns the {@link Gnt.data.TaskStore} instance, to which this dependency store is attached.
     * @return {Gnt.data.TaskStore}
     */
    getTaskStore : function() {
        return this.taskStore;
    }
});

/**

@class Gnt.data.TaskStore
@extends Ext.data.TreeStore

A class representing the tree of tasks in the gantt chart. An individual task is represented as an instance of the {@link Gnt.model.Task} class. The store
expects the data loaded to be hierarchical. Each parent node should contain its children in a property called 'children' (please note that this is different from the old 1.x
version where the task store expected a flat data structure)

Parent tasks
------------

By default, when the start or end date of a task gets changed, its parent task(s) will optionally also be updated. Parent tasks always start at it earliest child and ends
at the end date of its latest child. So be prepared to see several updates and possibly several requests to server. You can batch them with the {@link Ext.data.proxy.Proxy#batchActions} configuration
option.

Overall, this behavior can be controlled with the {@link #recalculateParents} configuration option (defaults to true).

Cascading
---------

In the similar way, when the start/end date of the task gets changed, gantt *can* update any dependent tasks, so they will start on the earliest date possible.
This behavior is called "cascading" and is enabled or disabled using the {@link #cascadeChanges} configuration option.

Integration notes
---------

When integrating the Gantt panel with your database, you should persist at least the following properties seen in the class diagram below.

{@img gantt/images/gantt-class-diagram.png}

The bottom 3 properties (`index`, `parentId`, `depth`) of the Task class stem from the {@link Ext.data.NodeInterface} and are required to place the tasks correctly in the tree structure.

If you store your data in a relational database, below is a suggested Task table definition:

{@img gantt/images/gantt-task-table.png}

 ...as well as a Dependency table definition:

{@img gantt/images/gantt-dependency-table.png}

The types for the fields doesn't have to be as seen above, it's merely a simple suggestion. You could for instance use 'string' or a UID as the type of the Id field.

Your server should respond with a hierarchical structure where parent nodes contain an array or their child nodes in a `children` property. If you don't have any local
sorters, defined on the task store, these child nodes should be sorted by their `index` property before the server responds.

When creating new task nodes or updating existing ones, the server should always respond with an array of the created/updated tasks. Each task should contain *all* fields.

*/
Ext.define('Gnt.data.TaskStore', {
    extend      : 'Ext.data.TreeStore',

    requires    : [
        'Gnt.model.Task',
        'Gnt.data.Calendar',
        'Gnt.data.DependencyStore',
        'Gnt.patches.Tree'
    ],

    mixins  : [
        'Sch.data.mixin.FilterableTreeStore',
        'Sch.data.mixin.EventStore'
    ],

    model                   : 'Gnt.model.Task',

    /**
     * @cfg {Gnt.data.Calendar} calendar A {@link Gnt.data.Calendar calendar} instance to use for this task store. **Should be loaded prior the task store**.
     * This option can be also specified as the configuration option for the gantt panel. If not provided, a default calendar, containig the weekends
     * only (no holidays) will be created.
     *
     */
    calendar                : null,

    /**
     * @cfg {Gnt.data.DependencyStore} dependencyStore A `Gnt.data.DependencyStore` instance with dependencies information.
     * This option can be also specified as a configuration option for the gantt panel.
     */
    dependencyStore         : null,


    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore A `Gnt.data.ResourceStore` instance with resources information.
     * This option can be also specified as a configuration option for the gantt panel.
     */
    resourceStore           : null,

    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore A `Gnt.data.AssignmentStore` instance with assignments information.
     * This option can be also specified as a configuration option for the gantt panel.
     */
    assignmentStore         : null,

    /**
     * @cfg {Boolean} weekendsAreWorkdays This option will be translated to the {@link Gnt.data.Calendar#weekendsAreWorkdays corresponding option} of the calendar.
     *
     */
    weekendsAreWorkdays     : false,

    /**
     * @cfg {Boolean} cascadeChanges A boolean flag indicating whether a change in some task should be propagated to its depended tasks. Defaults to `false`.
     * This option can be also specified as the configuration option for the gantt panel.
     */
    cascadeChanges          : false,

    /**
     * @cfg {Boolean} batchSync true to batch sync request for 500ms allowing cascade operations, or any other task change with side effects to be batched into one sync call. Defaults to true.
     */
    batchSync               : true,

    /**
     * @cfg {Boolean} recalculateParents A boolean flag indicating whether a change in some task should update its parent task. Defaults to `true`.
     * This option can be also specified as the configuration option for the gantt panel.
     */
    recalculateParents      : true,

    /**
     * @cfg {Boolean} skipWeekendsDuringDragDrop A boolean flag indicating whether a task should be moved to the next earliest available time if it falls on non-working time,
     * during move/resize/create operations. Defaults to `true`.
     * This option can be also specified as a configuration option for the Gantt panel.
     */
    skipWeekendsDuringDragDrop  : true,

    /**
    * @cfg {Int} cascadeDelay If you usually have deeply nested dependencies, it might be a good idea to add a small delay
    * to allow the modified record to be refreshed in the UI right away and then handle the cascading
    */
    cascadeDelay                : 0,
    
    /**
     * @cfg {Boolean} moveParentAsGroup Set to `true` to move parent task together with its children, as a group. Set to `false`
     * to move only parent task itself. Note, that to enable drag and drop for parent tasks, one need to use the 
     * {@link Gnt.panel.Gantt#allowParentTaskMove} option.
     */
    moveParentAsGroup           : true,
    
    /**
     * @cfg {Boolean} enableDependenciesForParentTasks Set to `true` to process the dependencies from/to parent tasks as any other dependency. 
     * Set to `false` to ignore such dependencies and not cascade changes by them.
     * 
     * Currently, support for dependencies from/to parent task is limited. Only the "start-to-end" and "start-to-start" dependencies 
     * are supported. Also, if some task has incoming dependency from usual task and parent task, sometimes the dependency from
     * parent task can be ignored.
     * 
     * Note, that when enabling this option requires the {@link Gnt.data.DependencyStore#strictDependencyValidation} to be set to `true` as well.
     * Otherwise it will be possible to create indirect cyclic dependnecies, which will cause "infinite recursion" exception.
     */
    enableDependenciesForParentTasks : true,

    /**
    * @cfg {Int} availabilitySearchLimit Maximum number of days to search for calendars common availability.
    * Used in various task calculations requiring to respect working time.
    * In these cases system tries to account working time as intersection of assigned resources calendars and task calendar.
    * This config determine a range intersectin will be searched in.
    * For example in case of task end date calculation system will try to find calendars intersection between task start date
    * and task start date plus `availabilitySearchLimit` days.
    */
    availabilitySearchLimit     : 1825, //5*365

    cascading                   : false,
    isFillingRoot               : false,

    earlyStartDates             : null,
    earlyEndDates               : null,
    lateStartDates              : null,
    lateEndDates                : null,

    lastTotalTimeSpan           : null,
    
    suspendAutoRecalculateParents : 0,
    suspendAutoCascade          : 0,
    
    currentCascadeBatch         : null,
    batchCascadeLevel           : 0,
    
    
    fillTasksWithDepInfoCounter : 0,
    
    /**
     * @cfg {String} dependenciesCalendar A string, defining the calendar, that will be used when calculating the working time, skipped
     * by the dependencies {@link Gnt.model.Dependency#lagField lag}. Default value is `project` meaning main project calendar is used.
     * Other recognized values are: `source` - the calendar of dependency's source task is used, `target` - the calendar of target task. 
     */
    dependenciesCalendar        : 'project',
    
    
    constructor : function (config) {
        this.addEvents(
            /**
             * Will be fired on the call to `filter` method
             * @event filter
             * @param {Gnt.data.TaskStore} self This task store
             * @param {Object} args The arguments passed to `filter` method
             */
            'filter',

            /**
             * Will be fired on the call to `clearFilter` method
             * @event clearfilter
             * @param {Gnt.data.TaskStore} self This task store
             * @param {Object} args The arguments passed to `clearFilter` method
             */
            'clearfilter',

            /**
            * @event beforecascade
            * Fires before a cascade operation is initiated
            * @param {Gnt.data.Store} store The task store
            */
            'beforecascade',

            /**
            * @event cascade
            * Fires when after a cascade operation has completed
            * @param {Gnt.data.Store} store The task store
            * @param {Object} context A context object revealing details of the cascade operation, such as 'nbrAffected' - how many tasks were affected.
            */
            'cascade'
        );

        config      = config || {};

        if (!config.calendar) {
            var calendarConfig  = {};

            if (config.hasOwnProperty('weekendsAreWorkdays')) {
                calendarConfig.weekendsAreWorkdays = config.weekendsAreWorkdays;
            } else {
                 if (this.self.prototype.hasOwnProperty('weekendsAreWorkdays') && this.self != Gnt.data.TaskStore) {
                    calendarConfig.weekendsAreWorkdays = this.weekendsAreWorkdays;
                 }
            }

            config.calendar     = new Gnt.data.Calendar(calendarConfig);
        }

        // If not provided, create default stores (which will be overridden by GanttPanel during instantiation
        var dependencyStore = config.dependencyStore || this.dependencyStore || Ext.create("Gnt.data.DependencyStore");
        delete config.dependencyStore;
        this.setDependencyStore(dependencyStore);

        var resourceStore = config.resourceStore || this.resourceStore || Ext.create("Gnt.data.ResourceStore");
        delete config.resourceStore;
        this.setResourceStore(resourceStore);

        var assignmentStore = config.assignmentStore || this.assignmentStore || Ext.create("Gnt.data.AssignmentStore", { resourceStore : resourceStore });
        delete config.assignmentStore;
        this.setAssignmentStore(assignmentStore);

        var calendar        = config.calendar;

        if (calendar) {
            delete config.calendar;

            this.setCalendar(calendar, true);
        }

        // init cache for early/late dates
        this.resetEarlyDates();
        this.resetLateDates();

        // Call this early manually to be able to add listeners before calling the superclass constructor
        this.mixins.observable.constructor.call(this);

        this.on({
            beforefill      : this.onRootBeforeFill,
            fillcomplete    : this.onRootFillEnd,
            remove          : this.onTaskDeleted,
            write           : this.onTaskStoreWrite,
            sort            : this.onSorted,
            load            : this.onTasksLoaded,
            scope           : this
        });

        this.callParent([ config ]);
        
        this.fillTasksWithDepInfo();

        if (this.autoSync) {
            if (this.batchSync) {
                // Prevent operations with side effects to create lots of individual server requests
                this.sync = Ext.Function.createBuffered(this.sync, 500);
            } else {
                // Need some preprocessing in case store tries to persist a single phantom record with a phantom parent.
                this.on('beforesync', this.onTaskStoreBeforeSync, this);
            }
        }

        this.initTreeFiltering();

        // this is required to activate the "bulkremove" thing
        // the "removeAll" methods checks for "node.store.treeStore" property, probably assuming that all nodes
        // are "joined" the NodeStore first, so it will be in the "store" property
        // however nodes, can be joined TreeStore first (and then NodeStore), so "store" will reference a tree store itself
        this.treeStore      = this;
    },
    
    
    onTasksLoaded : function () {
        this.fillTasksWithDepInfoCounter    = 1;
        
        this.fillTasksWithDepInfo();
    },


    load : function() {
        // Overridden to avoid reacting to the removing of all the records in the store
        this.un("remove", this.onTaskDeleted, this);

        this.callParent(arguments);

        this.on("remove", this.onTaskDeleted, this);
    },

    /**
     * Method for loading an existing dataset into the store.
     * @param {Gnt.model.Task[]/Object[]} data Data to be appended, either a JSON Array of objects or an array of task records.
     * @param {Object} [{addRecords: true, syncStore: false}] append Object storing config options for loading data. If the 'addRecords' option set to true,
     * records will be added to the current data set. Otherwise all previous data will be erased before loading new records. 'syncStore' option
     * is responsible for syncing the store after the operation has finished. If not provided, all modified records will be marked as
     * non-dirty.
     */
    loadData: function (data, append) {
        var me         = this,
            root       = me.getRootNode(),
            addRecords = append ? append.addRecords : false,
            syncStore  = append ? append.syncStore : false;

        //suspend events to prevent multiple proxy calls
        me.suspendAutoSync();
        me.suspendEvents();

        //if append is false, remove all nodes from the store. Check for root added just in case.
        if (!addRecords && root) {
            root.removeAll();
        }

        if (!me.getRootNode()){
            root = me.setRootNode();
        }

        if (data.length){
            var length       = data.length,
                model        = me.model,
                nodesWithoutAddedParents = [],

                //check if node is a record, or simple object with data
                nodeIsRecord = (typeof data[0].get === "function"),

                //flag indicating if index or parent of node has changed
                parentUnchanged,
                node, nodeObj, dataParentId, nodeParentId, dataIndex, nodeIndex, parent, oldParent, skip;

            var nodesIds = me.sortNewNodesByIndex(data);

            for (var i = 0; i < length; i++) {
                node            = me.getById(data[i].getId ? data[i].getId() : data[i].Id);
                skip            = false;
                parentUnchanged = 0;

                //if node is found in the store, update data/parent, else create a new node
                if (node){
                    //get parentId of node and from data
                    dataParentId = nodeIsRecord ? data[i].get('parentId') : data[i].parentId;
                    nodeParentId = node.parentNode.getId();
                    dataIndex    = nodeIsRecord ? data[i].get('index') : data[i].index;
                    nodeIndex    = node.get('index');

                    //if parentId or index changed, append to new parent or at different position
                    if ((( typeof dataParentId !== 'undefined' || dataParentId === null) ? (dataParentId !== nodeParentId) : false) ||
                        (typeof dataIndex !== 'undefined' ? (dataIndex !== nodeIndex) : false)){

                        //if parentId is null, add to rootNode
                        parent    = dataParentId === null ? root : me.getById(dataParentId);
                        oldParent = nodeParentId === null ? root : me.getById(nodeParentId);

                        if (parent && (parent.get('parentId') === node.getId()) &&
                            me.selfChildInRecordsData(node.getId(), dataParentId, nodesIds)){
                            skip = true;
                        }
                    } else {
                        parentUnchanged = 1;
                    }
                } else {
                    node         = nodeIsRecord ? new model(data[i].data) : new model(data[i]);
                    nodeParentId = node.get('parentId');

                    if (nodeParentId){
                        parent = me.getById(nodeParentId);
                    } else if ( nodeParentId === null){
                        parent = root;
                    }
                }

                //set node's values to either record's data or object properties
                if (!skip){
                    if (nodeIsRecord) {
                        node.set(data[i].data);
                    } else {
                        node.set(data[i]);
                    }
                } else {
                    continue;
                }

                //if parent node is already in the tree, add node to parent's children. Otherwise push it to temp array.
                if (parent && !parentUnchanged) {
                    me.moveChildren(node, parent, oldParent, nodesIds);
                    me.fixNodeDates(node);
                } else if(typeof parent === 'undefined' && !parentUnchanged){
                    //we need to store values of index and parentId, because appending nodes on the same
                    //level will overwrite the current values
                    nodeObj = {
                        node: node,
                        index: node.get('index') || 0,
                        parentId: node.get('parentId')
                    };
                    nodesWithoutAddedParents.push(nodeObj);
                } else {
                    me.fixNodeDates(node);
                }

                //if store is not to be synced, mark modified nodes as non-dirty
                if (parent && !syncStore){
                    parent.commit();
                    node.commit();

                    if (oldParent) oldParent.commit();
                }
            }

            var cursor        = 0,
                //force one full round over nodesWithoutAddedParents array
                fullRound     = 0,
                initialLength = nodesWithoutAddedParents.length,
                currentNodeObj,
                parentNode;

            //traverse array of nodes without parents, removing added nodes until it's length is equal to 0
            while (nodesWithoutAddedParents.length){
                if (cursor > nodesWithoutAddedParents.length - 1) {
                    cursor = 0;
                    fullRound = 1;
                }

                currentNodeObj = nodesWithoutAddedParents[cursor];
                parentNode     = currentNodeObj.parentId === null ? root : me.getById(currentNodeObj.parentId);

                if (parentNode) {
                    var notSelfChild = me.nodeIsChild(currentNodeObj.node, parent);

                    if (notSelfChild){
                        parentNode.insertChild(currentNodeObj.index, currentNodeObj.node);
                        me.fixNodeDates(currentNodeObj.node);
                        nodesWithoutAddedParents.splice(cursor, 1);

                        if (!syncStore){
                            parentNode.commit();
                            currentNodeObj.node.commit();
                        }

                        cursor -= 1;
                    }
                }

                cursor += 1;

                //check if it's possible to resolve parent/child dependencies, avoid recursive dependencies.
                if (fullRound && cursor === initialLength-1 && nodesWithoutAddedParents.length === initialLength){
                    throw 'Invalid data, possible infinite loop.';
                }
            }

            //restore expanded flag for nodes
            if (me.nodesToExpand){
                i=0;
                for (var l = me.nodesToExpand.length; i < l; i += 1){
                    node = me.nodesToExpand[i];

                    //we can't expand node without children as it throws errors
                    if (node.childNodes && node.childNodes.length){
                        node.expand();
                    }
                }
                delete me.nodesToExpand;
            }
        }

        //resume store's events and sync with proxy
        me.resumeAutoSync();
        me.resumeEvents();

        this.fireEvent('datachanged');
        this.fireEvent('refresh');

        if (syncStore){
            me.sync();
        }

        //Buffered store not yet supported
        if (this.buffered){
            //this.updateBufferedNodeStore();
        }
    },

    //internal function for checking if child node is in the loaded data and has parentId different then node id
    selfChildInRecordsData : function(parentId, childId, nodesIds){
        var ret = false;

        ret = typeof nodesIds[childId] === 'undefined' ? true : nodesIds[childId] === parentId;

        return ret;
    },

    //sort loaded data by parent id and index
    sortNewNodesByIndex: function(nodesArray){
        var nodesIds = {},
            getParam = function(obj, param){
                if (typeof obj.get === "function"){
                    return obj.get(param);
                }
                return obj[param];
            };

        Ext.Array.each(nodesArray, function(node){
            nodesIds[getParam(node, 'Id')] = getParam(node, 'parentId');
        });

        Ext.Array.sort(nodesArray, function(nodeObjA, nodeObjB){
            var idxA = getParam(nodeObjA, 'index'),
                idxB = getParam(nodeObjB, 'index'),
                pIdA = getParam(nodeObjA, 'parentId'),
                pIdB = getParam(nodeObjB, 'parentId');

            if (typeof idxA !== 'undefined' && typeof idxB !== 'undefined'){

                //sort by parentId's
                if(pIdA === pIdB){
                    return (idxA < idxB) ? -1 : (idxA > idxB) ? 1 : 0;
                } else {
                    if (pIdA === null){
                        return 1;
                    } else if (pIdB === null){
                        return -1;
                    } else {
                        return (pIdA < pIdB) ? -1 : 1;
                    }
                }
            }
            return 0;
        });

        return nodesIds;
    },

    //internal function. Recalculate duration and start/end dates of node parent and node itself if it has children
    fixNodeDates: function (node) {
        var duration = node.calculateDuration(node.getStartDate(), node.getEndDate(), node.getDurationUnit()),
            childNode;

        node.set({
            Duration: duration
        });

        if (this.recalculateParents){
            if (node.childNodes.length){
                childNode = node.getChildAt(0);
                childNode.recalculateParents();
            } else {
                node.recalculateParents();
            }
        }
    },

    //internal function. Compares id of newParent with id's of each child node to prevent adding node as a child of it's child
    nodeIsChild: function (node, newParent) {
        var id = newParent.getId(),
            ret = true;

        //if node has any child nodes
        if (node.childNodes.length){
            node.cascadeBy(function(n){
                if (n.getId() === id){
                    ret = false;
                    return false;
                }
            });
        }

        return ret;
    },

    /* @private
     * Method for moving node with all of it's children to a different parent node.
     * @param {Gnt.model.Task} node Task to be moved.
     * @param {Gnt.model.Task} newParent New parent for the Task.
     * @param {Gnt.model.Task} parent (optional) Current parent of the node. If not defined, it'll be derived from Task's {@link Gnt.model.Task#cfg-parentId parentId}
     * @param {Object} nodesIds (optional) Object with id's of nodes and their parents
     */
    moveChildren: function (node, newParent, parent, nodesIds) {
        //adding expanded node returns an error if the node has no children
        if (node.get('expanded')){
            if (!this.nodesToExpand){
                this.nodesToExpand = [];
            }
            this.nodesToExpand.push(node);
            node.set('expanded', false);
        }

        var copyNode,

            //check if we're not trying to add node as a child node of current child
            notSelfChild = this.nodeIsChild(node, newParent),
            notSelfChildInData = nodesIds ? !this.selfChildInRecordsData(node.getId(), newParent.getId(), nodesIds) : true,
            oldParent = parent || this.getById(node.get('parentId'));

        if (!notSelfChild && notSelfChildInData){
            newParent.set('parentId', null);
            this.moveChildren(newParent, this.getRootNode(), node);
        }

        if (notSelfChild || notSelfChildInData){
            //TODO Find a better way of moving parts of the tree
            //if node has children, do a deep copy of it and remove children from the original
            if(node.childNodes.length){
                copyNode = node.copy(null, true);
                node.removeAll();
            }
            if (oldParent && oldParent.getId() !== newParent.getId()){
                oldParent.removeChild(node);
            }

            typeof node.get('index') !== 'undefined' ? newParent.insertChild(node.get('index'), node) : newParent.appendChild(node);

            if(copyNode){
                //if node had any children, create a shallow copy and append it to the parent again
                copyNode.cascadeBy(function(n){
                    if(n !== copyNode){
                        var cp = n.copy(null);
                        cp.get('index') ? node.insertChild(cp.get('index'), cp) : node.appendChild(cp);
                    }
                });
            }

            this.fixNodeDates(node);
        }
    },

    setRootNode : function () {
        var me      = this;

        this.tree.setRootNode = Ext.Function.createInterceptor(this.tree.setRootNode, function (rootNode) {

            Ext.apply(rootNode, {
                calendar            : me.calendar,
                taskStore           : me,
                dependencyStore     : me.dependencyStore,

                // HACK Prevent tree store from trying to 'create' the root node
                phantom             : false,
                dirty               : false
            });
        });

        var res = this.callParent(arguments);

        delete this.tree.setRootNode;

        return res;
    },


    onRootBeforeFill : function () {
        // this is not quite correct since "beforefill" can be fired when filling
        // any node (it seems)
        // but usually (when not using on-demand tree loading) only the root node will be filled
        // we only need this "isFillingRoot" flag in some overrides in Task model
        this.isFillingRoot  = true;

        this.un({
            append      : this.onNodeUpdated,
            insert      : this.onNodeUpdated,

            update      : this.onTaskUpdated,

            scope       : this
        });
    },


    onRootFillEnd : function (me, root) {
        root.normalizeParent();

        this.on({
            append      : this.onNodeUpdated,
            insert      : this.onNodeUpdated,

            update      : this.onTaskUpdated,

            scope       : this
        });

        this.isFillingRoot  = false;
    },


    /**
     * Returns a dependecy store instance this task store is associated with. See also {@link #setDependencyStore}.
     *
     * @return {Gnt.data.DependencyStore}
     */
    getDependencyStore : function () {
        return this.dependencyStore;
    },


    fillTasksWithDepInfo : function () {
        // no tasks yet - internal tree is not ready
        if (!this.tree || !this.tree.nodeHash) return;
        
        var dependencyStore   = this.getDependencyStore();
        
        // do not iterate for the 1st call - since tasks already has these arrays set in the constructor
        if (this.fillTasksWithDepInfoCounter++ > 0) {
            this.forEachTaskUnOrdered(function (task) {
                task.successors     = [];
                task.predecessors   = [];
            });
        }
        
        if (dependencyStore) {
            dependencyStore.each(function (dependency) {
                var from    = dependency.getSourceTask(),
                    to      = dependency.getTargetTask();

                if (from && to) {
                    from.successors.push(dependency);
                    to.predecessors.push(dependency);
                }
            });
        }
    },


    /**
     * Sets the dependency store for this task store
     *
     * @param {Gnt.data.DependencyStore} dependencyStore
     */
    setDependencyStore : function (dependencyStore) {
        var listeners       = {
            load        : this.fillTasksWithDepInfo,
            datachanged : this.fillTasksWithDepInfo,
            add         : this.onDependencyAddOrUpdate,
            update      : this.onDependencyAddOrUpdate,
            remove      : this.onDependencyDelete,

            scope       : this
        };

        if (this.dependencyStore) {
            this.dependencyStore.un(listeners);
        }

        if (dependencyStore) {
            this.dependencyStore    = Ext.StoreMgr.lookup(dependencyStore);

            if (dependencyStore) {
                dependencyStore.taskStore   = this;
                
                dependencyStore.on(listeners);
                
                this.fillTasksWithDepInfo();
            }
        } else {
            this.dependencyStore    = null;
        }
    },

    /**
     * Sets the resource store for this task store
     *
     * @param {Gnt.data.ResourceStore} resourceStore
     */
    setResourceStore : function (resourceStore) {

        if (resourceStore) {
            this.resourceStore    = Ext.StoreMgr.lookup(resourceStore);

            resourceStore.taskStore = this;

            resourceStore.normalizeResources();
        } else {
            this.resourceStore    = null;
        }
    },


    /**
     * Returns a resource store instance this task store is associated with. See also {@link #setResourceStore}.
     *
     * @return {Gnt.data.ResourceStore}
     */
    getResourceStore : function(){
        return this.resourceStore || null;
    },


    /**
     * Sets the assignment store for this task store
     *
     * @param {Gnt.data.AssignmentStore} assignmentStore
     */
    setAssignmentStore : function (assignmentStore) {
        var listeners       = {
            add         : this.onAssignmentStructureMutation,
            update      : this.onAssignmentMutation,
            remove      : this.onAssignmentStructureMutation,

            scope       : this
        };

        if (this.assignmentStore) {
            this.assignmentStore.un(listeners);
        }

        if (assignmentStore) {
            this.assignmentStore    = Ext.StoreMgr.lookup(assignmentStore);

            assignmentStore.taskStore = this;

            assignmentStore.on(listeners);
        } else {
            this.assignmentStore = null;
        }
    },


    /**
     * Returns an assignment store this task store is associated with. See also {@link #setAssignmentStore}.
     *
     * @return {Gnt.data.AssignmentStore}
     */
    getAssignmentStore : function(){
        return this.assignmentStore || null;
    },


    /**
     * Call this method if you want to adjust the tasks according to the calendar dates.
     */
    renormalizeTasks : function (store, nodes) {
        // reset early/late dates cache
        this.resetEarlyDates();
        this.resetLateDates();

        if (nodes instanceof Gnt.model.Task) {
            nodes.adjustToCalendar();
        } else {
            // Root may not yet exist if task store hasn't been loaded yet (and not used with a tree view)
            var root = this.getRootNode();

            if (root) {
                // Process all
                root.cascadeBy(function(node) {
                    node.adjustToCalendar();
                });
            }
        }
    },

    /**
     * Returns a project calendar instance.
     *
     * @return {Gnt.data.Calendar}
     */
    getCalendar: function(){
        return this.calendar || null;
    },


    /**
     * Sets the calendar for this task store
     *
     * @param {Gnt.data.Calendar} calendar
     */
    setCalendar : function (calendar, doNotChangeTasks) {
        var listeners = {
            calendarchange      : this.renormalizeTasks,

            scope               : this
        };

        if (this.calendar) {
            this.calendar.un(listeners);
        }

        this.calendar           = calendar;

        calendar.on(listeners);

        var root                = this.tree && this.getRootNode();

        if (root) {
            root.calendar       = calendar;
        }

        if (!doNotChangeTasks) this.renormalizeTasks();
    },


    /**
    * Returns the critical path(s) that can affect the end date of the project
    * @return {Array} paths An array of arrays (containing task chains)
    */
    getCriticalPaths: function () {
        // Grab task id's that don't have any "incoming" dependencies
        var root                = this.getRootNode(),
            finalTasks          = [],
            lastTaskEndDate     = new Date(0);

        // find the project end date
        root.cascadeBy(function (task) {
            lastTaskEndDate = Sch.util.Date.max(task.getEndDate(), lastTaskEndDate);
        });

        // find the tasks that ends on that date
        root.cascadeBy(function (task) {
            //                                                              do not include the parent tasks that has children
            //                                                              since their influence on the project end date is determined by its children
            if (lastTaskEndDate - task.getEndDate() === 0 && !task.isRoot() && !(!task.isLeaf() && task.childNodes.length)) {
                finalTasks.push(task);
            }
        });

        var cPaths  = [];

        Ext.each(finalTasks, function (task) {
            cPaths.push(task.getCriticalPaths());
        });

        return cPaths;
    },

    onNodeUpdated : function (parent, node) {
        if (!node.isRoot()) {
            if (this.lastTotalTimeSpan) {
                var span = this.getTotalTimeSpan();

                // if new task dates violates cached total range then let's reset getTotalTimeSpan() cache
                if (node.getEndDate() > span.end || node.getStartDate() < span.start) {
                    this.lastTotalTimeSpan = null;
                }
            }

            // if it's a latest task
            if (node.getEndDate() - this.getProjectEndDate() === 0) {
                this.resetLateDates();
            }

            if (!this.cascading && this.recalculateParents) {
                node.recalculateParents();
            }
        }
    },

    getViolatedConstraints : function (limit) {
        var me          = this,
            count       = 0,
            errors      = [];

        this.dependencyStore.each(function (dependency) {
            var from    = dependency.getSourceTask();
            var to      = dependency.getTargetTask();

            if (from && to) {
                var error = to.getViolatedConstraints();
                if (error) {
                    count++;
                    errors.push(error);
                }

                if (limit && (count >= limit)) return false;
            }
        });

        return errors;
    },

    onTaskUpdated : function (store, task, operation) {
        var prev = task.previous;

        if (this.lastTotalTimeSpan) {
            var span = this.getTotalTimeSpan();

            // if new task dates violates cached total range then let's reset the cache
            if (prev && (prev[ task.endDateField ] - span.end === 0 || prev[ task.startDateField ] - span.start === 0) ||
                (task.getEndDate() > span.end || task.getStartDate() < span.start))
            {
                this.lastTotalTimeSpan = null;
            }
        }

        if (!this.cascading && operation !== Ext.data.Model.COMMIT && prev) {

            var doRecalcParents = task.percentDoneField in prev;

            // Check if we should cascade this update to successors
            // We're only interested in cascading operations that affect the start/end dates
            if (task.startDateField in prev ||
                task.endDateField in prev   ||
                'parentId' in prev          ||
                task.effortField in prev    ||
                prev[ task.schedulingModeField ] === 'Manual')
            {

                var cascadeSourceTask = task;

                if (this.cascadeChanges && !this.suspendAutoCascade) {
                    // if we switched scheduling mode from manual then we'll call cascadeChangesForTask() for some of
                    // task predecessors (if any) to update task itself
                    if (prev[ cascadeSourceTask.schedulingModeField ] == 'Manual') {
                        var deps = cascadeSourceTask.getIncomingDependencies(true);

                        if (deps.length) {
                            cascadeSourceTask = deps[ 0 ].getSourceTask();
                        }
                    }

                    Ext.Function.defer(this.cascadeChangesForTask, this.cascadeDelay, this, [ cascadeSourceTask ]);
                } else {
                    // reset early/late dates cache
                    this.resetEarlyDates();
                    this.resetLateDates();
                }

                doRecalcParents = true;

            // if task scheduling turned to manual
            } else if (prev[ task.schedulingModeField ] && task.isManuallyScheduled()) {
                // reset early/late dates cache
                this.resetEarlyDates();
                this.resetLateDates();
            }

            if (doRecalcParents && this.recalculateParents && !this.suspendAutoRecalculateParents) {
                task.recalculateParents();
            }
        }
    },
    
    
    // starts a `batched` cascade (can contain several cascades, combined in one `currentCascadeBatch` context
    // cascade batch may actually contain 0 cascades (if for example deps are invalid)
    startBatchCascade : function () {
        if (!this.batchCascadeLevel) {
            this.currentCascadeBatch    = { 
                nbrAffected         : 0, 
                affected            : {},
                
                visitedCounters     : {},
                
                addVisited          : function (task) {
                    var internalId      = task.internalId;
                    
                    if (!this.visitedCounters[ internalId ]) {
                        this.visitedCounters[ internalId ]     = 1;
                    } else {
                        this.visitedCounters[ internalId ]++;
                    }
                },
                
                addAffected         : function (task) {
                    var internalId      = task.internalId;
                    
                    if (!this.affected[ internalId ]) {
                        this.affected[ internalId ]            = task;
                        this.nbrAffected++;
                    }
                }
            };
        }
        
        this.batchCascadeLevel++;
        
        return this.currentCascadeBatch;
    },
    
    
    endBatchCascade : function () {
        this.batchCascadeLevel--;
        
        if (!this.batchCascadeLevel) {
            var currentCascadeBatch     = this.currentCascadeBatch;
            this.currentCascadeBatch    = null;

            // nbrAffected == 0 may still mean we are inside of cascade
            if (currentCascadeBatch.nbrAffected > 0) {
                this.resetEarlyDates();
                this.resetLateDates();
            }
            
            if (this.cascading) {
                this.cascading              = false;
                this.fireEvent('cascade', this, currentCascadeBatch);
            }
        }
    },
    

    /**
     * Cascade the updates to the depended tasks of given `task` (re-schedule them as soon as possible).
     *
     * @param {Gnt.model.Task} task
     */
    cascadeChangesForTask : function (sourceTask, doNotRecalculateParents) {
        var currentCascadeBatch     = this.currentCascadeBatch;
        
        if (currentCascadeBatch && currentCascadeBatch.visitedCounters[ sourceTask.internalId ] > sourceTask.predecessors.length) {
            return { nbrAffected : 0, affected : {} };
        }

        this.startBatchCascade();
        
        var me              = this,
            context         = { nbrAffected : 0, affected : {} };
            
//        // go breadth
//        currentCascadeBatch         = this.currentCascadeBatch;
//        
//        var queue           = sourceTask.getSuccessors();
//            
//        while (queue.length) {
//            var task        = queue.shift()
//            
//            if (currentCascadeBatch.visitedCounters[ task.internalId ] > task.predecessors.length) continue;
//            
//            currentCascadeBatch.addVisited(task);
//            
//            if (!task.isManuallyScheduled() && (task.isLeaf() || me.enableDependenciesForParentTasks)) {
//                if (!me.cascading) {
//                    // even that the task may not have changed in the following constrain
//                    // we need to fire the "beforecascade" event here, otherwise `constrain` may cause 
//                    // several updates and that will be not efficient
//                    me.fireEvent('beforecascade', me);
//                    me.cascading = true;
//                }
//                
//                var changed     = task.constrain(me);
//        
//                if (changed) {
//                    // update local context
//                    context.nbrAffected++;
//                    context.affected[ task.internalId ] = task;
//                    
//                    // update batch context
//                    currentCascadeBatch.addAffected(this);
//                    
//                    queue.push.apply(queue, task.getSuccessors())
//                }
//            }
//        }
//        // eof go breadth

        // go deep
        Ext.each(sourceTask.getOutgoingDependencies(true), function (dependency) {
            var dependentTask = dependency.getTargetTask();

            if (dependentTask) {
                if (!me.cascading) {
                    me.fireEvent('beforecascade', me);
                    me.cascading = true;
                }
                
                dependentTask.cascadeChanges(me, context, dependency);
            }
        });
        // eof go deep

        if (me.cascading) {
            if (!doNotRecalculateParents && me.recalculateParents) me.recalculateAffectedParents(context.affected);
        }
        
        this.endBatchCascade();
        
        return context;
    },
    
    
    // context object, containing list of parent task, along with the index by "internalId"
    getParentsContext : function () {
        return {
            array           : [],
            byInternalId    : {}
        };
    },
    
    
    // adds a task to the context returned by `getParentsContext`, keeping the following contract:
    // if some task is in context, then all its parent tasks should be in context too
    addTaskToParentsContext : function (parentsContext, task) {
        var byId        = parentsContext.byInternalId;
        var array       = parentsContext.array;
        var parent      = task.isLeaf() ? task.parentNode : task;
        
        while (parent) {
            if (byId[ parent.internalId ]) break;
            
            byId[ parent.internalId ] = parent;
            array.push(parent);
            
            parent      = parent.parentNode;
        }
    },
    
    
    recalculateAffectedParents : function (affectedTasksByInternalId, parentsContext) {
        parentsContext      = parentsContext || this.getParentsContext();
        
        this.suspendAutoCascade++;
        this.suspendAutoRecalculateParents++;
        
        var me              = this;
        
        Ext.Object.each(affectedTasksByInternalId, function (internalId, task) {
            me.addTaskToParentsContext(parentsContext, task);
        });
        
        var array           = parentsContext.array;
        
        array.sort(function (a, b) {
            return a.data.depth - b.data.depth;
        });
        
        var i;
        
        if (this.recalculateParents) {
            // refreshing the parent tasks starting from the deep-most ones - that critical for correct calculations
            for (i = array.length - 1; i >= 0; i--) array[ i ].refreshCalculatedParentNodeData();
        }
        
        if (this.cascadeChanges) {
            // cascading from top-most ones in the hope that they go earlier in time
            // (thus minimizing updates)
            for (i = 0; i < array.length; i++) this.cascadeChangesForTask(array[ i ]);
        }
        
        this.suspendAutoRecalculateParents--;
        this.suspendAutoCascade--;
    },


    onTaskDeleted : function (node, removedNode, isMove) {
        var dependencyStore     = this.dependencyStore;
        var deps;

        if (dependencyStore && !removedNode.isReplace && !isMove) {
            deps = removedNode.getAllDependencies(dependencyStore);
            dependencyStore.remove(deps);
        }

        var span        = this.getTotalTimeSpan();
        var startDate   = removedNode.getStartDate();
        var endDate     = removedNode.getEndDate();

        // if removed task dates were equal to total range then removing can affect total time span
        // so let's reset getTotalTimeSpan() cache
        if (endDate - span.end === 0 || startDate - span.start === 0) {
            this.lastTotalTimeSpan = null;
        }

        //if early/late dates are supported
        this.resetEarlyDates();
        this.resetLateDates();
    },


    onAssignmentMutation : function (assignmentStore, assignments) {
        var me      = this;

        Ext.each(assignments, function (assignment) {
            // Taskstore could be filtered etc.
            var t = assignment.getTask(me);
            if (t) {
                t.onAssignmentMutation(assignment);
            }
        });
    },


    onAssignmentStructureMutation : function (assignmentStore, assignments) {
        var me      = this;

        Ext.each(assignments, function (assignment) {
            var task  = assignment.getTask(me);

            if (task) {
                task.onAssignmentStructureMutation(assignment);
            }
        });
    },


    onDependencyAddOrUpdate: function (store, dependencies) {
        // reset early late dates cache
        this.resetEarlyDates();
        this.resetLateDates();

        // If cascade changes is activated, adjust the connected task start/end date
        if (this.cascadeChanges) {
            var me      = this,
                task;

            Ext.each(dependencies, function (dependency) {
                task = dependency.getTargetTask();
                if (task) {
                    task.constrain(me);
                }
            });
        }
    },

    onDependencyDelete: function (store, dependencies) {
        // reset early late dates cache
        this.resetEarlyDates();
        this.resetLateDates();
    },

    // pass "this" to filter function
    getNewRecords: function() {
        return Ext.Array.filter(this.tree.flatten(), this.filterNew, this);
    },

    // pass "this" to filter function
    getUpdatedRecords: function() {
        return Ext.Array.filter(this.tree.flatten(), this.filterUpdated, this);
    },


    // ignore root
    // @OVERRIDE
    filterNew: function(item) {
        // only want phantom records that are valid
        return item.phantom && item.isValid() && item != this.tree.root;
    },


    // ignore root
    // @OVERRIDE
    filterUpdated: function(item) {
        // only want dirty records, not phantoms that are valid
        return item.dirty && !item.phantom && item.isValid() && item != this.tree.root;
    },


    // Only used when not batching writes to the server. If batching is used, the server will always
    // see the full picture and can resolve parent->child relationships based on the PhantomParentId and PhantomId field values
    onTaskStoreBeforeSync: function (records, options) {
        var recordsToCreate     = records.create;

        if (recordsToCreate) {
            for (var r, i = recordsToCreate.length - 1; i >= 0; i--) {
                r = recordsToCreate[i];

                if (!r.isPersistable()) {
                    // Remove records that cannot yet be persisted (if parent is a phantom)
                    Ext.Array.remove(recordsToCreate, r);
                }
            }

            // Prevent empty create request
            if (recordsToCreate.length === 0) {
                delete records.create;
            }
        }

        return Boolean((records.create  && records.create.length  > 0) ||
                       (records.update  && records.update.length  > 0) ||
                       (records.destroy && records.destroy.length > 0));
    },

    onTaskStoreWrite : function(store, operation) {
        var dependencyStore = this.dependencyStore;

        if (!dependencyStore || operation.action !== 'create') {
            return;
        }

        var records = operation.getRecords(),
            taskId;

        Ext.each(records, function(task) {
            taskId = task.getId();

            if (!task.phantom && taskId !== task._phantomId) {
                Ext.each(dependencyStore.getNewRecords(), function (dep) {
                    var from = dep.getSourceId();
                    var to = dep.getTargetId();

                    // If dependency store is configured with autoSync, the 'set' operations below will trigger a Create action
                    // to setup the new "proper" dependencies
                    if (from === task._phantomId) {
                        dep.setSourceId(taskId);
                    } else if (to === task._phantomId) {
                        dep.setTargetId(taskId);
                    }
                });

                Ext.each(task.childNodes, function(child) {
                    if (child.phantom) {
                        child.set('parentId', taskId);
                    }
                });

                delete task._phantomId;
            }
        });
    },

    forEachTaskUnOrdered: function (fn, scope) {
        var hash    = this.tree.nodeHash;
        var root    = this.getRootNode();
        
        for (var property in hash) {
            if (hash[property] !== root) 
                if (fn.call(scope || this, hash[property]) === false) return false;
        }
    },

    getTasksTimeSpan : function(tasks) {
        var earliest = new Date(9999,0,1), latest = new Date(0);

        var compareFn = function(r) {
            var startDate = r.getStartDate();
            var endDate = r.getEndDate();

            if (startDate && startDate < earliest) {
                earliest = startDate;
            }

            // Ignore tasks without start date as they aren't rendered anyway
            if (startDate && endDate && endDate > latest) {
                latest = endDate;
            }
        };

        if (tasks) {
            if (!Ext.isArray(tasks)) tasks = [tasks];

            Ext.Array.each(tasks, compareFn);
        } else {
            this.forEachTaskUnOrdered(compareFn);
        }

        earliest    = earliest < new Date(9999,0,1) ? earliest : null;
        latest      = latest > new Date(0) ? latest : null;

        return {
            start   : earliest,
            end     : latest || (earliest && Ext.Date.add(earliest, Ext.Date.DAY, 1)) || null
        };
    },

    /**
     * Returns an object defining the earliest start date and the latest end date of all the tasks in the store.
     * Tasks without start date are ignored, tasks without end date use their start date (if any) + 1 day
     * @return {Object} An object with 'start' and 'end' Date properties.
     */
    getTotalTimeSpan : function() {
        if (this.lastTotalTimeSpan) return this.lastTotalTimeSpan;

        this.lastTotalTimeSpan = this.getTasksTimeSpan();

        return this.lastTotalTimeSpan;
    },

    getProjectStartDate : function () {
        return this.getTotalTimeSpan().start;
    },

    getProjectEndDate : function () {
        return this.getTotalTimeSpan().end;
    },

    /**
     * Cascades the tree and counts all nodes.  Please note, this method will not count nodes that are supposed to be loaded lazily - it will only count nodes "physically" present in the store.
     *
     * @return {Boolean} (optional) ignoreRoot true to ignore counting the root node of the tree (defaults to true)
     * @return {Int} The number of tasks currently loaded in the store
     */
    getCount : function(ignoreRoot) {
        var count = ignoreRoot === false ? 0 : -1;
        this.getRootNode().cascadeBy(function() { count++; });
        return count;
    },

    /**
     * Returns an array of all the tasks in this store.
     *
     * @return {[Gnt.model.Task]} The tasks currently loaded in the store
     */
    toArray : function() {
        var tasks = [];

        this.getRootNode().cascadeBy(function(t) {
            tasks.push(t);
        });

        return tasks;
    },

    /**
     * Removes one or more tasks from the store
     *
     * @param {Gnt.model.Task/Gnt.model.Task[]} tasks The task(s) to remove
     */
    remove : function(records) {
        Ext.each(records, function(t) {
            t.remove();
        });
    },

    /**
    * Increase the indendation level of one or more tasks in the tree
    * @param {Gnt.model.Task/Gnt.model.Task[]} tasks The task(s) to indent
    */
    indent: function (nodes) {

        this.fireEvent('beforeindentationchange', this, nodes);

        // TODO method should fail (and return false?) if passed nodes are from different parent nodes
        nodes       = Ext.isArray(nodes) ? nodes.slice() : [ nodes ];

        nodes.sort(function(a, b) { return a.data.index - b.data.index; });

        Ext.each(nodes, function(node) { node.indent(); });

        this.fireEvent('indentationchange', this, nodes);
    },


    /**
    * Decrease the indendation level of one or more tasks in the tree
    * @param {Gnt.model.Task/Gnt.model.Task[]} tasks The task(s) to outdent
    */
    outdent: function (nodes) {
        this.fireEvent('beforeindentationchange', this, nodes);

        // TODO method should fail (and return false?) if passed nodes are from different parent nodes
        nodes       = Ext.isArray(nodes) ? nodes.slice() : [ nodes ];

        nodes.sort(function(a, b) { return b.data.index - a.data.index; });

        Ext.each(nodes, function(node) { node.outdent(); });

        this.fireEvent('indentationchange', this, nodes);
    },

    /**
    * Returns the tasks associated with a resource
    * @param {Gnt.model.Resource} resource
    * @return {Gnt.model.Task[]} the tasks assigned to this resource
    */
    getTasksForResource: function (resource) {
        return resource.getTasks();
    },

    getEventsForResource: function (resource) {
        return this.getTasksForResource(resource);
    },

    // Event store adaptions (flat store vs tree store)

    indexOf : function(rec) {
        // since indexOf is irrelevant for the event store in Scheduler, we only return 0 or -1
        // this is called by event selection model (by its superclass)
        return rec && this.tree.getNodeById(rec.internalId) ? 0 : -1;
    },

    getByInternalId : function(id) {
        return this.tree.getNodeById(id);
    },

    queryBy : function(fn, scope) {
        var retVal = [];
        var me = this;

        this.getRootNode().cascadeBy(function(task) {
            if (fn.call(scope || me, task)) {
                retVal.push(task);
            }
        });

        return retVal;
    },

    onSorted : function() {
        // After sorting we need to reapply filters if store was previously filtered
        if (this.lastTreeFilter) {
            this.filterTreeBy(this.lastTreeFilter);
        }
    },

    /**
     * Appends a new task to the store
     * @param {Gnt.model.Task} record The record to append the store
     */
    append : function(record) {
        this.getRootNode().appendChild(record);
    },

    resetEarlyDates : function () {
        this.earlyStartDates = {};
        this.earlyEndDates = {};
        this.fireEvent('resetearlydates');
    },

    resetLateDates : function () {
        this.lateStartDates = {};
        this.lateEndDates = {};
        this.fireEvent('resetlatedates');
    },

    /**
     * Returns Task by sequential number. See {@link Gnt.model.Task#getSequenceNumber} for details.
     *
     * @param {Number} number
     *
     * @return {Gnt.model.Task}
     */
    getBySequenceNumber : function(number) {
        return this.getRootNode().getBySequenceNumber(number);
    }
}, function() {
    this.override(Sch.data.mixin.FilterableTreeStore.prototype.inheritables() || {});
});

/**
@class Gnt.data.ResourceStore
@extends Sch.data.ResourceStore

A class representing the collection of the resources - {@link Gnt.model.Resource} records.

*/

Ext.define('Gnt.data.ResourceStore', {
    
    requires    : [
        'Gnt.model.Resource'
    ],
    
    extend      : 'Sch.data.ResourceStore',
    
    
    model       : 'Gnt.model.Resource',
    
    
    /**
     * @property {Gnt.data.TaskStore} taskStore The task store to which this resource store is associated.
     * Usually is configured automatically, by the task store itself.   
     */
    taskStore   : null,
    

    
    constructor : function () {
        // Call this early manually to be able to add listeners before calling the superclass constructor
        this.mixins.observable.constructor.call(this);
        
        this.on({
            load            : this.normalizeResources,

            scope           : this
        });
        
        this.callParent(arguments);
    },
    
    
    normalizeResources : function () {
        // scan through all resources and re-assign the "calendarId" property to get the listeners in place
        this.each(function (resource) {
            if (!resource.normalized) {
                var calendarId      = resource.getCalendarId();
                
                if (calendarId) resource.setCalendarId(calendarId, true);
                
                resource.normalized     = true;
            }
        });
    },
    
    
    /**
     * Returns the associated task store instance.
     * 
     * @return {Gnt.data.TaskStore}
     */
    getTaskStore: function(){
        return this.taskStore || null;
    },

    
    /**
     * Returns the associated assignment store instance.
     * 
     * @return {Gnt.data.AssignmentStore}
     */
    getAssignmentStore: function(){
        return this.assignmentStore || null;
    },
    
    
    getByInternalId : function (id) {
        return this.data.getByKey(id) || this.getById(id);
    }
});
/**
@class Gnt.data.AssignmentStore
@extends Ext.data.Store

A class representing the collection of the assignments between the tasks in the {@link Gnt.data.TaskStore} and resources
in the {@link Gnt.data.ResourceStore}.

Contains the collection of {@link Gnt.model.Assignment} records.

*/

Ext.define('Gnt.data.AssignmentStore', {
    extend      : 'Ext.data.Store',

    requires    : [
        'Gnt.model.Assignment'
    ],

    model       : 'Gnt.model.Assignment',

    /**
     * @property {Gnt.data.TaskStore} taskStore The task store to which this assignment store is associated.
     * Usually is configured automatically, by the task store itself.   
     */
    taskStore   : null,
    

    /**
     * Returns the associated task store instance.
     * 
     * @return {Gnt.data.TaskStore}
     */
    getTaskStore: function(){
        return this.taskStore;
    },

    
    /**
     * Returns the associated resource store instance.
     * 
     * @return {Gnt.data.ResourceStore}
     */
    getResourceStore: function(){
        return this.getTaskStore().resourceStore;
    },
    
    
    getByInternalId : function (id) {
        return this.data.getByKey(id) || this.getById(id);
    }
});
Ext.define('Gnt.patches.IETreeStore', {
    extend      : 'Sch.util.Patch',

    requires    : ['Gnt.data.TaskStore'],
    target      : 'Gnt.data.TaskStore',

    ieOnly      : true,

    overrides   : {

        // @OVERRIDE
        // Need a hack to protect IE
        onNodeAdded : function (parent, node) {
            var me = this,
                proxy = me.getProxy(),
                reader = proxy.getReader(),
                data = node.raw || node[node.persistenceProperty],
                dataRoot;

            Ext.Array.remove(me.removed, node);
            node.join(me);

            if (!node.isLeaf()) {
                dataRoot = reader.getRoot(data);
                if (dataRoot) {
                    me.fillNode(node, reader.extractData(dataRoot));
                    if (data[reader.root]) {        // MODIFIED, ADDED IF CHECK
                        delete data[reader.root];
                    }
                }
            }

            if (me.autoSync && !me.autoSyncSuspended && (node.phantom || node.dirty)) {
                me.sync();
            }
        }
    }
});

/**
@class Gnt.template.Template
@extends Ext.XTemplate

Base class of all UI task templates. Subclass this class to implement your own UI template.
*/
Ext.define("Gnt.template.Template", {
    extend      : 'Ext.XTemplate',

    isLegacyIE  : Ext.isIE8m || Ext.isIEQuirks,

    getInnerTpl : Ext.emptyFn,

    innerTpl    : null,

    dependencyTerminalMarkup : '<div class="sch-gantt-terminal sch-gantt-terminal-start"></div><div class="sch-gantt-terminal sch-gantt-terminal-end"></div>',

    constructor : function (cfg) {
        Ext.apply(this, cfg);

        var side = cfg.rtl ? 'right' : 'left';
        var inner = this.getInnerTpl(cfg) || '';

        this.callParent([
                 '<div class="sch-event-wrap {ctcls} ' + Ext.baseCSSPrefix + 'unselectable" style="' + side + ':{offset}px">'+
                    (cfg.leftLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-left"><label class="sch-gantt-label sch-gantt-label-left">{leftLabel}</label></div>' : '')+
                    (cfg.rightLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-right" style="left:{width}px"><label class="sch-gantt-label sch-gantt-label-right">{rightLabel}</label></div>' : '') +
                    (cfg.topLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-top"><label class="sch-gantt-label sch-gantt-label-top">{topLabel}</label></div>' : '') +
                     inner +
                     (cfg.bottomLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-bottom"><label class="sch-gantt-label sch-gantt-label-bottom">{bottomLabel}</label></div>' : '') +
                '</div>',
            {
                compiled        : true,
                disableFormats  : true
            }
        ]);
    }
});

/**
@class Gnt.template.Task
@extends Ext.XTemplate

Template class used to render a regular leaf task.
*/
Ext.define("Gnt.template.Task", {
    extend : 'Gnt.template.Template',

    /**
     * @cfg {String} innerTpl The template defining the inner visual markup for the task.
     */
    innerTpl : '<div class="sch-gantt-progress-bar" style="width:{percentDone}%;{progressBarStyle}" unselectable="on">&#160;</div>',

    getInnerTpl : function (cfg) {
        var side = cfg.rtl ? 'right' : 'left';

        return '<div id="' + cfg.prefix + '{id}" class="sch-gantt-item sch-gantt-task-bar {cls}" unselectable="on" style="width:{width}px;{style}">'+
                    // @BWCOMPAT 2.2: sch-resizable-handle-west and sch-resizable-handle-east should be removed in 3.0
                    ((cfg.resizeHandles === 'both' || cfg.resizeHandles === 'left') ? '<div class="sch-resizable-handle sch-gantt-task-handle sch-resizable-handle-start sch-resizable-handle-west"></div>' : '') +

                    this.innerTpl +

                    ((cfg.resizeHandles === 'both' || cfg.resizeHandles === 'right') ? '<div class="sch-resizable-handle sch-gantt-task-handle sch-resizable-handle-end sch-resizable-handle-east"></div>' : '') +

                    (cfg.enableProgressBarResize ? '<div style="' + side + ':{percentDone}%" class="sch-gantt-progressbar-handle"></div>': '') +

                    // Left / Right terminals
                    (cfg.enableDependencyDragDrop ? this.dependencyTerminalMarkup : '') +
                '</div>';
    }
});
/**
@class Gnt.template.Milestone
@extends Ext.XTemplate

Class used to render a milestone task.
*/
Ext.define("Gnt.template.Milestone", {
    extend : 'Gnt.template.Template',

    /**
     * @cfg {String} innerTpl The template defining the inner visual markup for the milestone task.
     * Please note that this markup may be different depending on the browser used.
     */
    innerTpl :  (Ext.isIE8m || Ext.isIEQuirks ?
        ('<div style="border-width:{[Math.floor(values.side*0.7)]}px" class="sch-gantt-milestone-diamond-top {cls}" unselectable="on" style="{style}"></div>' +
        '<div style="border-width:{[Math.floor(values.side*0.7)]}px" class="sch-gantt-milestone-diamond-bottom {cls}" unselectable="on" style="{style}"></div>') :

        ('<img style="{[values.print ? "height:" + values.side + "px;border-left-width:" + values.side + "px" : ""]};{style}" src="' + Ext.BLANK_IMAGE_URL + '" class="sch-gantt-milestone-diamond {cls}" unselectable="on"/>')),

    getInnerTpl : function (cfg) {
        return '<div ' + (this.isLegacyIE ? 'style="width:{[Math.floor(values.side*0.7)]}px"' : '') + ' id="' + cfg.prefix + '{id}" class="sch-gantt-item sch-gantt-milestone-diamond-ct">' +
            // Milestone diamond, 2 elements for old IE
            this.innerTpl +
            // Dependency terminals
            (cfg.enableDependencyDragDrop ? this.dependencyTerminalMarkup : '') +
        '</div>';
    }
});
/**
@class Gnt.template.ParentTask
@extends Ext.XTemplate

Class used to render a parent task.
*/
Ext.define("Gnt.template.ParentTask", {
    extend : 'Gnt.template.Template',

    /**
     * @cfg {String} innerTpl The template defining the inner visual markup for the task.
     */
    innerTpl    : '<div class="sch-gantt-progress-bar" style="width:{percentDone}%;{progressBarStyle}">&#160;</div>'+
        '<div class="sch-gantt-parenttask-arrow sch-gantt-parenttask-leftarrow"></div>' +
        '<div class="sch-gantt-parenttask-arrow sch-gantt-parenttask-rightarrow"></div>',

    getInnerTpl : function(cfg) {
        return '<div id="' + cfg.prefix + '{id}" class="sch-gantt-item sch-gantt-parenttask-bar {cls}" style="width:{width}px; {style}">'+
                    this.innerTpl +
                    // Left / Right terminals
                    (cfg.enableDependencyDragDrop ? this.dependencyTerminalMarkup : '') +
                '</div>';

    }
});

/*
@class Gnt.Tooltip
@extends Ext.ToolTip
@private

Internal plugin showing task start/end information.
*/
Ext.define("Gnt.Tooltip", {
    extend      : 'Ext.ToolTip',
    alias       : 'widget.gantt_task_tooltip',

    requires    : ['Ext.Template'],

    mixins      : ['Gnt.mixin.Localizable'],

    /**
     * @cfg {String} startText The text to show before the start date. Defaults to 'Starts:'.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} endText The text to show before the end date. Defaults to 'Ends:'.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} durationText The text to show before the duration text during a resize operation. Defaults to 'Duration:'.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - startText       : 'Starts: ',
            - endText         : 'Ends: ',
            - durationText    : 'Duration:'
     */

    /**
     * @cfg {String} mode "startend" or "duration"
     */
    mode            : 'startend',


    cls             : 'sch-tip',

    height          : 40,

    autoHide        : false,
    anchor          : 'b-tl',
    maskOnDisable   : false,

    initComponent : function() {
        this.rtl = this.gantt.rtl;

        if (this.mode === 'startend' && !this.startEndTemplate) {
            this.startEndTemplate = new Ext.Template(
                '<div class="sch-timetipwrap {cls}">' +
                '<div>' +
                    this.L('startText') + '{startText}' +
                '</div>' +
                '<div>' +
                    this.L('endText') + '{endText}' +
                '</div>' +
            '</div>'
            ).compile();
        }

        if (this.mode === 'duration' && !this.durationTemplate) {
            this.durationTemplate = new Ext.Template(
                '<div class="sch-timetipwrap {cls}">',
                    '<div>' + this.L('startText') + ' {startText}</div>',
                    '<div>' + this.L('durationText') + ' {duration} {unit}' + '</div>',
                '</div>'
            ).compile();
        }

        this.callParent(arguments);
    },



    update : function (start, end, valid, taskRecord) {
        var content;
        if (this.mode === 'duration') {
            content = this.getDurationContent(start, end, valid, taskRecord);
        } else {
            content = this.getStartEndContent(start, end, valid, taskRecord);
        }
        this.callParent([content]);
    },


    // private
    getStartEndContent : function(start, end, valid, taskRecord) {
        var gantt       = this.gantt,
            startText   = gantt.getFormattedDate(start),
            endText     = startText,
            roundedEnd;

        if (end - start > 0) {
            endText = gantt.getFormattedEndDate(end, start);
        }

        var retVal = {
            cls         : valid ? 'sch-tip-ok' : 'sch-tip-notok',
            startText   : startText,
            endText     : endText
        };

        if (this.showClock) {
            Ext.apply(retVal, {
                startHourDegrees        : roundedStart.getHours() * 30,
                startMinuteDegrees      : roundedStart.getMinutes() * 6
            });

            if (end) {
                Ext.apply(retVal, {
                    endHourDegrees      : roundedEnd.getHours() * 30,
                    endMinuteDegrees    : roundedEnd.getMinutes() * 6
                });
            }
        }
        return this.startEndTemplate.apply(retVal);
    },


    getDurationContent : function(start, end, valid, taskRecord) {
        var unit        = taskRecord.getDurationUnit() || Sch.util.Date.DAY;
        var duration    = taskRecord.calculateDuration(start, end, unit);

        return this.durationTemplate.apply({
            cls         : valid ? 'sch-tip-ok' : 'sch-tip-notok',
            startText   : this.gantt.getFormattedDate(start),
            duration    : parseFloat(Ext.Number.toFixed(duration, 1)),
            unit        : Sch.util.Date.getReadableNameOfUnit(unit, duration > 1)
        });
    },


    show : function(el, xPos) {
        if (el) {
            this.setTarget(el);
        }

        this.callParent([]);

        // Must do this after callParent where rendering takes place
        if (xPos !== undefined) {
            this.setX(xPos);
        }
    }
});

/*
 * @class Gnt.feature.TaskDragDrop
 * @extends Ext.dd.DragZone
 * @private
 * 
 * Internal plugin enabling drag and drop for tasks
 */
Ext.define("Gnt.feature.TaskDragDrop", {
    extend : "Ext.dd.DragZone",

    requires : [
        'Gnt.Tooltip',
        'Ext.dd.StatusProxy'
    ],

    // Reference to the gantt view
    gantt           : null,

    // Don't seem to need these
    onDragEnter     : Ext.emptyFn,
    onDragOut       : Ext.emptyFn,

    /**
     * @cfg useTooltip {Boolean} `false` to not show a tooltip while dragging
     */
    useTooltip      : true,
    
    tip             : null,

    /**
     * An empty function by default, but provided so that you can perform custom validation on
     * the item being dragged. This function is called during the drag and drop process and also after the drop is made
     * @param {Ext.data.Model} record The record being dragged
     * @param {Date} date The date corresponding to the current start date
     * @param {Int} duration The duration of the item being dragged, in minutes
     * @param {Ext.EventObject} e The event object
     * @return {Boolean} true if the drop position is valid, else false to prevent a drop
     */
    validatorFn     : function (record, date, duration, e) { return true; },

    /**
     * @cfg {Object} validatorFnScope
     * The scope for the validatorFn, defaults to the gantt view instance
     */
    validatorFnScope : null,
    
    // has to be set to `false` - we'll register the gantt view in the ScrollManager manually
    containerScroll : false,

    dropAllowed     : "sch-gantt-dragproxy",
    dropNotAllowed  : "sch-gantt-dragproxy",

    
    constructor : function (el, config) {
        config          = config || {};
        Ext.apply(this, config);

        // Drag drop won't work in IE8 if running in an iframe
        // https://www.assembla.com/spaces/bryntum/tickets/712#/activity/ticket:
        if (Ext.isIE && (Ext.isIE8 || Ext.isIE7 || Ext.ieVersion < 9) && window.top !== window) {
            Ext.dd.DragDropManager.notifyOccluded = true;
        }

        this.proxy      = this.proxy || new Ext.dd.StatusProxy({
            shadow               : false,
            dropAllowed          : "sch-gantt-dragproxy",
            dropNotAllowed       : "sch-gantt-dragproxy",

            // HACK, we want the proxy inside the gantt chart, otherwise drag drop breaks in fullscreen mode
            ensureAttachedToBody : Ext.emptyFn
        });

        var me          = this,
            gantt       = me.gantt;

        if (me.useTooltip) {
            me.tip      = new Gnt.Tooltip({
                cls   : 'gnt-dragdrop-tip',
                gantt : gantt
            });
        }

        me.callParent([ el, Ext.apply(config, { ddGroup : gantt.id + '-task-dd' }) ]);

        me.scroll       = false;
        me.isTarget     = true;
        me.ignoreSelf   = false;

        // Stop task drag and drop when a resize handle, a terminal or a parent task is clicked
        me.addInvalidHandleClass('sch-resizable-handle');
        me.addInvalidHandleClass(Ext.baseCSSPrefix + 'resizable-handle');
        me.addInvalidHandleClass('sch-gantt-terminal');
        me.addInvalidHandleClass('sch-gantt-progressbar-handle');

        gantt.ownerCt.el.appendChild(this.proxy.el);

        gantt.on({
            destroy : me.destroy,
            scope   : me
        });
    },
    

    destroy : function () {
        if (this.tip) {
            this.tip.destroy();
        }
        this.callParent(arguments);
    },


    // @OVERRIDE
    autoOffset : function (x, y) {
        this.setDelta(0, 0);
    },

    // @OVERRIDE
    setXConstraint : function (iLeft, iRight, iTickSize) {
        this.leftConstraint = iLeft;
        this.rightConstraint = iRight;

        this.minX = iLeft;
        this.maxX = iRight;
        if (iTickSize) {
            this.setXTicks(this.initPageX, iTickSize);
        }

        this.constrainX = true;
    },

    // @OVERRIDE
    setYConstraint : function (iUp, iDown, iTickSize) {
        this.topConstraint = iUp;
        this.bottomConstraint = iDown;

        this.minY = iUp;
        this.maxY = iDown;
        if (iTickSize) {
            this.setYTicks(this.initPageY, iTickSize);
        }

        this.constrainY = true;
    },

    constrainTo : function (constrainingRegion, elRegion, offsetX, offsetY) {
        this.resetConstraints();
        
        this.initPageX  = constrainingRegion.left + offsetX;
        this.initPageY  = elRegion.top + offsetY;
        
        this.setXConstraint(constrainingRegion.left, constrainingRegion.right, this.xTickSize);
        this.setYConstraint(elRegion.top - 1, elRegion.top - 1, this.yTickSize);
    },

    
    onDragOver : function (e, id) {
        var data        = this.dragData,
            task        = data.record,
            gantt       = this.gantt;
            
        if (!data.hidden) {
            Ext.fly(data.sourceNode).hide();
            data.hidden = true;
        }
            
        var newStart;

        // the time diff method can be used for continuous time axis only
        // fallback to proxy element position resolving for filtered time axis
        if (gantt.timeAxis.isContinuous()) {
            var timeDiff    = gantt.getDateFromCoordinate(e.getXY()[ 0 ]) - data.sourceDate;
        
            newStart        = gantt.timeAxis.roundDate(new Date(data.origStart - 0 + timeDiff));
        } else {
            var proxyEl     = this.proxy.el;
            //                                                                        Adjust x position for certain task types
            var x           = proxyEl.getX() + (gantt.rtl ? proxyEl.getWidth() : 0) + gantt.getXOffset(task) - data.offsets[ 0 ]; 
            newStart        = gantt.getDateFromXY([ x, 0 ], 'round');
        }

        if (!newStart || newStart - data.start === 0) return;

        data.start      = newStart;
        
        this.valid      = this.validatorFn.call(
            this.validatorFnScope || gantt,
            task,
            newStart,
            data.duration,
            e
        ) !== false;
        
        if (this.tip) {
            var end = task.calculateEndDate(newStart, task.getDuration(), task.getDurationUnit());

            this.updateTip(task, newStart, end, this.valid);
        }
    },

    
    startDrag : function() {
        var ScrollManager               = Ext.dd.ScrollManager;
        
        this.gantt.el.ddScrollConfig    = {
            // this line required for ExtJS 4.2.1 only in 4.2.2 increment will be read from ScrollManager itself if missing
            increment       : ScrollManager.increment,
            hthresh         : ScrollManager.hthresh,
            // disable the vertical container scroll while dragging the task
            vthresh         : -1
        };
        
        return this.callParent(arguments);
    },

    
    endDrag : function() {
        // remove previous constraints for container scroll
        delete this.gantt.el.ddScrollConfig;
        
        return this.callParent(arguments);
    },
    
    
    onStartDrag : function () {
        var rec = this.dragData.record;

        if (this.tip) {
            this.tip.enable();
            this.tip.show(this.dragData.ddel);

            this.updateTip(rec, rec.getStartDate(), rec.getEndDate());
        }
        
        this.gantt.fireEvent('taskdragstart', this.gantt, rec);
    },

    
    updateTip : function (record, start, end, isValid) {
        isValid     = isValid !== false;

        if (record.isMilestone() && start - Ext.Date.clearTime(start, true) === 0) {
            start   = Sch.util.Date.add(start, Sch.util.Date.MILLI, -1);
            end     = Sch.util.Date.add(end, Sch.util.Date.MILLI, -1);
        }

        this.tip.update(start, end, isValid);
    },

    // On receipt of a mousedown event, see if it is within a draggable element.
    // Return a drag data object if so. The data object can contain arbitrary application
    // data, but it should also contain a DOM element in the ddel property to provide
    // a proxy to drag.
    getDragData : function (e) {
        var g               = this.gantt,
            sourceNode      = e.getTarget(g.eventSelector);

        if (sourceNode && !e.getTarget('.sch-gantt-baseline-item')) {
            var sourceTask          = g.resolveTaskRecord(sourceNode),
                isMilestone         = sourceTask.isMilestone();

            if (g.fireEvent('beforetaskdrag', g, sourceTask, e) === false) {
                return null;
            }
            
            var xy                  = e.getXY();

            var copy                = sourceNode.cloneNode(true),
                increment           = g.getSnapPixelAmount(),
                origXY              = Ext.fly(sourceNode).getXY();
                
            var offsets             = [ xy[ 0 ] - origXY[ 0 ], xy[ 1 ] - origXY[ 1 ] ];

            copy.id                 = Ext.id();
            var height              = Ext.fly(sourceNode).getHeight();

            // Height needs to be hardcoded since it's percentage based when the task bar is inside the row/cell
            Ext.fly(copy).setHeight(height - (Ext.isIE7 && !isMilestone ? 2 : 0));

            if (Ext.isIE8m && isMilestone) {
                Ext.fly(copy).setSize(height + 5, height + 5);
            }
            
//            copy.style.position     = 'absolute'
            copy.style.left         = -offsets[ 0 ] + 'px';
//            copy.style.top          = -offsets[ 1 ] + 'px'

//            if (increment >= 1) {
//                Ext.fly(copy).setStyle('left', '-' + g.getXOffset(sourceTask) + 'px');  // Reset any offset applied through CSS
//            }

            this.constrainTo(
                Ext.fly(g.findItemByChild(sourceNode)).getRegion(), 
                Ext.fly(sourceNode).getRegion(),
                offsets[ 0 ], offsets[ 1 ]
            );

            if (increment >= 1) {
                this.setXConstraint(this.leftConstraint, this.rightConstraint, increment);
            }

            return {
                sourceNode  : sourceNode,
                repairXY    : origXY,
                offsets     : offsets,
                ddel        : copy,
                record      : sourceTask,
                duration    : Sch.util.Date.getDurationInMinutes(sourceTask.getStartDate(), sourceTask.getEndDate()),
                
                sourceDate  : g.getDateFromCoordinate(xy[ 0 ]),
                origStart   : sourceTask.getStartDate(),
                start       : null
            };
        }
        return null;
    },

    // Override, get rid of weird highlight fx in default implementation
    afterRepair : function () {
        Ext.fly(this.dragData.sourceNode).show();
        if (this.tip) {
            this.tip.hide();
        }
        this.dragging = false;
    },

    // Provide coordinates for the proxy to slide back to on failed drag.
    // This is the original XY coordinates of the draggable element.
    getRepairXY : function () {
        this.gantt.fireEvent('aftertaskdrop', this.gantt);
        return this.dragData.repairXY;
    },

    onDragDrop : function (e, id) {
        var target      = this.cachedTarget || Ext.dd.DragDropMgr.getDDById(id),
            data        = this.dragData,
            gantt       = this.gantt,
            task        = data.record,
            start       = data.start;

        var wasChanged  = false;

        if (this.tip) {
            this.tip.disable();
        }

        if (this.valid && start && task.getStartDate() - start !== 0) {
            // Done this way since it might be dropped on a holiday, and then gets bumped back to its original value
            gantt.taskStore.on('update', function () { wasChanged = true; }, null, { single : true });

            task.setStartDate(start, true, gantt.taskStore.skipWeekendsDuringDragDrop);

            if (wasChanged) {
                gantt.fireEvent('taskdrop', gantt, task);
                // For our good friend IE9, the pointer cursor gets stuck without the defer
                if (Ext.isIE9) {
                    this.proxy.el.setStyle('visibility', 'hidden');
                    Ext.Function.defer(this.onValidDrop, 10, this, [target, e, id]);
                } else {
                    this.onValidDrop(target, e, id);
                }
            }
        }

        if (!wasChanged) {
            this.onInvalidDrop(target, e, id);
        }

        gantt.fireEvent('aftertaskdrop', gantt, task);
    },

    // HACK: Override for IE, if you drag the task bar outside the window or iframe it crashes (missing e.target)
    // https://www.assembla.com/spaces/bryntum/tickets/716
    onInvalidDrop : function(target, e, id) {
        if (Ext.isIE && !e) {
            e = target;
            target = target.getTarget() || document.body;
        }

        return this.callParent([target, e, id]);
    }
});


/*
 * @class Gnt.feature.DependencyDragZone
 * @extends Ext.util.Observable
 * @private
 * Internal drag zone class for dependency drag drop.
 */
Ext.define("Gnt.feature.DependencyDragZone", {
    extend : 'Ext.dd.DragZone',

    mixins: {
        observable:  'Ext.util.Observable'
    },

    rtl              : null,
    useLineProxy     : null,
    terminalSelector : null,
    ganttView        : null,
    fromText         : null,
    toText           : null,
    startText        : null,
    endText          : null,

    constructor : function(el, config) {
        this.mixins.observable.constructor.call(this, config);

        this.callParent(arguments);
    },

    initLineProxy : function (sourceEl, isStart) {
        var lpEl = this.lineProxyEl = this.lineProxyEl || this.el.createChild({ cls : 'sch-gantt-connector-proxy' });
        var adjust = (Ext.isIE9m || Ext.isIEQuirks) ? 0 : 4;
        var side = this.rtl ? (isStart ? 'r' : 'l') : (isStart ? 'l' : 'r');

        lpEl.alignTo(sourceEl, side, [isStart ? -adjust : adjust, 0]);

        Ext.apply(this, {
            containerTop    : this.el.getTop(),
            containerLeft   : this.el.getLeft(),
            startXY         : lpEl.getXY(),
            startScrollLeft : this.el.dom.scrollLeft,
            startScrollTop  : this.el.dom.scrollTop
        });
    },

    onDrag : function(e, t) {
        if (this.useLineProxy) {
            this.updateLineProxy(e.getXY());
        }
    },

    updateLineProxy : function (xy) {
        var lineProxy = this.lineProxyEl,
            diffX = xy[0] - this.startXY[0] + this.el.dom.scrollLeft - this.startScrollLeft,
            diffY = xy[1] - this.startXY[1] + this.el.dom.scrollTop - this.startScrollTop,
            newHeight = Math.max(1, Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) - 2),
            // Calculate new angle relative to start XY
            rad = Math.atan2(diffY, diffX) - (Math.PI / 2),
            styleBlob;

        if ((Ext.isIE9m || Ext.isIEQuirks)) {
            var cos = Math.cos(rad),
                sin = Math.sin(rad),
                matrixString = 'progid:DXImageTransform.Microsoft.Matrix(sizingMethod="auto expand", M11 = ' + cos + ', M12 = ' + (-sin) + ', M21 = ' + sin + ', M22 = ' + cos + ')',
                scrollValueTop,
                scrollValueLeft;

            if (this.el.dom.scrollTop !== this.startScrollTop) {
                scrollValueTop = this.startScrollTop - this.containerTop;
            } else {
                scrollValueTop = this.el.dom.scrollTop - this.containerTop;
            }

            if (this.el.dom.scrollLeft !== this.startScrollLeft) {
                scrollValueLeft = this.startScrollLeft - this.containerLeft;
            } else {
                scrollValueLeft = this.el.dom.scrollLeft - this.containerLeft;
            }

            styleBlob = {
                "height"     : newHeight + 'px',
                "top"        : Math.min(0, diffY) + this.startXY[1] + scrollValueTop + (diffY < 0 ? 2 : 0) + 'px',
                "left"       : Math.min(0, diffX) + this.startXY[0] + scrollValueLeft + (diffX < 0 ? 2 : 0) + 'px',
                "filter"     : matrixString,
                "-ms-filter" : matrixString
            };
        } else {
            var rotateString = 'rotate(' + rad + 'rad)';

            styleBlob = {
                "height"            : newHeight + 'px',
                "-o-transform"      : rotateString,
                "-webkit-transform" : rotateString,
                "-ms-transform"     : rotateString,
                "-moz-transform"    : rotateString,
                "transform"         : rotateString
            };
        }

        lineProxy.setStyle(styleBlob);
    },


    onStartDrag : function () {
        this.el.addCls('sch-gantt-dep-dd-dragging');
        this.fireEvent('dndstart', this);

        if (this.useLineProxy) {
            var dd = this.dragData;
            this.initLineProxy(dd.sourceNode, dd.isStart);
            this.lineProxyEl.show();
        }
    },

    // On receipt of a mousedown event, see if it is within a draggable element.
    // Return a drag data object if so. The data object can contain arbitrary application
    // data, but it should also contain a DOM element in the ddel property to provide
    // a proxy to drag.
    getDragData : function (e) {
        var sourceNode = e.getTarget(this.terminalSelector);

        if (sourceNode) {
            var sourceTaskRecord = this.ganttView.resolveTaskRecord(sourceNode);
            if (this.fireEvent('beforednd', this, sourceTaskRecord) === false) {
                return null;
            }

            var isStart = !!sourceNode.className.match('sch-gantt-terminal-start'),
                ddel = Ext.core.DomHelper.createDom({
                    cls      : 'sch-dd-dependency',
                    children : [
                        {
                            tag  : 'span',
                            cls  : 'sch-dd-dependency-from',
                            html : Ext.String.format(this.fromText, Ext.String.htmlEncode(sourceTaskRecord.getName()), isStart ? this.startText : this.endText)
                        },
                        {
                            tag  : 'span',
                            cls  : 'sch-dd-dependency-to',
                            html : ''
                        }
                    ]
                });

            return {
                fromId     : sourceTaskRecord.getId() || sourceTaskRecord.internalId,
                isStart    : isStart,
                repairXY   : Ext.fly(sourceNode).getXY(),
                ddel       : ddel,
                sourceNode : Ext.fly(sourceNode).up(this.ganttView.eventSelector)
            };
        }
        return false;
    },

    // Override, get rid of weird highlight fx in default implementation
    afterRepair : function () {
        this.el.removeCls('sch-gantt-dep-dd-dragging');

        this.dragging = false;
        this.fireEvent('afterdnd', this);
    },

    onMouseUp   : function () {
        this.el.removeCls('sch-gantt-dep-dd-dragging');

        if (this.lineProxyEl) {
            var duration = (Ext.isIE9m || Ext.isIEQuirks) ? 0 : 400;
            var el = this.lineProxyEl;

            el.animate({
                to       : { height : 0 },
                duration : duration,
                callback : function() {
                    Ext.destroy(el);
                }
            });

            this.lineProxyEl = null;
        }
    },

    // Provide coordinates for the proxy to slide back to on failed drag.
    // This is the original XY coordinates of the draggable element.
    getRepairXY : function () {
        return this.dragData.repairXY;
    },

    destroy : function () {
        Ext.destroy(this.lineProxyEl);

        this.callParent(arguments);
    }
});


/*
 * @class Gnt.feature.DependencyDropZone
 * @extends Ext.util.Observable
 * @private
 * Internal drop zone class for dependency drag drop.
 */
Ext.define("Gnt.feature.DependencyDropZone", {
    extend : 'Ext.dd.DropZone',

    mixins: {
        observable:  'Ext.util.Observable'
    },

    terminalSelector : null,
    dependencyStore  : null,
    toText           : null,
    startText        : null,
    endText          : null,

    constructor : function(el, config) {
        this.mixins.observable.constructor.call(this, config);

        this.callParent(arguments);
    },

    getTargetFromEvent : function (e) {
        return e.getTarget(this.terminalSelector);
    },

    // On entry into a target node, highlight that node.
    onNodeEnter        : function (target, dd, e, data) {
        Ext.fly(target).addCls('sch-gantt-terminal-drophover');
    },

    // On exit from a target node, unhighlight that node.
    onNodeOut          : function (target, dd, e, data) {
        Ext.fly(target).removeCls('sch-gantt-terminal-drophover');

        // Clear the proxy text showing the target task
        dd.proxy.el.down('.sch-dd-dependency-to').update(Ext.String.format(this.toText, '', ''));
    },

    onNodeOver : function (target, dd, e, data) {
        var targetRecord = this.ganttView.resolveTaskRecord(target),
            targetId = targetRecord.getId() || targetRecord.internalId,
            isTargetStart = target.className.match('sch-gantt-terminal-start'),
            newText = Ext.String.format(this.toText, Ext.String.htmlEncode(targetRecord.getName()), isTargetStart ? this.startText : this.endText);

        dd.proxy.el.down('.sch-dd-dependency-to').update(newText);

        var type = this.resolveType(data.isStart, target);

        if (this.dependencyStore.isValidDependency(data.fromId, targetId, type)) {
            return this.dropAllowed;
        } else {
            return this.dropNotAllowed;
        }
    },

    onNodeDrop : function (target, dd, e, data) {
        var type = this.resolveType(data.isStart, target),
            retVal,
            targetRec = this.ganttView.resolveTaskRecord(target),
            targetId = targetRec.getId() || targetRec.internalId;

        this.el.removeCls('sch-gantt-dep-dd-dragging');

        retVal = this.dependencyStore.isValidDependency(data.fromId, targetId, type);

        if (retVal) {
            this.fireEvent('drop', this, data.fromId, targetId, type);
        }
        this.fireEvent('afterdnd', this);

        return retVal;
    },

    resolveType : function (isStart, target) {
        var DepType = Gnt.model.Dependency.Type,
            type;

        if (isStart) {
            if (target.className.match('sch-gantt-terminal-start')) {
                type = DepType.StartToStart;
            } else {
                type = DepType.StartToEnd;
            }
        } else {
            if (target.className.match('sch-gantt-terminal-start')) {
                type = DepType.EndToStart;
            } else {
                type = DepType.EndToEnd;
            }
        }

        return type;
    }
});

/*
 * @class Gnt.feature.DependencyDragDrop
 * @extends Ext.util.Observable
 * @private
 * Internal class managing the interaction of setting up new dependencies using drag and drop between dependency terminals.
 */
Ext.define("Gnt.feature.DependencyDragDrop", {
    extend : 'Ext.util.Observable',

    mixins : {
        localizable : 'Gnt.mixin.Localizable'
    },

    requires : [
        'Gnt.feature.DependencyDragZone',
        'Gnt.feature.DependencyDropZone'
    ],

    /**
     * @cfg {String} fromText The text to show before the from task when setting up a dependency. Defaults to 'From:'.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} toText The text to show before the to task when setting up a dependency. Defaults to 'From:'.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} startText The text indicating that a dependency connector is a Start type.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} endText The text indicating whether a dependency connector is an End type.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - fromText    : 'From: <strong>{0},</strong> {1},<br/>',
     - toText      : 'To: <strong>{0},</strong> {1},',
     - startText   : 'Start',
     - endText     : 'End'
     */

    /**
     * @cfg {Boolean} useLineProxy True to display a line while dragging
     */
    useLineProxy     : true,

    /**
     * @cfg {Object} dragZoneConfig
     * A custom config object used to configure the Ext.dd.DragZone instance.
     */
    dragZoneConfig  : null,

    /**
     * @cfg {Object} dropZoneConfig
     * A custom config object used to configure the Ext.dd.DropZone instance.
     */
    dropZoneConfig  : null,

    // private, the terminal CSS selector
    terminalSelector : '.sch-gantt-terminal',
    el               : null,
    rtl              : null,
    ddGroup          : null,
    ganttView        : null,

    constructor : function (config) {
        this.addEvents(
            /**
             * @event beforednd
             * Fires before a drag and drop operation is initiated, return false to cancel it
             * @param {Gnt.feature.DependencyDragDrop} dnd The drag and drop instance
             * @param {Ext.data.Model} fromRecord The task record
             */
            'beforednd',

            /**
             * @event dndstart
             * Fires when a drag and drop operation starts
             * @param {Gnt.feature.DependencyDragDrop} dnd The drag and drop instance
             */
            'dndstart',

            /**
             * @event drop
             * Fires after a drop has been made on a receiving terminal
             * @param {Gnt.feature.DependencyDragDrop} dnd The drag and drop instance
             * @param {Mixed} fromId The source dependency task record id
             * @param {Mixed} toId The target dependency task record id
             * @param {Int} type The dependency type, see {@link Gnt.model.Dependency} for more information about possible values.
             */
            'drop',

            /**
             * @event afterdnd
             * Always fires after a dependency drag and drop operation
             * @param {Gnt.feature.DependencyDragDrop} dnd The drag and drop instance
             */
            'afterdnd'
        );

        var view = config.ganttView;

        Ext.apply(this, config);

        this.ddGroup = view.id + '-sch-dependency-dd';

        // Lazy setup
        this.el.on('mousemove', this.doSetup, this, { single : true });

        this.callParent(arguments);
    },

    doSetup : function () {
        var me = this;

        // The drag zone behaviour
        this.dragZone = new Gnt.feature.DependencyDragZone(this.el, Ext.apply({
            rtl              : this.rtl,
            terminalSelector : this.terminalSelector,
            useLineProxy     : this.useLineProxy,
            ddGroup          : this.ddGroup,
            ganttView        : this.ganttView,

            startText        : this.L('startText'),
            endText          : this.L('endText'),
            fromText         : this.L('fromText')
        }, this.dragZoneConfig));

        this.relayEvents(this.dragZone, ['beforednd', 'dndstart', 'afterdnd']);

        this.dropZone = Ext.create("Gnt.feature.DependencyDropZone", this.el, Ext.apply({
            rtl              : this.rtl,
            terminalSelector : this.terminalSelector,
            ddGroup          : this.ddGroup,
            ganttView        : this.ganttView,
            dependencyStore  : this.dependencyStore,

            startText        : this.L('startText'),
            endText          : this.L('endText'),
            toText           : this.L('toText')
        }, this.dropZoneConfig));

        this.relayEvents(this.dropZone, ['drop', 'afterdnd']);
    },

    destroy : function () {
        if (this.dragZone) {
            this.dragZone.destroy();
        }

        if (this.dropZone) {
            this.dropZone.destroy();
        }
    }
});

/*
* @class Gnt.feature.DragCreator
* @private
*
* An internal class which shows a drag proxy while clicking and dragging.
* Create a new instance of this plugin
*/
Ext.define("Gnt.feature.DragCreator", {
    requires : [
        'Ext.Template',
        'Sch.util.DragTracker',
        'Gnt.Tooltip'
    ],

    constructor : function (config) {
        Ext.apply(this, config || {});

        this.init();
    },

    /**
    * @cfg {Boolean} disabled true to start disabled
     */
    disabled: false,

    /**
    * @cfg {Boolean} showDragTip true to show a time tooltip when dragging to create a new event
    */
    showDragTip: true,

    /**
    * @cfg {Int} dragTolerance Number of pixels the drag target must be moved before dragging is considered to have started. Defaults to 2.
    */
    dragTolerance: 2,

    /**
    * @cfg {Ext.Template} template The HTML template shown when dragging to create new items
    */

    /**
    * An empty function by default, but provided so that you can perform custom validation on the item being created
    * @param {Ext.data.Model} taskRecord the resource for which the task is being created
    * @param {Date} startDate
    * @param {Date} endDate
    * @param {Event} e The event object
    * @return {Boolean} isValid True if the creation event is valid, else false to cancel
    */
    validatorFn: Ext.emptyFn,

    /**
    * @cfg {Object} validatorFnScope
    * The scope for the validatorFn
    */
    validatorFnScope: null,

    /**
    * Enable/disable the plugin
    * @param {Boolean} disabled True to disable this plugin
    */
    setDisabled: function (disabled) {
        this.disabled = disabled;
        if (this.dragTip) {
            this.dragTip.setDisabled(disabled);
        }
    },

    getProxy : function() {
        if (!this.proxy) {
            // Attach this element to the nested gantt panel element (view el is cleared by refreshes)
            this.proxy = this.template.append(this.ganttView.ownerCt.el, {}, true);
        }
        return this.proxy;
    },

    // private
    onBeforeDragStart: function (e) {
        var s = this.ganttView,
            t = e.getTarget('.' + s.timeCellCls, 2);

        if (t) {
            var taskRecord = s.resolveTaskRecord(t);
            var dateTime = s.getDateFromDomEvent(e);

            if (!this.disabled &&
                t &&
                !taskRecord.getStartDate() &&
                !taskRecord.getEndDate() &&
                s.fireEvent('beforedragcreate', s, taskRecord, dateTime, e) !== false) {

                e.stopEvent();

                // Save record if the user ends the drag outside the current row
                this.taskRecord = taskRecord;

                // Start time of the task to be created
                this.originalStart = dateTime;

                // Constrain the dragging within the current row schedule area
                this.rowRegion = s.getScheduleRegion(this.taskRecord, this.originalStart);

                // Save date constraints
                this.dateConstraints = s.getDateConstraints(this.resourceRecord, this.originalStart);

                // TODO apply xStep or yStep to drag tracker
                return true;
            }
        }
        return false;
    },

    // private
    onDragStart: function () {
        var me = this,
            view = me.ganttView,
            proxy = me.getProxy();

        me.start = me.originalStart;
        me.end = me.start;

        me.rowBoundaries = {
            top : me.rowRegion.top,
            bottom : me.rowRegion.bottom
        };

        proxy.setRegion({
            top : me.rowBoundaries.top,
            right : me.tracker.startXY[0],
            bottom : me.rowBoundaries.bottom,
            left : me.tracker.startXY[0]
        });

        proxy.show();

        me.ganttView.fireEvent('dragcreatestart', me.ganttView);

        if (me.showDragTip) {
            me.dragTip.update(me.start, me.end, true, this.taskRecord);
            me.dragTip.enable();
            me.dragTip.show(proxy);
        }
    },

    // private
    onDrag: function (e) {
        var me = this,
            view = me.ganttView,
            dragRegion = me.tracker.getRegion().constrainTo(me.rowRegion),
            dates = view.getStartEndDatesFromRegion(dragRegion, 'round');

        if (!dates) {
            return;
        }

        me.start = dates.start || me.start;
        me.end = dates.end || me.end;

        var dc = me.dateConstraints;

        if (dc) {
            me.end = Sch.util.Date.constrain(me.end, dc.start, dc.end);
            me.start = Sch.util.Date.constrain(me.start, dc.start, dc.end);
        }

        me.valid = this.validatorFn.call(me.validatorFnScope || me, this.taskRecord, me.start, me.end, e) !== false;

        if (me.showDragTip) {
            me.dragTip.update(me.start, me.end, me.valid, this.taskRecord);
        }

        Ext.apply(dragRegion, me.rowBoundaries);

        this.getProxy().setRegion(dragRegion);
    },

    // private
    onDragEnd: function (e) {
        var gv = this.ganttView;

        if (this.showDragTip) {
            this.dragTip.disable();
        }

        if (!this.start || !this.end || (this.end < this.start)) {
            this.valid = false;
        }

        if (this.valid) {
            this.taskRecord.setStartEndDate(this.start, this.end, this.taskRecord.getTaskStore().skipWeekendsDuringDragDrop);
            gv.fireEvent('dragcreateend', gv, this.taskRecord, e);
        }
        this.proxy.hide();

        gv.fireEvent('afterdragcreate', gv);
    },

    // private
    init: function () {
        var gv = this.ganttView,
            gridViewBodyEl = gv.el,
            bind = Ext.Function.bind;

        this.lastTime = new Date();
        this.template = this.template || Ext.create("Ext.Template",
            '<div class="sch-gantt-dragcreator-proxy"></div>',
            {
                compiled : true,
                disableFormats : true
            }
        );

        gv.on({
            destroy: this.onGanttDestroy,
            scope: this
        });

        this.tracker = new Sch.util.DragTracker({
            el : gridViewBodyEl,
            tolerance: this.dragTolerance,
            onBeforeStart: bind(this.onBeforeDragStart, this),
            onStart: bind(this.onDragStart, this),
            onDrag: bind(this.onDrag, this),
            onEnd: bind(this.onDragEnd, this)
        });

        if (this.showDragTip) {
            this.dragTip = Ext.create("Gnt.Tooltip", {
                mode : 'duration',
                cls : 'sch-gantt-dragcreate-tip',
                gantt : gv
            });
        }
    },

    onGanttDestroy: function () {
        if (this.dragTip) {
            this.dragTip.destroy();
        }

        if (this.tracker) {
            this.tracker.destroy();
        }

        if (this.proxy) {
            Ext.destroy(this.proxy);
            this.proxy = null;
        }
    }
});

/**
 * @class Gnt.feature.LabelEditor
 * @protected
 * @extends Ext.Editor
 *
 * Internal class used by the Gantt chart internals allowing inline editing of the task labels.
 */
Ext.define("Gnt.feature.LabelEditor", {
    extend : "Ext.Editor",

    /**
     * @cfg {String} labelPosition Identifies which side of task this editor is used for. Possible values: 'left', 'right', 'top' or 'bottom'.
     * @property
     */
    labelPosition : '',

    constructor     : function (ganttView, config) {
        this.ganttView = ganttView;
        this.ganttView.on('afterrender', this.onGanttRender, this);

        Ext.apply(this, config);

        if (this.labelPosition === 'left') {
            this.alignment = 'r-r';
        } else if (this.labelPosition === 'right') {
            this.alignment = 'l-l';
        }

        this.delegate = '.sch-gantt-label-' + this.labelPosition;

        this.callParent([config]);
    },

    // Programmatically enter edit mode
    edit            : function (record) {
        var wrap = this.ganttView.getElementFromEventRecord(record).up(this.ganttView.eventWrapSelector);
        this.record = record;
        this.startEdit(wrap.down(this.delegate), this.dataIndex ? record.get(this.dataIndex) : '');
    },

    // private, must be supplied
    delegate        : '',

    // private, must be supplied
    dataIndex       : '',
    shadow          : false,
    completeOnEnter : true,
    cancelOnEsc     : true,
    ignoreNoChange  : true,

    onGanttRender : function (ganttView) {
        if (!this.field.width) {
            this.autoSize = 'width';
        }

        this.on({
            beforestartedit : function (editor, el, value) {
                return ganttView.fireEvent('labeledit_beforestartedit', ganttView, this.record, value, editor);
            },
            beforecomplete  : function (editor, value, original) {
                return ganttView.fireEvent('labeledit_beforecomplete', ganttView, value, original, this.record, editor);
            },
            complete        : function (editor, value, original) {
                this.record.set(this.dataIndex, value);
                ganttView.fireEvent('labeledit_complete', ganttView, value, original, this.record, editor);
            },
            scope           : this
        });

        ganttView.el.on('dblclick', function (e, t) {
            this.edit(ganttView.resolveTaskRecord(t));
        }, this, {
            delegate : this.delegate
        });
    }
}); 

/*
* @class Gnt.feature.ProgressBarResize
* 
* Internal plugin enabling resizing of a task progress bar, configure it from the Gantt panel config object using the 'progressBarResizeConfig' object.
*/
Ext.define("Gnt.feature.ProgressBarResize", {
    requires    : [
        'Ext.ToolTip',
        'Ext.resizer.Resizer'
    ],

    constructor : function(config) {
        Ext.apply(this, config || {}); 
        var g = this.ganttView;

        g.on({
            destroy : this.cleanUp,
            scope   : this
        });

        g.el.on('mousedown', this.onMouseDown, this, { delegate: '.sch-gantt-progressbar-handle' });

        this.callParent(arguments);
    },

    /**
    * @cfg useTooltip {Boolean} false to not show a tooltip while resizing. Defaults to true.
    */
    useTooltip  : true,

    /**
    * @cfg {Int} increment
    * The increment in percent to use during a progress element resize
    */
    increment   : 10,

    tip         : null,
    resizable   : null,
    ganttView   : null,

    onMouseDown: function (e, t) {
        var g = this.ganttView,
            rec = g.resolveTaskRecord(t);

        if (g.fireEvent('beforeprogressbarresize', g, rec) !== false) {
            var progBar = Ext.fly(t).prev('.sch-gantt-progress-bar');
            e.stopEvent();

            this.resizable = this.createResizable(progBar, rec, e);
            g.fireEvent('progressbarresizestart', g, rec);

            // If the mouse isn't moved after mousedown, no resize event will be fired by the Ext.Resizable. Handle this case manually
            Ext.getBody().on('mouseup', this.onBodyMouseUp, this, { single : true, delay : 1 });
        }
    },

    // private
    createResizable: function (el, taskRecord, e) {
        var t = e.getTarget(),
            rtl = this.ganttView.rtl,
            taskEl = el.up(this.ganttView.eventSelector),
            taskWidth = taskEl.getWidth() - 2,
            widthIncrement = taskWidth * this.increment / 100;

        var rz = Ext.create('Ext.resizer.Resizer', {
            target          : el,
            taskRecord      : taskRecord,
            handles         : rtl ? 'w' : 'e',
            minWidth        : 0,
            maxWidth        : taskWidth,
            minHeight       : 1,
            widthIncrement  : widthIncrement,
            listeners       : {
                resizedrag  : this.partialResize,
                resize      : this.afterResize,
                scope       : this
            }
        });
        rz.resizeTracker.onMouseDown(e, rz[rtl ? 'west' : 'east'].dom);
        taskEl.select('.' + Ext.baseCSSPrefix + 'resizable-handle, .sch-gantt-terminal, .sch-gantt-progressbar-handle').hide();

        if (this.useTooltip) {
            this.tip = Ext.create("Ext.ToolTip", {
                autoHide    : false,
                anchor      : 'b',
                html        : '%'
            });

            this.tip.setTarget(el);
            this.tip.update(taskRecord.getPercentDone() + '%');

            this.tip.show();
        }

        return rz;
    },

    // private
    partialResize: function (rz, newWidth) {
        var percent = Math.round(newWidth * 100 / (rz.maxWidth * this.increment)) * this.increment;
        
        if (this.tip) {
            this.tip.body.update(percent + '%');
        }
    },

    // private
    afterResize: function (rz, w, h, e) {
        var rec = rz.taskRecord;

        if (this.tip) {
            this.tip.destroy();
            this.tip = null;
        }

        var old = rz.taskRecord.getPercentDone();

        if (Ext.isNumber(w)) {
            var percent = Math.round(w * 100 / (rz.maxWidth * this.increment)) * this.increment;
            rz.taskRecord.setPercentDone(percent);
        }

        if (old === rz.taskRecord.getPercentDone()) {
            // Value didn't change, manually refresh the row
            this.ganttView.refreshNode(this.ganttView.indexOf(rz.taskRecord));
        }

        // Destroy resizable 
        rz.destroy();
        this.resizable = null;

        this.ganttView.fireEvent('afterprogressbarresize', this.ganttView, rec);
    },

    // If the new percent done is the same as the old, no resize event will be fired by the Ext.Resizable. Handle this case manually
    onBodyMouseUp : function() {
        if (this.resizable) {
            this.afterResize(this.resizable);
        }
    },

    cleanUp: function () {
        if (this.tip) {
            this.tip.destroy();
        }
    }
}); 

/**
@class Gnt.feature.TaskResize
@extends Ext.util.Observable

A plugin enabling the task resizing feature. Generally there's no need to manually create it,
it can be activated with the {@link Gnt.panel.Gantt#resizeHandles} option of the gantt panel and configured with the {@link Gnt.panel.Gantt#resizeConfig}.


*/
Ext.define("Gnt.feature.TaskResize", {

    constructor : function(config) {
        Ext.apply(this, config);
        var g = this.gantt;

        g.on({
            destroy : this.cleanUp,
            scope : this
        });

        g.mon(g.el, 'mousedown', this.onMouseDown, this, { delegate : '.sch-resizable-handle' });

        this.callParent(arguments);
    },

    /**
     * @cfg {Boolean} showDuration true to show the duration instead of the end date when resizing a task
     */
    showDuration : true,

    /**
      * @cfg useTooltip {Boolean} false to not show a tooltip while resizing
      */
    useTooltip : true,

    /**
     * An empty function by default, but provided so that you can perform custom validation on
     * the item being resized.
     * @param {Ext.data.Model} taskRecord The task being resized
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Event} e The event object
     * @return {Boolean} isValid True if the creation event is valid, else false to cancel
     */
    validatorFn : Ext.emptyFn,

    /**
     * @cfg {Object} validatorFnScope
     * The scope for the validatorFn
     */
    validatorFnScope : null,

    origEl  : null,
    taskRec : null,
    isStart : null,
    gantt   : null,

    onMouseDown : function(e, t) {
        var s = this.gantt,
            domEl = e.getTarget(s.eventSelector),
            rec = s.resolveTaskRecord(domEl);

        var isResizable = rec.isResizable();

        // Don't trigger on right clicks
        if (e.button !== 0 || isResizable === false || typeof isResizable === 'string' && !domEl.className.match(isResizable)) {
            return;
        }

        if (s.fireEvent('beforetaskresize', s, rec, e) === false) {
            return;
        }
        e.stopEvent();

        this.origEl = domEl;
        this.taskRec = rec;
        this.isStart = !!t.className.match('sch-resizable-handle-start');

        s.el.on({
            mousemove   : this.onMouseMove,
            mouseup     : this.onMouseUp,
            scope       : this,
            single      : true
        });

        s.fireEvent('taskresizestart', s, rec);
    },

    // private
    onMouseMove : function(e, t) {
        var el              = Ext.get(this.origEl),
            g               = this.gantt,
            rtl             = g.rtl,
            isStart         = this.isStart,
            taskRecord      = this.taskRec,
            isWest          = (rtl && !isStart) || (!rtl && isStart),
            widthIncrement  = g.getSnapPixelAmount(),
            currentWidth    = el.getWidth(),
            rowRegion       = el.up(g.getItemSelector()).getRegion();

        this.resizable = Ext.create('Ext.resizer.Resizer', {
            otherEdgeX      : isWest ? el.getRight() : el.getLeft(),
            target          : el,
            taskRecord      : taskRecord,
            isStart         : isStart,
            isWest          : isWest,
            handles         : isWest ? 'w' : 'e',
            constrainTo     : rowRegion,
            minHeight       : 1,
            minWidth        : widthIncrement,
            widthIncrement  : widthIncrement,
            listeners       : {
                resizedrag  : this.partialResize,
                resize      : this.afterResize,
                scope       : this
            }
        });

        // HACK calling private method
        this.resizable.resizeTracker.onMouseDown(e, this.resizable[isWest ? 'west' : 'east'].dom);

        if (this.useTooltip) {

            if(!this.tip) {
                this.tip = Ext.create("Gnt.Tooltip", {
                    mode    : this.showDuration ? 'duration' : 'startend',
                    gantt   : this.gantt
                });
            }

            this.tip.show(el, e.getX() - 15);
            this.tip.update(taskRecord.getStartDate(), taskRecord.getEndDate(), true, taskRecord);

            // Catch case of user not moving the mouse at all
            Ext.getBody().on('mouseup', function(){ this.tip.hide(); }, this, { single : true });
        }
    },

    onMouseUp : function(e, t) {
        var g = this.gantt;

        g.el.un({
            mousemove   : this.onMouseMove,
            scope       : this,
            single      : true
        });
    },

    // private
    partialResize : function (resizer, newWidth, oldWidth, e) {
        var s           = this.gantt,
            isWest      = resizer.isWest,
            cursorDate;

        if (isWest) {
            cursorDate = s.getDateFromCoordinate(resizer.otherEdgeX - Math.min(newWidth, this.resizable.maxWidth), 'round');
        } else {
            cursorDate = s.getDateFromCoordinate(resizer.otherEdgeX + Math.min(newWidth, this.resizable.maxWidth), 'round');
        }

        if (!cursorDate || resizer.date-cursorDate === 0) {
            return;
        }

        var start = resizer.isStart ? cursorDate : resizer.taskRecord.getStartDate(),
            end   = resizer.isStart ? resizer.taskRecord.getEndDate() : cursorDate,
            valid = this.validatorFn.call(this.validatorFnScope || this, resizer.taskRecord, start, end) !== false;

        resizer.date = cursorDate;

        s.fireEvent('partialtaskresize', s, resizer.taskRecord, start, end, resizer.el, e);

        if (this.useTooltip) {
            this.tip.update(start, end, valid, resizer.taskRecord);
        }
    },

    // private
    afterResize : function (resizer, w, h, e) {
        if (this.useTooltip) {
            this.tip.hide();
        }
        var taskRecord  = resizer.taskRecord,
            oldStart    = taskRecord.getStartDate(),
            oldEnd      = taskRecord.getEndDate(),
            start       = resizer.isStart ? resizer.date : oldStart,
            end         = resizer.isStart ? oldEnd : resizer.date,
            gantt       = this.gantt;

        // Destroy resizable
        resizer.destroy();

        if (start && end && // Input sanity check
            (start - oldStart || end - oldEnd) && // Make sure start OR end changed
            this.validatorFn.call(this.validatorFnScope || this, taskRecord, start, end, e) !== false) {

            // let's make sure that node has fired 'itemupdate' event otherwise scheduling view may present outdated start/end dates
            // For example: we have start date set to Monday and drag it to Sunday then 'itemupdate' won't be fired since
            // start date will be adjusted back to Monday (skip non-working time) and it will not change
            var updated,
                checkerFn = function() { updated = true; };

            gantt.on('itemupdate', checkerFn, null, { single : true });

            var skipWeekends    = gantt.taskStore.skipWeekendsDuringDragDrop;

            // start <= end is "normal" case
            // start > end is case when task should be resized to 0
            if (start - oldStart !== 0) {
                taskRecord.setStartDate(start <= end ? start : end, false, skipWeekends);
            } else {
                taskRecord.setEndDate(start <= end ? end : start, false, skipWeekends);
            }

            gantt.un('itemupdate', checkerFn, null, { single : true });

            // it 'itemupdate' wasn't fired let's refresh node manually
            if (!updated) gantt.refreshNode(gantt.store.indexOf(taskRecord));

        } else {
            gantt.refreshKeepingScroll();
        }

        gantt.fireEvent('aftertaskresize', gantt, taskRecord);
    },

    cleanUp : function() {
        if (this.tip) {
            this.tip.destroy();
        }
    }
});

/**
@class Gnt.feature.WorkingTime
@extends Sch.plugin.Zones

A simple subclass of the {@link Sch.plugin.Zones} which highlights holidays/weekends on the gantt chart. 
Generally, there's no need to instantiate it manually, it can be activated with the {@link Gnt.panel.Gantt#highlightWeekends} configuration option.

{@img gantt/images/plugin-working-time.png}

Note, that the holidays/weekends will only be shown when the resolution of the time axis is weeks or less.

*/
Ext.define("Gnt.feature.WorkingTime", {
    extend : 'Sch.plugin.Zones',
    
    requires : [
        'Ext.data.Store',
        'Sch.model.Range'
    ],
    
    expandToFitView : true,

    /**
     * @cfg {Gnt.data.Calendar} calendar The calendar to extract the holidays from
     */
    calendar : null,
    

    init : function (ganttPanel) {
        if (!this.calendar) {
            Ext.Error.raise("Required attribute 'calendar' missed during initialization of 'Gnt.feature.WorkingTime'");
        }

        this.bindCalendar(this.calendar);
        
        Ext.apply(this, {
            store : new Ext.data.Store({
                model       : 'Sch.model.Range'
            })
        });
        
        this.callParent(arguments);
        
        ganttPanel.on('viewchange', this.onViewChange, this);
        
        // timeAxis should be already fully initialized at this point
        this.onViewChange();
    },

    bindCalendar : function(calendar) {
        var listeners = {
            datachanged     : this.refresh,
            update          : this.refresh,

            scope           : this,
            delay           : 1
        };
        
        if (this.calendar) {
            this.calendar.un(listeners);
        }

        calendar.on(listeners);

        this.calendar = calendar;
    },
    
    onViewChange : function () {
        var DATE    = Sch.util.Date;
        
        if (DATE.compareUnits(this.timeAxis.unit, DATE.WEEK) > 0) {
            this.setDisabled(true);
        } else {
            this.setDisabled(false);
            
            this.refresh();
        }
    },

    
    refresh : function() {
        var view        = this.schedulerView;
        
        this.store.removeAll(true);
        
        this.store.add(this.calendar.getHolidaysRanges(view.timeAxis.getStart(), view.timeAxis.getEnd(), true));
    }
});
/**

 @class Gnt.plugin.DependencyEditor
 @extends Ext.form.Panel

 {@img gantt/images/dependency-editor.png}

 A plugin (ptype = 'gantt_dependencyeditor') which shows the dependency editor panel, when a user double-clicks a dependency line or arrow.

 To customize the fields created by this plugin, override the `buildFields` method.

 You can add it to your gantt chart like this:

 var gantt = Ext.create('Gnt.panel.Gantt', {

        plugins             : [
            Ext.create("Gnt.plugin.DependencyEditor", {
                // default value
                hideOnBlur      : true
            })
        ],
        ...
    })


 */
Ext.define("Gnt.plugin.DependencyEditor", {
    extend        : "Ext.form.Panel",
    alias         : 'plugin.gantt_dependencyeditor',
    mixins        : ['Ext.AbstractPlugin', 'Gnt.mixin.Localizable'],
    lockableScope : 'top',

    // 1. We don't use header at all, 2. IE8 takes the use of a header personal and dies in Ext 4.2.1. http://www.sencha.com/forum/showthread.php?271770-4.2.1-getFramingInfoCls-broken-in-IE8
    header        : false,

    requires : [
        'Ext.form.field.Display',
        'Ext.form.field.ComboBox',
        'Ext.form.field.Number',
        'Gnt.model.Dependency'
    ],

    /**
     * @cfg {Boolean} hideOnBlur True to hide this panel if a click is detected outside the panel (defaults to true)
     */
    hideOnBlur : true,

    /**
     * @cfg {String} fromText The text to before the From label
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} toText The text to before the To label
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} typeText The text to before the Type field
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} lagText The text to before the Lag field
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} endToStartText The text for `end-to-start` dependency type
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} startToStartText The text for `start-to-start` dependency type
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} endToEndText The text for `end-to-end` dependency type
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} startToEndText The text for `start-to-end` dependency type
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - fromText            : 'From',
     - toText              : 'To',
     - typeText            : 'Type',
     - lagText             : 'Lag',
     - endToStartText      : 'Finish-To-Start',
     - startToStartText    : 'Start-To-Start',
     - endToEndText        : 'Finish-To-Finish',
     - startToEndText      : 'Start-To-Finish'
     */

    /**
     * @cfg {Boolean} showLag True to show the lag editor
     */
    showLag : false,

    border     : false,
    height     : 150,
    width      : 260,
    frame      : true,
    labelWidth : 60,

    /**
     * @cfg {String} triggerEvent
     * The event upon which the editor shall be shown. Defaults to 'dependencydblclick'.
     */
    triggerEvent : 'dependencydblclick',

    /**
     * @cfg {Boolean} constrain Pass `true` to enable the constraining - ie editor panel will not exceed the document edges. This option will disable the animation
     * during the expansion. Default value is `false`.
     */
    constrain : false,

    initComponent : function () {
        Ext.apply(this, {
            items : this.buildFields(),

            defaults : {
                width : 240
            },

            floating : true,
            hideMode : 'offsets'
        });

        this.callParent(arguments);

        this.addCls('sch-gantt-dependencyeditor');
    },

    init : function (cmp) {
        cmp.on(this.triggerEvent, this.onDependencyDblClick, this);
        cmp.on('destroy', this.destroy, this);
        cmp.on('afterrender', this.onGanttRender, this, { delay : 50 });

        this.gantt = cmp;
        this.taskStore = cmp.getTaskStore();
    },

    onGanttRender : function () {
        this.render(Ext.getBody());

        // Collapse after render, otherwise rendering is messed up
        this.collapse(Ext.Component.DIRECTION_TOP, true);
        this.hide();

        if (this.hideOnBlur) {
            // Hide when clicking outside panel
            this.on({
                show : function () {
                    this.mon(Ext.getBody(), {
                        click : this.onMouseClick,
                        scope : this
                    });
                },

                hide : function () {
                    this.mun(Ext.getBody(), {
                        click : this.onMouseClick,
                        scope : this
                    });
                },

                delay : 50
            });
        }
    },

    /**
     * Expands the editor
     * @param {Record} dependencyRecord The record to show in the editor panel
     * @param {Array} xy the coordinates where the window should be shown
     */
    show : function (dependencyRecord, xy) {
        this.dependencyRecord = dependencyRecord;

        // Load form panel fields
        this.getForm().loadRecord(dependencyRecord);
        this.fromLabel.setValue(Ext.String.htmlEncode(this.dependencyRecord.getSourceTask().getName()));
        this.toLabel.setValue(Ext.String.htmlEncode(this.dependencyRecord.getTargetTask().getName()));

        this.callParent([]);
        this.el.setXY(xy);

        this.expand(!this.constrain);

        if (this.constrain) {
            this.doConstrain(Ext.util.Region.getRegion(Ext.getBody()));
        }
    },


    /**
     * This method is being called during form initialization. It should return an array of fields, which will be assigned to the `items` property.
     * @return {Array}
     */
    buildFields : function () {
        var me = this,
            depClass = Gnt.model.Dependency,
            DependencyType = depClass.Type,
            fields = [
                this.fromLabel = Ext.create("Ext.form.DisplayField", {
                    fieldLabel : this.L('fromText')
                }),

                this.toLabel = Ext.create("Ext.form.DisplayField", {
                    fieldLabel : this.L('toText')
                }),

                this.typeField = Ext.create("Ext.form.ComboBox", {
                    name          : depClass.prototype.nameField,
                    fieldLabel    : this.L('typeText'),
                    triggerAction : 'all',
                    queryMode     : 'local',
                    valueField    : 'value',
                    displayField  : 'text',
                    editable      : false,
                    store         : Ext.create("Ext.data.JsonStore", {
                        fields : ['text', 'value'],
                        data   : [
                            {
                                text  : this.L('endToStartText'),
                                value : DependencyType.EndToStart
                            },
                            {
                                text  : this.L('startToStartText'),
                                value : DependencyType.StartToStart
                            },
                            {
                                text  : this.L('endToEndText'),
                                value : DependencyType.EndToEnd
                            },
                            {
                                text  : this.L('startToEndText'),
                                value : DependencyType.StartToEnd
                            }
                        ]
                    })
                })
            ];

        if (this.showLag) {
            fields.push(
                this.lagField = Ext.create("Ext.form.NumberField", {
                    name       : depClass.prototype.lagField,
                    fieldLabel : this.L('lagText')
                })
            );
        }

        return fields;
    },

    onDependencyDblClick : function (depView, record, e, t) {
        if (this.lagField) {
            this.lagField.name = record.lagField;
        }

        if (this.typeField) {
            this.typeField.name = record.typeField;
        }

        if (record != this.dependencyRecord) {
            this.show(record, e.getXY());
        }
    },


    onMouseClick  : function (e) {
        if (
            this.collapsed || e.within(this.getEl()) ||
                // ignore the click on the menus and combo-boxes (which usually floats as the direct child of <body> and
                // leaks through the `e.within(this.getEl())` check
                e.getTarget('.' + Ext.baseCSSPrefix + 'layer') ||

                // if clicks should be ignored for any other element - it should have this class
                e.getTarget('.sch-ignore-click')
            ) {
            return;
        }

        this.collapse();
    },

    // Always hide drag proxy on collapse
    afterCollapse : function () {
        delete this.dependencyRecord;

        // Currently the header is kept even after collapse, so need to hide the form completely
        this.hide();

        this.callParent(arguments);

        if (this.hideOnBlur) {
            // Hide when clicking outside panel
            this.mun(Ext.getBody(), 'click', this.onMouseClick, this);
        }
    }
});

/**
@class Gnt.plugin.TaskContextMenu
@extends Ext.menu.Menu

Plugin (ptype = 'gantt_taskcontextmenu') for showing a context menu when right clicking a task:

{@img gantt/images/context-menu.png}

You can add it to your gantt chart like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        plugins             : [
            Ext.create("Gnt.plugin.TaskContextMenu")
        ],
        ...
    })


To customize the content of the menu, subclass this plugin and provide your own implementation of the `createMenuItems` method.
You can also customize various handlers for menu items, like `addTaskAbove`, `deleteTask` etc. For example:

    Ext.define('MyProject.plugin.TaskContextMenu', {
        extend     : 'Gnt.plugin.TaskContextMenu',

        createMenuItems : function () {
            return this.callParent().concat({
                text        : 'My handler',

                handler     : this.onMyHandler,
                scope       : this
            })
        },

        onMyHandler : function () {
            // the task on which the right click have occured
            var task        = this.rec;

            ...
        }
    });

    var gantt = Ext.create('Gnt.panel.Gantt', {
        selModel : new Ext.selection.TreeModel({ ignoreRightMouseSelection : false }),
        plugins             : [
            Ext.create("MyProject.plugin.TaskContextMenu")
        ],
        ...
    })

Note that when using right click to show the menu you should the 'ignoreRightMouseSelection' to false on your selection model (as seen in the source above).

*/
Ext.define("Gnt.plugin.TaskContextMenu", {
    extend        : "Ext.menu.Menu",
    alias         : 'plugin.gantt_taskcontextmenu',
    mixins        : ['Ext.AbstractPlugin', 'Gnt.mixin.Localizable'],
    lockableScope : 'top',

    requires : ['Gnt.model.Dependency'],

    legacyHolderProp : 'texts',

    plain : true,

    /**
     * @cfg {String} triggerEvent
     * The event upon which the menu shall be shown. Defaults to 'taskcontextmenu', meaning the menu is shown when right-clicking a task.
     * You can change this to 'itemcontextmenu' if you want the menu to be shown when right clicking the a grid cell too.
     */
    triggerEvent : 'taskcontextmenu',

    /**
     * @cfg {Object} texts A object, purposed for localization.
     * @deprecated Please use {@link #l10n l10n} instead.
     */

    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - newTaskText         : 'New task',
     - deleteTask          : 'Delete task(s)',
     - editLeftLabel       : 'Edit left label',
     - editRightLabel      : 'Edit right label',
     - add                 : 'Add...',
     - deleteDependency    : 'Delete dependency...',
     - addTaskAbove        : 'Task above',
     - addTaskBelow        : 'Task below',
     - addMilestone        : 'Milestone',
     - addSubtask          : 'Sub-task',
     - addSuccessor        : 'Successor',
     - addPredecessor      : 'Predecessor'
     */

    grid : null,

    /**
     * @property {Gnt.model.Task} rec The task model, for which the menu was activated
     */
    rec  : null,

    lastHighlightedItem : null,

    /**
     * This method is being called during plugin initialization. Override if you need to customize the items in the menu.
     * The method should return an array of menu items, which will be used as the value of the `items` property.
     *
     * Each menu item is decorated with an itemId property for testability.
     *
     * @return {Array}
     */
    createMenuItems : function () {
        return [
            {
                handler      : this.deleteTask,
                requiresTask : true,
                itemId       : 'deleteTask',
                text         : this.L('deleteTask')
            },
            {
                handler      : this.editLeftLabel,
                requiresTask : true,
                itemId       : 'editLeftLabel',
                text         : this.L('editLeftLabel')
            },
            {
                handler      : this.editRightLabel,
                requiresTask : true,
                itemId       : 'editRightLabel',
                text         : this.L('editRightLabel')
            },
            {
                handler      : this.toggleMilestone,
                requiresTask : true,
                itemId       : 'toggleMilestone',
                text         : this.L('convertToMilestone')
            },
            {
                text   : this.L('add'),
                itemId : 'addTaskMenu',
                menu   : {
                    plain : true,
                    defaults : { scope : this },
                    items : [
                        {
                            handler      : this.addTaskAboveAction,
                            requiresTask : true,
                            text         : this.L('addTaskAbove')
                        },
                        {
                            handler : this.addTaskBelowAction,
                            text    : this.L('addTaskBelow')
                        },
                        {
                            handler      : this.addMilestone,
                            requiresTask : true,
                            text         : this.L('addMilestone')
                        },
                        {
                            handler      : this.addSubtask,
                            requiresTask : true,
                            text         : this.L('addSubtask')
                        },
                        {
                            handler      : this.addSuccessor,
                            requiresTask : true,
                            text         : this.L('addSuccessor')
                        },
                        {
                            handler      : this.addPredecessor,
                            requiresTask : true,
                            text         : this.L('addPredecessor')
                        }
                    ]
                }
            },
            {
                text         : this.L('deleteDependency'),
                requiresTask : true,
                itemId       : 'deleteDependencyMenu',

                isDependenciesMenu : true,

                menu : {
                    plain : true,

                    listeners : {
                        beforeshow : this.populateDependencyMenu,

                        // highlight dependencies on mouseover of the menu item
                        mouseover  : this.onDependencyMouseOver,

                        // unhighlight dependencies on mouseout of the menu item
                        mouseleave : this.onDependencyMouseOut,

                        scope : this
                    }
                }
            }
        ];
    },


    // backward compat
    buildMenuItems  : function () {
        this.items = this.createMenuItems();
    },


    initComponent : function () {
        this.defaults = this.defaults || {};
        this.defaults.scope = this;

        this.buildMenuItems();

        this.callParent(arguments);
    },


    init : function (grid) {
        grid.on('destroy', this.cleanUp, this);
        var scheduleView = grid.getSchedulingView(),
            lockedView = grid.lockedGrid.getView();

        if (this.triggerEvent === 'itemcontextmenu') {
            lockedView.on('itemcontextmenu', this.onItemContextMenu, this);
            scheduleView.on('itemcontextmenu', this.onItemContextMenu, this);
        }
        // Always listen to taskcontext menu
        scheduleView.on('taskcontextmenu', this.onTaskContextMenu, this);

        // Handle case of empty schedule too
        scheduleView.on('containercontextmenu', this.onContainerContextMenu, this);
        lockedView.on('containercontextmenu', this.onContainerContextMenu, this);

        this.grid = grid;
    },


    populateDependencyMenu : function (menu) {
        var grid = this.grid,
            taskStore = grid.getTaskStore(),
            dependencies = this.rec.getAllDependencies(),
            depStore = grid.dependencyStore;

        menu.removeAll();

        if (dependencies.length === 0) {
            return false;
        }

        var taskId = this.rec.getId() || this.rec.internalId;

        Ext.each(dependencies, function (dependency) {
            var fromId = dependency.getSourceId(),
                task = taskStore.getById(fromId == taskId ? dependency.getTargetId() : fromId);

            if (task) {
                menu.add({
                    depId : dependency.internalId,
                    text  : Ext.util.Format.ellipsis(Ext.String.htmlEncode(task.getName()), 30),

                    scope   : this,
                    handler : function (menuItem) {
                        // in 4.0.2 `indexOfId` returns the record by the `internalId`
                        // in 4.0.7 `indexOfId` returns the record by its "real" id
                        // so need to manually scan the store to find the record

                        var record;

                        depStore.each(function (dependency) {
                            if (dependency.internalId == menuItem.depId) {
                                record = dependency;
                                return false;
                            }
                        });

                        depStore.remove(record);
                    }
                });
            }
        }, this);
    },


    onDependencyMouseOver : function (menu, item, e) {
        if (item) {
            var schedulingView = this.grid.getSchedulingView();

            if (this.lastHighlightedItem) {
                schedulingView.unhighlightDependency(this.lastHighlightedItem.depId);
            }

            this.lastHighlightedItem = item;

            schedulingView.highlightDependency(item.depId);
        }
    },


    onDependencyMouseOut : function (menu, e) {
        if (this.lastHighlightedItem) {
            this.grid.getSchedulingView().unhighlightDependency(this.lastHighlightedItem.depId);
        }
    },


    cleanUp : function () {
        this.destroy();
    },

    onTaskContextMenu : function (g, record, e) {
        this.activateMenu(record, e);
    },

    onItemContextMenu : function (view, record, item, index, e) {
        this.activateMenu(record, e);
    },

    onContainerContextMenu : function (g, e) {
        this.activateMenu(null, e);
    },

    activateMenu : function (rec, e) {
        // Do not show menu in readonly mode of the gantt chart
        if (this.grid.isReadOnly()) {
            return;
        }

        e.stopEvent();

        this.rec = rec;
        this.configureMenuItems();

        this.showAt(e.getXY());
    },


    configureMenuItems : function () {
        var reqTasks = this.query('[requiresTask]');
        var rec = this.rec;

        Ext.each(reqTasks, function (item) {
            item.setDisabled(!rec);
        });

        var dependenciesItem = this.query('[isDependenciesMenu]')[ 0 ];

        if (rec && dependenciesItem) dependenciesItem.setDisabled(!rec.getAllDependencies().length);

        var toggleMilestone = this.down('#toggleMilestone');

        if (rec && toggleMilestone) {
            toggleMilestone.setText(rec.isMilestone() ? this.L('convertToRegular') : this.L('convertToMilestone'));
        }
    },


    copyTask : function (original) {
        var model = this.grid.getTaskStore().model;

        var newTask = new model({
            leaf : true
        });

        newTask.setPercentDone(0);
        newTask.setName(this.L('newTaskText', this.texts));
        newTask.set(newTask.startDateField, (original && original.getStartDate()) || null);
        newTask.set(newTask.endDateField, (original && original.getEndDate()) || null);
        newTask.set(newTask.durationField, (original && original.getDuration()) || null);
        newTask.set(newTask.durationUnitField, (original && original.getDurationUnit()) || 'd');
        return newTask;
    },


    // Actions follow below
    // ---------------------------------------------

    /**
     * Handler for the "add task above" menu item
     */
    addTaskAbove : function (newTask) {
        var task = this.rec;

        if (task) {
            task.addTaskAbove(newTask);
        } else {
            this.grid.taskStore.getRootNode().appendChild(newTask);
        }
    },

    /**
     * Handler for the "add task below" menu item
     */
    addTaskBelow : function (newTask) {
        var task = this.rec;

        if (task) {
            task.addTaskBelow(newTask);
        } else {
            this.grid.taskStore.getRootNode().appendChild(newTask);
        }
    },

    /**
     * Handler for the "delete task" menu item
     */
    deleteTask : function () {
        var selected = this.grid.getSelectionModel().selected;

        this.grid.taskStore.remove(selected.getRange());
    },

    /**
     * Handler for the "edit left label" menu item
     */
    editLeftLabel : function () {
        this.grid.getSchedulingView().editLeftLabel(this.rec);
    },

    /**
     * Handler for the "edit right label" menu item
     */
    editRightLabel : function () {
        this.grid.getSchedulingView().editRightLabel(this.rec);
    },


    /**
     * Handler for the "add task above" menu item
     */
    addTaskAboveAction : function () {
        this.addTaskAbove(this.copyTask(this.rec));
    },


    /**
     * Handler for the "add task below" menu item
     */
    addTaskBelowAction : function () {
        this.addTaskBelow(this.copyTask(this.rec));
    },


    /**
     * Handler for the "add subtask" menu item
     */
    addSubtask : function () {
        var task = this.rec;
        task.addSubtask(this.copyTask(task));
    },

    /**
     * Handler for the "add successor" menu item
     */
    addSuccessor : function () {
        var task = this.rec;
        task.addSuccessor(this.copyTask(task));
    },

    /**
     * Handler for the "add predecessor" menu item
     */
    addPredecessor : function () {
        var task = this.rec;
        task.addPredecessor(this.copyTask(task));
    },


    /**
     * Handler for the "add milestone" menu item
     */
    addMilestone : function () {
        var task = this.rec,
            newTask = this.copyTask(task);

        task.addTaskBelow(newTask);
        newTask.setStartEndDate(task.getEndDate(), task.getEndDate());
    },

    /**
     * Handler for the "Convert to milestone" menu item
     */
    toggleMilestone : function () {
        if (this.rec.isMilestone()) {
            this.rec.convertToRegular();
        } else {
            this.rec.convertToMilestone();
        }
    }
});

/**
@class Gnt.plugin.Export
@extends Sch.plugin.Export

A plugin (ptype = 'gantt_export') for generating PDF/PNG out of a Gantt panel. NOTE: This plugin will make an Ajax request to the server, POSTing
 the HTML to be exported. The {@link #printServer} url must therefore be on the same domain as your application.

#Configuring/usage

To use this plugin, add it to your Gantt as any other plugin. It is also required to have [PhantomJS][1] and [Imagemagick][2]
installed on the server. The complete process of setting up a backend for this plugin can be found in the readme file inside export examples
as well as on our [blog][3]. Note that export is currently not supported if your view (or store) is buffered.

        var gantt = Ext.create('Sch.panel.Gantt', {
            ...

            plugins         : [
                Ext.create('Gnt.plugin.Export', {
                    // default values
                    printServer: 'server.php'
                })
            ]
        });

Gantt will be extended with three new methods:

* {@link #setFileFormat}, which allows setting the format to which panel should be exported. Default format is `pdf`.

* {@link #showExportDialog}, which shows export settings dialog

        gantt.showExportDialog();

* {@link #doExport} which actually performs the export operation using {@link #defaultConfig} or provided config object :

        gantt.doExport(
            {
                format: "A5",
                orientation: "landscape",
                range: "complete",
                showHeader: true,
                singlePageExport: false
            }
        );

#Export options

In the current state, plugin gives few options to modify the look and feel of the generated document/image throught a dialog window :

{@img scheduler/images/export_dialog.png}

If no changes are made to the form, the {@link #defaultConfig} will be used.

##Export Range

This setting controls the timespan visible on the exported document/image. Three options are available here :

{@img scheduler/images/export_dialog_ranges.png}

###Complete schedule

Whole current timespan will be visible on the exported document.

###Date range

User can select the start and end dates (from the total timespan of the panel) visible on the exported document/image.

{@img scheduler/images/export_dialog_ranges_date.png}

###Current view

Timespan of the exported document will be set to the currently visible part of the time axis. User can control
the width of the time column and height of row.

{@img scheduler/images/export_dialog_ranges_current.png}

##Paper Format

This combo gives control of the size of the generated PDF document by choosing one from a list of supported ISO paper sizes : (`A5`, `A4`, `A3`, `Letter`).
Generated PDF has a fixed DPI value of 72. Dafault format is `A4`.

{@img scheduler/images/export_dialog_format.png}

##Orientation

This setting defines the orientation of the generated document.

{@img scheduler/images/export_dialog_orientation.png}

Default option is the `portrait` (horizontal) orientation :

{@img scheduler/images/export_dialog_portrait.png}

Second option is the `landscape` (vertical) orientation :

{@img scheduler/images/export_dialog_landscape.png}

[1]: http://www.phantomjs.org
[2]: http://www.imagemagick.org
[3]: http://bryntum.com/blog

*/
Ext.define('Gnt.plugin.Export', {
    extend              : 'Sch.plugin.Export',

    alias               : 'plugin.gantt_export',
    alternateClassName  : 'Gnt.plugin.PdfExport',

    //override added to turn off vertical resizer in the dialog
    showExportDialog    : function() {
        this.exportDialogConfig.scrollerDisabled = true;

        this.callParent(arguments);
    },

    /*
    * @private
    * Method exporting panel's HTML to JSON structure. This function is taking snapshots of the visible panel (by changing timespan
    * and hiding rows) and pushing their html to an array, which is then encoded to JSON. Additionally it re-renders dependencies div.
    *
    * @param {Object} calculatedPages Object with values returned from {@link #calculatePages}.
    * @param {Object} params Object with additional properties needed for calculations.
    *
    * @return {Array} htmlArray JSON string created from an array of objects with stringified html.
    */
    getExportJsonHtml   : function (calculatedPages, params) {
        var ganttView       = this.scheduler.getSchedulingView(),
            depView         = ganttView.dependencyView,
            tplData         = depView.painter.getDependencyTplData(ganttView.dependencyStore.getRange()),
            dependencies    = depView.lineTpl.apply(tplData),
            config          = params.config,
            panelHTML;

        if (!config.singlePageExport) {
            panelHTML       = {
                dependencies        : dependencies,
                rowsAmount          : calculatedPages.rowsAmount,
                columnsAmountNormal : calculatedPages.columnsAmountNormal,
                columnsAmountLocked : calculatedPages.columnsAmountLocked,
                timeColumnWidth     : calculatedPages.timeColumnWidth,
                lockedGridWidth     : calculatedPages.lockedGridWidth,
                rowHeight           : calculatedPages.rowHeight
            };
        } else {
            calculatedPages = {};

            panelHTML       = {
                dependencies        : dependencies,
                singlePageExport    : true
            };
        }

        panelHTML.lockedColumnPages = calculatedPages.lockedColumnPages;
        calculatedPages.panelHTML   = panelHTML;

        return this.callParent(arguments);
    },

    /*
    * @private
    * Function returning full width and height of both grids.
    *
    * @return {Object} values Object containing width and height properties.
    */
    getRealSize : function(){
        var realSize = this.callParent(arguments);

        realSize.width += this.scheduler.down('splitter').getWidth();

        return realSize;
    },

    /*
    * @private
    * Resizes panel elements to fit on the print page. This has to be done manually in case of wrapping Gantt
    * inside another, smaller component. This function also adds dependencies to the output html.
    */
    resizePanelHTML : function (HTML) {
        var frag             = this.callParent(arguments),
            normalRowsDeps   = frag.select('.sch-dependencyview-ct').first(),
            splitterHTML     = frag.select('.' + Ext.baseCSSPrefix + 'splitter').first(),
            left             = 0,
            top              = 0,
            lockedColumnsLen, i;

        // if we have skipped ticks before first visible one then we will shift left coordinate of dependencies
        left = HTML.skippedColsBefore * HTML.timeColumnWidth;

        // for multiple pages mode
        if (!HTML.singlePageExport) {
            top                 = HTML.k * HTML.rowsAmount * HTML.rowHeight;
            lockedColumnsLen    = HTML.lockedColumnPages ? HTML.lockedColumnPages.length : 0;
            // column page num
            i                   = HTML.i;

            if (lockedColumnsLen) {
                if (i >= lockedColumnsLen - 1) {

                    var noColumnsCounter = i - lockedColumnsLen + 1;

                    left += (noColumnsCounter === lockedColumnsLen - 1) ? HTML.timeColumnWidth * HTML.columnsAmountLocked :
                        HTML.timeColumnWidth * HTML.columnsAmountLocked + (noColumnsCounter - 1) * HTML.timeColumnWidth * HTML.columnsAmountNormal;

                } else {
                    splitterHTML.hide();
                }
            } else {
                // for pages except very first one we calculate left shift (to apply to dependency view)
                if (i) {
                    left += (i - 1) * HTML.timeColumnWidth * HTML.columnsAmountNormal + HTML.timeColumnWidth * HTML.columnsAmountLocked;
                }
            }
        }

        normalRowsDeps.dom.innerHTML = HTML.dependencies;

        //move the dependencies div to match the position of the dependency lines
        normalRowsDeps.applyStyles({
            top     : -top + 'px',
            left    : -left + 'px'
        });

        splitterHTML.setHeight('100%');

        return frag;
    }
});

/**
@class Gnt.plugin.Printable
@extends Sch.plugin.Printable

A plugin (ptype = 'gantt_printable') for printing the content of an Ext Gantt panel. Please note that this will not generate a picture perfect
 printed version, due to various limitations in the browser print implementations. If you require a high quality print, you should use the Export plugin instead and first export to PDF.

You can add it to your gantt chart like any other plugin and it will add a new method `print` to the gantt panel itself:

    var gantt = Ext.create('Gnt.panel.Gantt', {
    
        plugins             : [
            Ext.create("Gnt.plugin.Printable")
        ],
        ...
    })

    gantt.print();

*/
Ext.define("Gnt.plugin.Printable", {
    extend : "Sch.plugin.Printable",
    alias  : 'plugin.gantt_printable',

    getGridContent : function(gantt) {
        var ganttView  = gantt.getSchedulingView();

        ganttView._print = true;

        var retVal     = this.callParent(arguments),
            depView    = ganttView.dependencyView,
            tplData    = depView.painter.getDependencyTplData(ganttView.dependencyStore.getRange()),
            depHtml    = '<div class="' + depView.containerEl.dom.className + '">' + depView.lineTpl.apply(tplData) + '</div>',
            normalRows = retVal.normalRows;

        //highlight critical path
        if (Ext.select('.sch-gantt-critical-chain').first()){
            var el = Ext.DomHelper.createDom({
                tag     : 'div',
                html    : depHtml
            });
            el = Ext.get(el);

            var elRows = Ext.DomHelper.createDom({
                tag: 'div',
                html: normalRows
            });
            elRows = Ext.get(elRows);

            var paths = ganttView.getCriticalPaths(),
                ds = ganttView.dependencyStore,
                t,i,l, depRecord;

            //Simplified critical path highlighting
            Ext.each(paths, function(tasks) {
                for (i = 0, l = tasks.length; i < l; i++) {
                    t = tasks[i];
                    this.highlightTask(t, gantt, elRows);

                    if (i < (l - 1)) {
                        depRecord = ds.getAt(ds.findBy(function(dep) {
                            return dep.getTargetId() === (t.getId() || t.internalId) && dep.getSourceId() === (tasks[i+1].getId() || tasks[i+1].internalId);
                        }));
                        this.highlightDependency(depRecord, el, depView);
                    }
                }
            }, this);

            normalRows = elRows.getHTML();
            depHtml = el.getHTML();
        }

        retVal.normalRows = depHtml + normalRows;

        delete ganttView._print;

        return retVal;
    },

    highlightTask: function(task, gantt, containerEl){
        var el = gantt.getSchedulingView().getElementFromEventRecord(task),
            elId = el.id;

            if (el) {
                containerEl.select('#'+elId).first().parent('tr').addCls('sch-gantt-task-highlighted');
            }
    },

    highlightDependency: function(rec, containerEl, depView){
        var id = rec instanceof Ext.data.Model ? rec.internalId : rec;

        return containerEl.select('.sch-dep-' + id).addCls(depView.selectedCls);
    }
});
/*
 * @class Gnt.view.DependencyPainter
 * @extends Ext.util.Observable
 * @private
 * Internal class handling the drawing of inter-task dependencies.
 */
Ext.define("Gnt.view.DependencyPainter", {

    ganttView       : null,
    rowHeight       : null,
    topArrowOffset  : 8,
    arrowOffset     : 8,
    lineWidth       : 2,
    xOffset         : 6,

    constructor: function (cfg) {
        cfg = cfg || {};

        Ext.apply(this, cfg);
    },

    setRowHeight : function(height) {
        this.rowHeight = height;
    },

    getTaskBox: function (task) {
        var DT          = Sch.util.Date,
            taskStart   = task.getStartDate(),
            taskEnd     = task.getEndDate(),
            view        = this.ganttView,
            isBuffered  = view.bufferedRenderer,
            viewStart   = view.timeAxis.getStart(),
            viewEnd     = view.timeAxis.getEnd();

        // Assure task is:
        //      - not filtered out
        //      - not inside a collapsed parent task
        //      - scheduled
        //      - intersecting current view date range
        if (!task.isVisible() ||
            !taskStart ||
            !taskEnd ||
            !DT.intersectSpans(taskStart, taskEnd, viewStart, viewEnd) ||
            (!isBuffered && view.store.indexOf(task) < 0)) {
            return null;
        }

        var offsets,
            start       = view.getXFromDate(DT.max(taskStart, viewStart)),
            end         = view.getXFromDate(DT.min(taskEnd, viewEnd)),
            rowNode     = view.getNodeByRecord(task);

        if (rowNode || isBuffered) {
            var xOffset         = view.getXOffset(task),
                top, bottom,
                isMilestone     = task.isMilestone(),
                rendered        = true;

            if (start > xOffset) {
                start -= xOffset;
            }
            end += xOffset;

            //fix dependency arrows drawn inside of task in IE<8
            if(!isMilestone && Ext.isIE){
                if ((Ext.isIE6 || Ext.isIE7 || Ext.isIE8) && Ext.isIEQuirks){
                    end += 1;
                    start -= 2;
                }
            }

            var viewEl          = view.el;
            var viewElScrollTop = viewEl.getScroll().top;

            if (rowNode) {
                var eventNode = view.getEventNodeByRecord(task);
                offsets     = Ext.fly(eventNode).getOffsetsTo(viewEl);
                top         = offsets[1] + viewElScrollTop + (isMilestone && Ext.isIE8 ? 3 : 0);
                bottom      = top + Ext.fly(eventNode).getHeight();

                if (isMilestone) {
                    end       +=1;
                }
            } else {
                // View is buffered, and task element is not in DOM - try to project a reasonable box
                var nodes           = view.all.elements;
                var firstInView     = view.store.getAt(view.all.startIndex);

                if (task.isAbove(firstInView)) {
                    rowNode     = nodes[view.all.startIndex];
                    offsets     = Ext.fly(rowNode).getOffsetsTo(viewEl);
                    offsets[1]  -= view.rowHeight;     // Make sure it's off screen
                } else {
                    rowNode     = nodes[view.all.endIndex];
                    offsets     = Ext.fly(rowNode).getOffsetsTo(viewEl);
                    offsets[1]  += view.rowHeight;     // Make sure it's off screen
                }

                top     = offsets[1] + viewElScrollTop;
                bottom  = top + this.rowHeight;

                rendered = false;
            }

            return {
                top         : top,
                end         : end,
                bottom      : bottom,
                start       : start,
                rendered    : rendered
            };
        }
    },

    getRenderData : function(dependency) {
        var fromTask = dependency.getSourceTask(),
            toTask = dependency.getTargetTask();

        if (!fromTask || !toTask) return null;

        var fromBox = this.getTaskBox(fromTask);
        var toBox = this.getTaskBox(toTask);
        var view = this.ganttView;

        if (view.bufferRender && fromBox && !fromBox.rendered && toBox && !toBox.rendered) {

            // Make sure the path between the tasks intersect current table chunk
            var firstInView    = view.store.getAt(view.all.startIndex);
            var lastInView     = view.store.getAt(view.all.endIndex);

            if ((fromTask.isAbove(firstInView) && toTask.isAbove(firstInView)) ||
                (lastInView.isAbove(fromTask) && lastInView.isAbove(toTask)))
            {
                return null;
            }
        }

        return {
            fromBox : fromBox,
            toBox   : toBox
        };
    },

    getDependencyTplData: function (dependencyRecords) {
        var me = this,
            view = me.ganttView;

        // Normalize input
        if (dependencyRecords instanceof Ext.data.Model) {
            dependencyRecords = [dependencyRecords];
        }

        if (dependencyRecords.length === 0 || view.store.getCount() === 0) {
            return;
        }

        var depData = [],
            coords, fromTask, toTask, fromBox, toBox, dependency;

        for (var i = 0, l = dependencyRecords.length; i < l; i++) {
            dependency = dependencyRecords[i];

            var data = this.getRenderData(dependency);

            if (data) {
                fromBox = data.fromBox;
                toBox = data.toBox;

                if (fromBox && toBox) {
                    coords = me.getLineCoordinates(fromBox, toBox, dependency);

                    if (coords) {
                        depData.push({
                            dependency      : dependency,
                            id              : dependency.internalId,
                            cls             : dependency.getCls(),
                            lineCoordinates : coords
                        });
                    }
                }
            }
        }

        return depData;
    },

    getLineCoordinates: function (fromBox, toBox, dependency) {
        var startSide, endSide,
            startXY     = [0, fromBox.top - 1 + ((fromBox.bottom - fromBox.top) / 2)],
            endXY       = [0, toBox.top - 1 + ((toBox.bottom - toBox.top) / 2)],
            targetBelow = endXY[1] > startXY[1],
            DepType     = Gnt.model.Dependency.Type,
            offset      = this.arrowOffset + this.xOffset,
            type        = dependency.getType(),
            coords      = [],
            isMilestone = dependency.getTargetTask().isMilestone(),
            xPoint, targetX, turningPointY;

        switch (type) {
            case DepType.StartToEnd:
                startXY[0]  = fromBox.start;
                endXY[0]    = toBox.end + offset;
                startSide = 'l';
                endSide = 'r';
                break;

            case DepType.StartToStart:
                startXY[0]  = fromBox.start;
                endXY[0]    = toBox.start - offset;
                startSide = 'l';
                endSide = 'l';
                break;

            case DepType.EndToStart:
                startXY[0]  = fromBox.end;
                endXY[0]    = toBox.start - offset;
                startSide = 'r';
                endSide = 'l';
                break;

            case DepType.EndToEnd:
                startXY[0]  = fromBox.end;
                endXY[0]    = toBox.end + offset;
                startSide = 'r';
                endSide = 'r';
                break;

            default:
                throw 'Invalid dependency type: ' + dependency.getType();
        }

        coords.push(startXY);

        var x2 = startXY[0] + (startSide === 'r' ? this.xOffset : -this.xOffset);

        if (targetBelow && type === DepType.EndToStart && fromBox.end < (toBox.start + 5)) {
            // 2 lines
            xPoint = Math.min(toBox.start + this.xOffset, toBox.end);

            coords.push([ xPoint, startXY[1] ]);
            coords.push([ xPoint, toBox.top - this.arrowOffset - (isMilestone ? 2 : 0) ]);
        }
        else if (startSide !== endSide && ((startSide === 'r' && x2 > endXY[0]) || (startSide === 'l' && x2 < endXY[0]))) {
            // 5 lines
            targetX = toBox[endSide === 'l' ? 'start' : 'end'];
            turningPointY = endXY[1] + (targetBelow ? -1 : 1) * (this.rowHeight / 2);

            coords.push([ x2, startXY[1] ]);
            coords.push([ x2, turningPointY ]);
            coords.push([ endXY[0], turningPointY ]);
            coords.push(endXY);

            coords.push([targetX + (endXY[0] < targetX ? -this.arrowOffset : this.arrowOffset) - (isMilestone && endSide === 'l'? 2 : 0), endXY[1]]);
        } else {
            // 3 lines
            targetX = toBox[endSide === 'l' ? 'start' : 'end'];

            if (startSide === 'r') {
                xPoint = Math.max(x2, endXY[0]);
            } else {
                xPoint = Math.min(x2, endXY[0]);
            }
            coords.push([ xPoint, startXY[1]]);
            coords.push([ xPoint, endXY[1]]);

            coords.push([targetX + (xPoint < targetX ? -this.arrowOffset : this.arrowOffset) - (isMilestone && endSide === 'l' ? 2 : 0), endXY[1]]);
        }

        var lineCoords = [];

        for (var i = 0; i < coords.length - 1; i++) {
            lineCoords.push({
                x1 : coords[i][0],
                y1 : coords[i][1],
                x2 : coords[i+1][0],
                y2 : coords[i+1][1]
            });
        }

        return lineCoords;
    }
});

/*
 * @class Gnt.view.Dependency
 * @extends Ext.util.Observable
 * @private
 * Internal class handling the dependency related functionality.
 */
Ext.define("Gnt.view.Dependency", {
    extend      : "Ext.util.Observable",

    requires    : [
        'Gnt.feature.DependencyDragDrop',
        'Gnt.view.DependencyPainter'
    ],

    /**
     * @cfg {Int} lineWidth
     * The number of pixels for the line width (supported values are 1 or 2 pixels), defaults to 1.
     */
    lineWidth       : 1,

    /**
     * @cfg {Object} dragZoneConfig
     * A custom config object to pass on to configure the Ext.dd.DragZone instance used when creating new dependencies
     */
    dragZoneConfig  : null,

    /**
     * @cfg {Object} dropZoneConfig
     * A custom config object to pass on to configure the Ext.dd.DropZone instance used when creating new dependencies
     */
    dropZoneConfig  : null,

    containerEl     : null,
    ganttView       : null,
    painter         : null,
    taskStore       : null,
    store           : null,
    dnd             : null,
    lineTpl         : null,


    enableDependencyDragDrop    : true,

    renderAllDepsBuffered       : false,

    dependencyCls               : 'sch-dependency',
    selectedCls                 : 'sch-dependency-selected',

    dependencyPainterClass      : "Gnt.view.DependencyPainter",

    // private
    constructor: function (cfg) {
        this.callParent(arguments);

        var ganttView = this.ganttView;

        ganttView.on({
            refresh         : this.renderAllDependenciesBuffered,
            bufferedrefresh : this.renderAllDependenciesBuffered,
            itemupdate      : this.onTaskUpdated,

            scope           : this
        });

        this.bindTaskStore(ganttView.getTaskStore());
        this.bindDependencyStore(cfg.store);

        if (!this.lineTpl) {
            var rtl = this.rtl;
            var side = rtl ? 'right' : 'left';

            this.lineTpl = Ext.create("Ext.XTemplate",
                '<tpl for=".">' +
                    Ext.String.format(
                        '<tpl for="lineCoordinates">' +
                            // lineCls can be used to style the dependency lines
                            '<div class="{0} {[ parent.dependency.isHighlighted ? "{1}" : "" ]} {[values.x1==values.x2 ? "sch-dependency-line-v" : "sch-dependency-line-h"]} {lineCls} sch-dep-{parent.id} {0}-line {[this.getSuffixedCls(parent.cls, "-line")]}" ' +
                            'style="' + side + ':{[Math.min(values.x1, values.x2)]}px;top:{[Math.min(values.y1, values.y2)]}px;' +
                            'width:{[Math.abs(values.x1-values.x2)+' + this.lineWidth + ']}px;' +
                            'height:{[Math.abs(values.y1-values.y2)+' + this.lineWidth + ']}px">' +
                            '</div>' +
                        '</tpl>' +
                        '<div style="' + side + ':{[values.lineCoordinates[values.lineCoordinates.length - 1].x2]}px;top:{[values.lineCoordinates[values.lineCoordinates.length - 1].y2]}px" ' +
                            '   class="{0}-arrow-ct {0} {[ values.dependency.isHighlighted ? "{1}" : "" ]} sch-dep-{id} {[this.getSuffixedCls(values.cls, "-arrow-ct")]}">' +
                            '<img src="' + Ext.BLANK_IMAGE_URL + '" class="{0}-arrow {0}-arrow-{[this.getArrowDirection(values.lineCoordinates)]} {[this.getSuffixedCls(values.cls, "-arrow")]}" />' +
                        '</div>',
                        this.dependencyCls,
                        this.selectedCls
                    ) +
                '</tpl>',
                {
                    compiled: true,
                    disableFormats : true,
                    getArrowDirection: function (coords) {
                        var lastXY = coords[coords.length - 1];

                        if (lastXY.y2 < lastXY.y1) return 'up';

                        if (lastXY.x1 === lastXY.x2) {
                            return 'down';
                        } else if ((!rtl && lastXY.x1 > lastXY.x2) || (rtl && lastXY.x1 < lastXY.x2)) {
                            return 'left';
                        } else {
                            return 'right';
                        }
                    },

                    getSuffixedCls : function (cls, suffix) {
                        if (cls && cls.indexOf(' ') != -1)
                            return cls.replace(/^\s*(.*)\s*$/, '$1').split(/\s+/).join(suffix + ' ') + suffix;
                        else
                            return cls + suffix;
                    }
                }
            );
        }

        this.painter = Ext.create(this.dependencyPainterClass, Ext.apply({
            rowHeight   : ganttView.rowHeight,
            ganttView   : ganttView
        }, cfg));

        this.addEvents(
            /**
             * @event beforednd
             * Fires before a drag and drop operation is initiated, return false to cancel it
             * @param {Gnt.view.Dependency} dm the dependency manager instance
             * @param {HTMLNode} node The node that's about to be dragged
             * @param {Ext.EventObject} e The event object
             */
            'beforednd',

            /**
             * @event dndstart
             * Fires when a dependency drag and drop operation starts
             * @param {Gnt.view.Dependency} dm the dependency manager instance
             */
            'dndstart',

            /**
             * @event drop
             * Fires after a drop has been made on a receiving terminal
             * @param {Gnt.view.Dependency} dm the dependency manager instance
             * @param {Mixed} fromId The source dependency record id
             * @param {Mixed} toId The target dependency record id
             * @param {Int} type The dependency type, see sch.dependencymanager.js for more information
             */
            'drop',

            /**
             * @event afterdnd
             * Always fires after a dependency drag and drop operation
             * @param {Gnt.view.Dependency} dm the dependency manager instance
             */
            'afterdnd',

            /**
             * @event beforecascade
             * Fires before a cascade operation is initiated
             * @param {Gnt.view.Dependency} dm the dependency manager instance
             */
            'beforecascade',

            /**
             * @event cascade
             * Fires when after a cascade operation has completed
             * @param {Gnt.view.Dependency} dm the dependency manager instance
             */
            'cascade',

            /**
             * @event dependencyclick
             * Fires after clicking on a dependency line/arrow
             * @param {Gnt.view.Dependency} g The view instance
             * @param {Gnt.model.Dependency} record The dependency record
             * @param {Ext.EventObject} event The event object
             * @param {HTMLElement} target The clicked DOM element
             */
            'dependencyclick',

            /**
             * @event dependencycontextmenu
             * Fires after right clicking on a dependency line/arrow
             * @param {Gnt.view.Dependency} g The view instance
             * @param {Gnt.model.Dependency} record The dependency record
             * @param {Ext.EventObject} event The event object
             * @param {HTMLElement} target The clicked DOM element
             */
            'dependencycontextmenu',

            /**
             * @event dependencydblclick
             * Fires after double clicking on a dependency line/arrow
             * @param {Gnt.view.Dependency} g The view instance
             * @param {Gnt.model.Dependency} record The dependency record
             * @param {Ext.EventObject} event The event object
             * @param {HTMLElement} target The clicked DOM element
             */
            'dependencydblclick',

            /**
             * @event refresh
             * Fires after the view has fully rendered all the dependencies in the underlying store
             * @param {Gnt.view.Dependency} g The dependency view instance
             */
            'refresh'
        );

        if (this.enableDependencyDragDrop) {
            this.dnd = Ext.create("Gnt.feature.DependencyDragDrop", {
                el              : ganttView.getEl(),
                rtl             : ganttView.rtl,
                ganttView       : ganttView,
                dragZoneConfig  : this.dragZoneConfig,
                dropZoneConfig  : this.dropZoneConfig,
                dependencyStore : this.store
            });

            this.dnd.on('drop', this.onDependencyDrop, this);
            this.relayEvents(this.dnd, ['beforednd', 'dndstart', 'afterdnd', 'drop']);
        }

        // Setup our own container element
        this.containerEl = this.containerEl.createChild({
            cls : 'sch-dependencyview-ct ' + (this.lineWidth === 1 ? ' sch-dependencyview-thin ' : '')
        });

        this.ganttView.mon(this.containerEl, {
            dblclick    : this.onDependencyClick,
            click       : this.onDependencyClick,
            contextmenu : this.onDependencyClick,
            scope       : this,
            delegate    : '.' + this.dependencyCls
        });

        if (ganttView.rendered) {
            this.renderAllDependenciesBuffered();
        }
    },

    bindDependencyStore : function (store) {
        this.depStoreListeners = {
            // For filtering, server write etc
            refresh         : this.renderAllDependenciesBuffered,
            clear           : this.renderAllDependenciesBuffered,

            load            : this.renderAllDependenciesBuffered,

            add             : this.onDependencyAdd,
            update          : this.onDependencyUpdate,
            remove          : this.onDependencyDelete,

            scope           : this
        };

        store.on(this.depStoreListeners);

        this.store = store;
    },

    unBindDependencyStore : function () {
        if (this.depStoreListeners) {
            this.store.un(this.depStoreListeners);
        }
    },

    bindTaskStore : function (taskStore) {
        var ganttView       = this.ganttView;

        this.taskStoreListeners = {
            cascade             : this.onTaskStoreCascade,

            beforefill          : this.onRootFillStart,

            remove              : this.renderAllDependenciesBuffered,
            insert              : this.renderAllDependenciesBuffered,
            append              : this.renderAllDependenciesBuffered,
            move                : this.renderAllDependenciesBuffered,

            sort                : this.renderAllDependenciesBuffered,

            scope               : this
        };

        Ext.apply(this.taskStoreListeners, {
            expand          : this.renderAllDependenciesBuffered,
            collapse        : this.renderAllDependenciesBuffered
        });

        taskStore.on(this.taskStoreListeners);

        this.taskStore = taskStore;
    },

    onTaskStoreCascade : function(store, cascadeContext) {
        if (cascadeContext && cascadeContext.nbrAffected > 0) {
            this.renderAllDependenciesBuffered();
        }
    },

    unBindTaskStore : function (taskStore) {
        taskStore       = taskStore || this.taskStore;

        if (!taskStore) return;

        if (this.ganttViewListeners) {
            this.ganttView.un(this.ganttViewListeners);
        }

        taskStore.un(this.taskStoreListeners);
    },

    onRootFillStart : function() {
        var store = this.taskStore;

        this.unBindTaskStore(store);

        this.taskStore.on('fillcomplete', function() { this.bindTaskStore(store); }, this, { single : true });
    },

    onDependencyClick : function(e, t) {
        var rec = this.getRecordForDependencyEl(t);
        this.fireEvent('dependency' + e.type, this, rec, e, t);
    },

    /**
     * Highlight the elements representing a particular dependency
     * @param {Mixed} record Either the id of a record or a record in the dependency store
     */
    highlightDependency: function (record) {
        if (!(record instanceof Ext.data.Model)) {
            record = this.getDependencyRecordByInternalId(record);
        }

        if (record) {
            record.isHighlighted    = true;

            this.getElementsForDependency(record).addCls(this.selectedCls);
        }
    },


    /**
     * Remove highlight of the elements representing a particular dependency
     * @param {Mixed} record Either the id of a record or a record in the dependency store
     */
    unhighlightDependency: function (record) {
        if (!(record instanceof Ext.data.Model)) {
            record = this.getDependencyRecordByInternalId(record);
        }

        if (record) {
            record.isHighlighted    = false;

            this.getElementsForDependency(record).removeCls(this.selectedCls);
        }
    },


    /**
     * Retrieve the elements representing a particular dependency
     * @param {Record} rec the record in the dependency store
     * @return {CompositeElementLite/CompositeElement}
     */
    getElementsForDependency: function (rec) {
        var id = rec instanceof Ext.data.Model ? rec.internalId : rec;
        return this.containerEl.select('.sch-dep-' + id);
    },

    // private
    depRe: new RegExp('sch-dep-([^\\s]+)'),


    getDependencyRecordByInternalId : function(id) {
        var r, i, l;

        for (i = 0, l = this.store.getCount(); i < l; i++) {
            r = this.store.getAt(i);
            if (r.internalId == id) {
                return r;
            }
        }
        return null;
    },

    // private
    getRecordForDependencyEl: function (t) {
        var m = t.className.match(this.depRe),
            rec = null;

        if (m && m[1]) {
            var recordId = m[1];

            rec = this.getDependencyRecordByInternalId(recordId);
        }

        return rec;
    },


    renderAllDependenciesBuffered : function () {
        var me = this;

        this.containerEl.update('');

        setTimeout(function () {
            if (!me.ganttView.isDestroyed) me.renderAllDependencies();
        }, 0);
    },

    /**
     * Renders all the dependencies for the current view
     */
    renderAllDependencies : function() {

        // component has been destroyed already
        if (!this.containerEl.dom) return;

        this.containerEl.update('');
        this.renderDependencies(this.store.data.items);
        this.fireEvent('refresh', this);
    },

    /**
     * Returns all the elements representing the rendered dependencies
     * @return {CompositeElement}
     */
    getDependencyElements : function() {
        return this.containerEl.select('.' + this.dependencyCls);
    },

    renderDependencies: function (dependencyRecords) {
        if (dependencyRecords){
            var tplData = this.painter.getDependencyTplData(dependencyRecords);
            this.lineTpl[Ext.isIE ? "insertFirst" : "append"](this.containerEl, tplData);
        }
    },


    renderTaskDependencies: function (tasks) {
        var toDraw  = [];

        if (tasks instanceof Ext.data.Model) {
            tasks = [tasks];
        }

        for (var i = 0, n = tasks.length; i < n; i++) {
            toDraw = toDraw.concat(tasks[i].getAllDependencies());
        }
        this.renderDependencies(toDraw);
    },

    onDependencyUpdate: function (store, depRecord) {
        this.removeDependencyElements(depRecord, false);

        // Draw new dependencies for the event
        this.renderDependencies(depRecord);
    },



    onDependencyAdd: function (store, depRecords) {
        // Draw added dependencies
        this.renderDependencies(depRecords);
    },

    removeDependencyElements: function (record, animate) {
        if (animate !== false) {
            this.getElementsForDependency(record).fadeOut({ remove: true });
        } else {
            this.getElementsForDependency(record).remove();
        }
    },

    onDependencyDelete: function (store, depRecord) {
        this.removeDependencyElements(depRecord);
    },

    dimEventDependencies: function (eventId) {
        this.containerEl.select(this.depRe + eventId).setOpacity(0.2);
    },

    // private
    clearSelectedDependencies : function() {
        this.containerEl.select('.' + this.selectedCls).removeCls(this.selectedCls);

        this.store.each(function (dependency) {
            dependency.isHighlighted    = false;
        });
    },


    onTaskUpdated: function (task) {
        if (!this.taskStore.cascading && (!task.previous || task.startDateField in task.previous || task.endDateField in task.previous)) {
            this.updateDependencies(task);
        }
    },


    updateDependencies: function (tasks) {
        if (tasks instanceof Ext.data.Model) {
            tasks = [ tasks ];
        }

        var me      = this;

        Ext.each(tasks, function (task) {
            Ext.each(task.getAllDependencies(), function (dependency) {
                me.removeDependencyElements(dependency, false);
            });
        });

        // Draw new dependencies for the task
        this.renderTaskDependencies(tasks);
    },


    onNewDependencyCreated : function () {
    },


    onDependencyDrop: function (plugin, fromId, toId, type) {
        var dependencyStore = this.store;

        var newDependency = new dependencyStore.model({
            fromTask    : fromId,
            toTask      : toId,
            type        : type
        });

        if (dependencyStore.isValidDependency(newDependency) && this.onNewDependencyCreated(newDependency) !== false) {
            dependencyStore.add(newDependency);
        }
    },

    destroy: function () {
        if (this.dnd) {
            this.dnd.destroy();
        }

        this.unBindTaskStore();

        this.unBindDependencyStore();
    },

    setRowHeight : function(height, preventRefresh) {
        this.rowHeight = height;
        this.painter.setRowHeight(height);

        if (!preventRefresh) {
            this.renderAllDependencies();
        }
    }
});

/**

@class Gnt.view.Gantt
@extends Sch.view.TimelineGridView

A view of the gantt panel. Use the {@link Gnt.panel.Gantt#getSchedulingView} method to get its instance from gantt panel.

*/
Ext.define("Gnt.view.Gantt", {
    extend : "Sch.view.TimelineGridView",

    alias : ['widget.ganttview'],

    requires : [
        'Ext.dd.ScrollManager',
        'Gnt.view.Dependency',
        'Gnt.model.Task',
        'Gnt.template.Task',
        'Gnt.template.ParentTask',
        'Gnt.template.Milestone',
        'Gnt.feature.TaskDragDrop',
        'Gnt.feature.ProgressBarResize',
        'Gnt.feature.TaskResize',
        'Sch.view.Horizontal'
    ],

    uses : [
        'Gnt.feature.LabelEditor',
        'Gnt.feature.DragCreator'
    ],

    mixins : [
        'Sch.mixin.FilterableTreeView'
    ],

    _cmpCls : 'sch-ganttview',

    barMargin : 4,

    scheduledEventName : 'task',

    trackOver        : false,
    toggleOnDblClick : false,

    // Number of pixels to offset a milestone diamond
    milestoneOffset  : 11,

    // Number of pixels to offset a parent task
    parentTaskOffset : 6,

    // private
    eventSelector    : '.sch-gantt-item',

    eventWrapSelector : '.sch-event-wrap',


    progressBarResizer : null,
    taskResizer        : null,
    taskDragDrop       : null,
    dragCreator        : null,
    dependencyView     : null,

    resizeConfig            : null,
    createConfig            : null,
    dragDropConfig          : null,
    progressBarResizeConfig : null,

    dependencyViewConfig : null,

    externalGetRowClass : null,


    constructor : function (config) {
        config = config || {};

        if (config) {
            this.externalGetRowClass = config.getRowClass;

            delete config.getRowClass;
        }

        this.addEvents(
            // Task click-events --------------------------
            /**
             * @event taskclick
             * Fires when a task is clicked
             *
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Gnt.model.Task} taskRecord The task record
             * @param {Ext.EventObject} e The event object
             */
            'taskclick',

            /**
             * @event taskdblclick
             * Fires when a task is double clicked
             *
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Gnt.model.Task} taskRecord The task record
             * @param {Ext.EventObject} e The event object
             */
            'taskdblclick',

            /**
             * @event taskcontextmenu
             * Fires when contextmenu is activated on a task
             *
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Gnt.model.Task} taskRecord The task record
             * @param {Ext.EventObject} e The event object
             */
            'taskcontextmenu',


            // Resizing events start --------------------------
            /**
             * @event beforetaskresize
             * Fires before a resize starts, return false to stop the execution
             *
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Gnt.model.Task} taskRecord The task about to be resized
             * @param {Ext.EventObject} e The event object
             */
            'beforetaskresize',

            /**
             * @event taskresizestart
             * Fires when resize starts
             *
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Gnt.model.Task} taskRecord The task about to be resized
             */
            'taskresizestart',

            /**
             * @event partialtaskresize
             * Fires during a resize operation and provides information about the current start and end of the resized event
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             *
             * @param {Gnt.model.Task} taskRecord The task being resized
             * @param {Date} startDate The start date of the task
             * @param {Date} endDate The end date of the task
             * @param {Ext.Element} The element being resized
             */
            'partialtaskresize',

            /**
             * @event aftertaskresize
             * Fires after a succesful resize operation
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Gnt.model.Task} taskRecord The task that has been resized
             */
            'aftertaskresize',


            // Task progress bar resizing events start --------------------------
            /**
             * @event beforeprogressbarresize
             * Fires before a progress bar resize starts, return false to stop the execution
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Gnt.model.Task} taskRecord The record about to be have its progress bar resized
             */
            'beforeprogressbarresize',

            /**
             * @event progressbarresizestart
             * Fires when a progress bar resize starts
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Gnt.model.Task} taskRecord The record about to be have its progress bar resized
             */
            'progressbarresizestart',

            /**
             * @event afterprogressbarresize
             * Fires after a succesful progress bar resize operation
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Gnt.model.Task} taskRecord record The updated record
             */
            'afterprogressbarresize',


            // Dnd events start --------------------------
            /**
             * @event beforetaskdrag
             * Fires before a task drag drop is initiated, return false to cancel it
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Gnt.model.Task} taskRecord The task record that's about to be dragged
             * @param {Ext.EventObject} e The event object
             */
            'beforetaskdrag',

            /**
             * @event taskdragstart
             * Fires when a dnd operation starts
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Gnt.model.Task} taskRecord The record being dragged
             */
            'taskdragstart',

            /**
             * @event taskdrop
             * Fires after a succesful drag and drop operation
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Gnt.model.Task} taskRecord The dropped record
             */
            'taskdrop',

            /**
             * @event aftertaskdrop
             * Fires after a drag and drop operation, regardless if the drop valid or invalid
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             */
            'aftertaskdrop',


            // Label editors events --------------------------
            /**
             * @event labeledit_beforestartedit
             * Fires before editing is started for a field
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Gnt.model.Task} taskRecord The task record
             */
            'labeledit_beforestartedit',

            /**
             * @event labeledit_beforecomplete
             * Fires after a change has been made to a label field, but before the change is reflected in the underlying field.
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Mixed} value The current field value
             * @param {Mixed} startValue The original field value
             * @param {Gnt.model.Task} taskRecord The affected record
             */
            'labeledit_beforecomplete',

            /**
             * @event labeledit_complete
             * Fires after editing is complete and any changed value has been written to the underlying field.
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Mixed} value The current field value
             * @param {Mixed} startValue The original field value
             * @param {Gnt.model.Task} taskRecord The affected record
             */
            'labeledit_complete',


            // Dependencies events--------------------------
            /**
             * @event beforedependencydrag
             * Fires before a dependency drag operation starts (from a "task terminal"). Return false to prevent this operation from starting.
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Gnt.model.Task} taskRecord The source task record
             */
            'beforedependencydrag',

            /**
             * @event dependencydragstart
             * Fires when a dependency drag operation starts
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             */
            'dependencydragstart',

            /**
             * @event dependencydrop
             * Fires when a dependency drag drop operation has completed successfully and a new dependency has been created.
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Gnt.model.Task} fromRecord The source task record
             * @param {Gnt.model.Task} toRecord The destination task record
             * @param {Int} type The dependency type
             */
            'dependencydrop',

            /**
             * @event afterdependencydragdrop
             * Always fires after a dependency drag-drop operation
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             */
            'afterdependencydragdrop',

            // Drag create events start --------------------------
            /**
             * @event beforedragcreate
             * Fires before a drag create operation starts, return false to prevent the operation
             * @param {GanttView} gantt The gantt view
             * @param {Gnt.model.Task} task The task record being updated
             * @param {Date} date The date of the drag start point
             * @param {Ext.EventObject} e The event object
             */
            'beforedragcreate',

            /**
             * @event dragcreatestart
             * Fires before a drag starts, return false to stop the operation
             * @param {GanttView} view The gantt view
             */
            'dragcreatestart',

            /**
             * @event dragcreateend
             * Fires after a successful drag-create operation
             * @param {GanttView} view The gantt view
             * @param {Gnt.model.Task} task The updated task record
             * @param {Ext.EventObject} e The event object
             */
            'dragcreateend',

            /**
             * @event afterdragcreate
             * Always fires after a drag-create operation
             * @param {GanttView} view The gantt view
             */
            'afterdragcreate',
            // Drag create events end --------------------------


            /**
             * @event scheduleclick
             * Fires after a click on the schedule area
             * @param {Gnt.view.Gantt} ganttView The gantt view object
             * @param {Date} clickedDate The clicked date
             * @param {Int} rowIndex The row index
             * @param {Ext.EventObject} e The event object
             */
            'scheduleclick',

            /**
             * @event scheduledblclick
             * Fires after a doubleclick on the schedule area
             * @param {Gnt.view.Gantt} ganttView The gantt view object
             * @param {Date} clickedDate The clicked date
             * @param {Int} rowIndex The row index
             * @param {Ext.EventObject} e The event object
             */
            'scheduledblclick',

            /**
             * @event schedulecontextmenu
             * Fires after a context menu click on the schedule area
             * @param {Gnt.view.Gantt} ganttView The gantt view object
             * @param {Date} clickedDate The clicked date
             * @param {Int} rowIndex The row index
             * @param {Ext.EventObject} e The event object
             */
            'schedulecontextmenu'
        );

        this.callParent(arguments);

        this.initTreeFiltering();

        this.addCls('sch-ganttview');
    },

    onRender : function () {
        this.configureLabels();
        this.setupGanttEvents();
        this.setupTemplates();
        this.callParent(arguments);
    },

    /**
     * Returns the associated dependency store
     * @return {Gnt.data.TaskStore}
     */
    getDependencyStore : function () {
        return this.dependencyStore;
    },


    configureFeatures : function () {
        if (this.enableProgressBarResize !== false) {
            this.progressBarResizer = Ext.create("Gnt.feature.ProgressBarResize", Ext.apply({
                ganttView : this
            }, this.progressBarResizeConfig || {}));

            this.on({
                beforeprogressbarresize : this.onBeforeTaskProgressBarResize,
                progressbarresizestart  : this.onTaskProgressBarResizeStart,
                afterprogressbarresize  : this.onTaskProgressBarResizeEnd,
                scope                   : this
            });
        }

        if (this.resizeHandles !== 'none') {

            this.taskResizer = Ext.create("Gnt.feature.TaskResize", Ext.apply({
                gantt            : this,
                validatorFn      : this.resizeValidatorFn || Ext.emptyFn,
                validatorFnScope : this.validatorFnScope || this
            }, this.resizeConfig || {}));

            this.on({
                beforedragcreate : this.onBeforeDragCreate,
                beforetaskresize : this.onBeforeTaskResize,
                taskresizestart  : this.onTaskResizeStart,
                aftertaskresize  : this.onTaskResizeEnd,
                scope            : this
            });
        }

        if (this.enableTaskDragDrop) {
            // Seems we cannot use the gantt view el for the drag zone, it crashes IE9 in some cases.
            // See https://www.assembla.com/spaces/bryntum/tickets/716

            this.taskDragDrop = Ext.create("Gnt.feature.TaskDragDrop", this.ownerCt.el, Ext.apply({
                gantt            : this,
                validatorFn      : this.dndValidatorFn || Ext.emptyFn,
                validatorFnScope : this.validatorFnScope || this
            }, this.dragDropConfig));

            this.on({
                beforetaskdrag : this.onBeforeTaskDrag,
                taskdragstart  : this.onDragDropStart,
                aftertaskdrop  : this.onDragDropEnd,
                scope          : this
            });
        }

        if (this.enableDragCreation) {
            this.dragCreator = Ext.create("Gnt.feature.DragCreator", Ext.apply({
                ganttView        : this,
                validatorFn      : this.createValidatorFn || Ext.emptyFn,
                validatorFnScope : this.validatorFnScope || this
            }, this.createConfig));
        }
    },

    /**
     * Returns the template for the task. Override this template method to supply your own custom UI template for a certain type of task.
     *
     * @template
     * @protected
     * @param {Gnt.model.Task} task The task to get template for.
     * @param {Boolean} isBaseline True to return the template for a baseline version of the task.
     * @return {Gnt.template.Template} Template for the task.
     */
    getTemplateForTask : function (task, isBaseline) {
        if (task.isMilestone(isBaseline)) {
            return this.milestoneTemplate;
        }
        if (task.isLeaf()) {
            return this.eventTemplate;
        }
        return this.parentEventTemplate;
    },

    // private
    columnRenderer    : function (value, meta, taskModel) {
        var taskStart = taskModel.getStartDate(),
            ta = this.timeAxis,
            D = Sch.util.Date,
            tplData = {},
            cellResult = '',
            ctcls = '',
            viewStart = ta.getStart(),
            viewEnd = ta.getEnd(),
            isMilestone = taskModel.isMilestone(),
            isLeaf = taskModel.isLeaf(),
            userData, startsInsideView, endsOutsideView;

        if (taskStart) {
            var taskEnd = taskModel.getEndDate() || Sch.util.Date.add(taskStart, Sch.util.Date.DAY, 1),
                doRender = Sch.util.Date.intersectSpans(taskStart, taskEnd, viewStart, viewEnd);

            if (doRender) {
                endsOutsideView = taskEnd > viewEnd;
                startsInsideView = D.betweenLesser(taskStart, viewStart, viewEnd);

                var taskStartX = Math.floor(this.getXFromDate(startsInsideView ? taskStart : viewStart)),
                    taskEndX = Math.floor(this.getXFromDate(endsOutsideView ? viewEnd : taskEnd)),
                    itemWidth = isMilestone ? 0 : taskEndX - taskStartX,
                    lField = this.leftLabelField,
                    rField = this.rightLabelField,
                    tField = this.topLabelField,
                    bField = this.bottomLabelField,
                    tpl = this.getTemplateForTask(taskModel);

                if (!isMilestone && !isLeaf) {
                    if (endsOutsideView) {
                        itemWidth += this.parentTaskOffset; // Compensate for the parent arrow offset (6px on left side)
                    } else {
                        itemWidth += 2 * this.parentTaskOffset; // Compensate for the parent arrow offset (6px on both sides)
                    }
                }

                tplData = {
                    // Core properties
                    id          : taskModel.internalId,
                    offset      : isMilestone ? (taskEndX || taskStartX) - this.getXOffset(taskModel) : taskStartX,
                    width       : Math.max(1, itemWidth),
                    ctcls       : '',
                    cls         : '',
                    print       : this._print,
                    record      : taskModel,
                    // Percent complete
                    percentDone : Math.min(taskModel.getPercentDone() || 0, 100)
                };

                // Get data from user "renderer"
                userData = this.eventRenderer.call(this.eventRendererScope || this, taskModel, tplData, taskModel.store) || {};

                if (lField) {
                    // Labels
                    tplData.leftLabel = lField.renderer.call(lField.scope || this, taskModel.data[lField.dataIndex], taskModel);
                }

                if (rField) {
                    tplData.rightLabel = rField.renderer.call(rField.scope || this, taskModel.data[rField.dataIndex], taskModel);
                }

                if (tField) {
                    tplData.topLabel = tField.renderer.call(tField.scope || this, taskModel.data[tField.dataIndex], taskModel);
                }

                if (bField) {
                    tplData.bottomLabel = bField.renderer.call(bField.scope || this, taskModel.data[bField.dataIndex], taskModel);
                }

                Ext.apply(tplData, userData);

                var dataCls = ' sch-event-resizable-' + taskModel.getResizable();

                if (isMilestone) {
                    tplData.side = Math.round((this.enableBaseline ? 0.4 : 0.5) * this.rowHeight);
                    ctcls += " sch-gantt-milestone";
                } else {
                    tplData.width = Math.max(1, itemWidth);

                    if (endsOutsideView) {
                        ctcls += ' sch-event-endsoutside ';
                    }

                    if (!startsInsideView) {
                        ctcls += ' sch-event-startsoutside ';
                    }

                    if (isLeaf) {
                        ctcls += " sch-gantt-task";
                    } else {
                        ctcls += " sch-gantt-parent-task";
                    }
                }

                if (taskModel.dirty)                    dataCls += ' sch-dirty ';
                if (taskModel.isDraggable() === false)  dataCls += ' sch-event-fixed ';

                tplData.cls = (tplData.cls || '') + (taskModel.getCls() || '') + dataCls;
                tplData.ctcls += ' ' + ctcls;

                cellResult += tpl.apply(tplData);
            }
        }

        if (this.enableBaseline) {

            var taskBaselineStart           = taskModel.getBaselineStartDate(),
                taskBaselineEnd             = taskModel.getBaselineEndDate();

            if (!userData) {
                userData                    = this.eventRenderer.call(this, taskModel, tplData, taskModel.store) || {};
            }

            if (taskBaselineStart && taskBaselineEnd && Sch.util.Date.intersectSpans(taskBaselineStart, taskBaselineEnd, viewStart, viewEnd)) {
                endsOutsideView             = taskBaselineEnd > viewEnd;
                startsInsideView            = D.betweenLesser(taskBaselineStart, viewStart, viewEnd);

                var isBaselineMilestone     = taskModel.isBaselineMilestone(),
                    baseStartX              = Math.floor(this.getXFromDate(startsInsideView ? taskBaselineStart : viewStart)),
                    baseEndX                = Math.floor(this.getXFromDate(endsOutsideView ? viewEnd : taskBaselineEnd)),
                    baseWidth               = isBaselineMilestone ? 0 : baseEndX - baseStartX,
                    baseTpl                 = this.getTemplateForTask(taskModel, true),
                    data                    = {
                        progressBarStyle : userData.baseProgressBarStyle || '',
                        id               : taskModel.internalId + '-base',
                        percentDone      : taskModel.getBaselinePercentDone(),
                        offset           : isBaselineMilestone ? (baseEndX || baseStartX) - this.getXOffset(taskModel, true) : baseStartX,
                        print            : this._print,
                        width            : Math.max(1, baseWidth),
                        baseline         : true
                    };

                ctcls                       = '';

                if (isBaselineMilestone) {
                    data.side               = Math.round(0.40 * this.rowHeight);
                    ctcls                   = "sch-gantt-milestone-baseline sch-gantt-baseline-item";
                } else if (taskModel.isLeaf()) {
                    ctcls                   = "sch-gantt-task-baseline sch-gantt-baseline-item";
                } else {
                    ctcls                   = "sch-gantt-parenttask-baseline sch-gantt-baseline-item";
                }

                if (endsOutsideView) {
                    ctcls                   += ' sch-event-endsoutside ';
                }

                if (!startsInsideView) {
                    ctcls                   += ' sch-event-startsoutside ';
                }

                // HACK, a bit inconsistent. 'basecls' should probably end up on the task el instead of the wrapper.
                data.ctcls                  = ctcls + ' ' + (userData.basecls || '');

                cellResult                  += baseTpl.apply(data);
            }
        }

        return cellResult;
    },


    setupTemplates : function () {

        var tplCfg = {
            leftLabel                : this.leftLabelField,
            rightLabel               : this.rightLabelField,
            topLabel                 : this.topLabelField,
            bottomLabel              : this.bottomLabelField,
            prefix                   : this.eventPrefix,
            resizeHandles            : this.resizeHandles,
            enableDependencyDragDrop : this.enableDependencyDragDrop !== false,
            enableProgressBarResize  : this.enableProgressBarResize,
            rtl                      : this.rtl
        };

        var config;

        if (!this.eventTemplate) {
            config = this.taskBodyTemplate ? Ext.apply({ innerTpl : this.taskBodyTemplate }, tplCfg) : tplCfg;
            this.eventTemplate = Ext.create("Gnt.template.Task", config);
        }

        if (!this.parentEventTemplate) {
            config = this.parentTaskBodyTemplate ? Ext.apply({ innerTpl : this.parentTaskBodyTemplate }, tplCfg) : tplCfg;
            this.parentEventTemplate = Ext.create("Gnt.template.ParentTask", config);
        }

        if (!this.milestoneTemplate) {
            config = this.milestoneBodyTemplate ? Ext.apply({ innerTpl : this.milestoneBodyTemplate }, tplCfg) : tplCfg;
            this.milestoneTemplate = Ext.create("Gnt.template.Milestone", config);
        }
    },

    /**
     * Wrapper function returning the dependency manager instance
     * @return {Gnt.view.Dependency} dependencyManager The dependency manager instance
     */
    getDependencyView : function () {
        return this.dependencyView;
    },


    /**
     * Returns the associated task store
     * @return {Gnt.data.TaskStore}
     */
    getTaskStore     : function () {
        return this.taskStore;
    },

    // private
    initDependencies : function () {

        if (this.dependencyStore) {
            var me = this,
                dv = Ext.create("Gnt.view.Dependency", Ext.apply({
                    containerEl              : me.el,
                    ganttView                : me,
                    enableDependencyDragDrop : me.enableDependencyDragDrop,
                    store                    : me.dependencyStore,
                    rtl                      : me.rtl
                }, this.dependencyViewConfig));

            dv.on({
                beforednd     : me.onBeforeDependencyDrag,
                dndstart      : me.onDependencyDragStart,
                drop          : me.onDependencyDrop,
                afterdnd      : me.onAfterDependencyDragDrop,
                beforecascade : me.onBeforeCascade,
                cascade       : me.onCascade,
                scope         : me
            });

            me.dependencyView = dv;

            me.relayEvents(dv, [
            /**
             * @event dependencyclick
             * Fires after clicking on a dependency line/arrow
             * @param {Gnt.view.Dependency} g The dependency view instance
             * @param {Gnt.model.Dependency} record The dependency record
             * @param {Ext.EventObject} event The event object
             * @param {HTMLElement} target The target of this event
             */
                'dependencyclick',

            /**
             * @event dependencycontextmenu
             * Fires after right clicking on a dependency line/arrow
             * @param {Gnt.view.Dependency} g The dependency view instance
             * @param {Gnt.model.Dependency} record The dependency record
             * @param {Ext.EventObject} event The event object
             * @param {HTMLElement} target The target of this event
             */
                'dependencycontextmenu',

            /**
             * @event dependencydblclick
             * Fires after double clicking on a dependency line/arrow
             * @param {Gnt.view.Dependency} g The dependency view instance
             * @param {Gnt.model.Dependency} record The dependency record
             * @param {Ext.EventObject} event The event object
             * @param {HTMLElement} target The target of this event
             */
                'dependencydblclick'
            ]);
        }
    },


    // private
    setupGanttEvents : function () {
        var sm = this.getSelectionModel();

        if (this.toggleParentTasksOnClick) {
            this.on({
                taskclick : function (g, model) {
                    if (!model.isLeaf()) {
                        model.isExpanded() ? model.collapse() : model.expand();
                    }
                }
            });
        }
    },

    // private
    configureLabels  : function () {

        var defaults = {
            renderer  : function (v) {
                return v;
            },
            dataIndex : undefined
        };

        Ext.Array.forEach(['left', 'right', 'top', 'bottom'], function(pos) {

            var field = this[pos+'LabelField'];

            if (field) {
                if (Ext.isString(field)) {
                    field = this[pos + 'LabelField'] = { dataIndex : field };
                }
                Ext.applyIf(field, defaults);

                // Initialize editor (if defined)
                if (field.editor) {
                    field.editor = Ext.create("Gnt.feature.LabelEditor", this, {
                        labelPosition : pos,
                        field         : field.editor,
                        dataIndex     : field.dataIndex
                    });
                }
            }
        }, this);

        this.on('labeledit_beforestartedit', this.onBeforeLabelEdit, this);
    },

    // private
    onBeforeTaskDrag : function (p, record) {
        return !this.readOnly && record.isDraggable() !== false && (this.allowParentTaskMove || record.isLeaf());
    },

    onDragDropStart : function () {
        if (this.tip) {
            this.tip.disable();
        }
    },

    onDragDropEnd : function () {
        if (this.tip) {
            this.tip.enable();
        }
    },

    onTaskProgressBarResizeStart : function () {
        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }
    },

    onTaskProgressBarResizeEnd : function () {
        if (this.tip) {
            this.tip.enable();
        }
    },

    onTaskResizeStart : function () {
        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }
    },

    onTaskResizeEnd    : function () {
        if (this.tip) {
            this.tip.enable();
        }
    },

    // private
    onBeforeDragCreate : function () {
        return !this.readOnly;
    },

    // private
    onBeforeTaskResize : function (view, task) {
        return !this.readOnly && task.getSchedulingMode() !== 'EffortDriven';
    },

    onBeforeTaskProgressBarResize : function () {
        return !this.readOnly;
    },

    onBeforeLabelEdit : function () {
        return !this.readOnly;
    },

    onBeforeEdit : function () {
        return !this.readOnly;
    },

    afterRender : function () {
        this.initDependencies();
        this.callParent(arguments);

        this.el.on('mousemove', this.configureFeatures, this, { single : true });

        Ext.dd.ScrollManager.register(this.el);
    },

    resolveTaskRecord : function (el) {
        var node = this.findItemByChild(el);
        if (node) {
            return this.getRecord(this.findItemByChild(el));
        }
        return null;
    },

    resolveEventRecord : function (el) {
        return this.resolveTaskRecord(el);
    },

    /**
     * Highlights a task and optionally any dependent tasks. Highlighting will add the `sch-gantt-task-highlighted` 
     * class to the task's row.
     *
     * @param {Mixed} task Either a task record or the id of a task
     * @param {Boolean} highlightDependentTasks `true` to highlight the depended tasks. Defaults to `true`
     *
     */
    highlightTask : function (task, highlightDependentTasks) {
        if (!(task instanceof Ext.data.Model)) {
            task = this.taskStore.getById(task);
        }

        if (task) {
            task.isHighlighted = true;

            var el = this.getNode(task);
            if (el) {
                Ext.fly(el).addCls('sch-gantt-task-highlighted');
            }

            if (highlightDependentTasks !== false) {
                for (var i = 0, l = task.successors.length; i < l; i++) {
                    var dep     = task.successors[ i ];

                    this.highlightDependency(dep);
                    this.highlightTask(dep.getTargetTask(), highlightDependentTasks);
                }
            }
        }
    },


    /**
     * Un-highlights a task and optionally any dependent tasks.
     *
     * @param {Mixed} task Either a task record or the id of a task
     * @param {Boolean} alsoDependedTasks `true` to highlight the depended tasks. Defaults to `true`
     *
     */
    unhighlightTask : function (task, alsoDependedTasks) {
        if (!(task instanceof Ext.data.Model)) {
            task = this.taskStore.getById(task);
        }

        if (task) {
            task.isHighlighted = false;

            Ext.fly(this.getNode(task)).removeCls('sch-gantt-task-highlighted');

            if (alsoDependedTasks !== false) {
                for (var i = 0, l = task.successors.length; i < l; i++) {
                    var dep     = task.successors[ i ];

                    this.unhighlightDependency(dep);
                    this.unhighlightTask(dep.getTargetTask(), alsoDependedTasks);
                }
            }
        }
    },


    getRowClass                       : function (task) {
        var cls = '';

        if (task.isHighlighted) cls = 'sch-gantt-task-highlighted';

        if (this.externalGetRowClass) cls += ' ' + (this.externalGetRowClass.apply(this, arguments) || '');

        return cls;
    },


    // private
    clearSelectedTasksAndDependencies : function () {
        this.getDependencyView().clearSelectedDependencies();
        this.el.select('tr.sch-gantt-task-highlighted').removeCls('sch-gantt-task-highlighted');

        this.taskStore.getRootNode().cascadeBy(function (task) {
            task.isHighlighted = false;
        });
    },


    /**
     * Returns the critical path(s) that can affect the end date of the project
     * @return {Array} paths An array of arrays (containing task chains)
     */
    getCriticalPaths : function () {
        return this.taskStore.getCriticalPaths();
    },


    /**
     * Highlights the critical path(s) that can affect the end date of the project.
     */
    highlightCriticalPaths : function () {
        // First clear any selected tasks/dependencies
        this.clearSelectedTasksAndDependencies();

        var paths = this.getCriticalPaths(),
            dm = this.getDependencyView(),
            ds = this.dependencyStore,
            t, i, l, depRecord;

        Ext.each(paths, function (tasks) {
            for (i = 0, l = tasks.length; i < l; i++) {
                t = tasks[i];
                this.highlightTask(t, false);

                if (i < l - 1) {

                    for (var j = 0, m = t.predecessors.length; j < m; j++) {
                        if (t.predecessors[j].getSourceId() == tasks[i + 1].getInternalId()) {
                            depRecord = t.predecessors[j];
                            break;
                        }
                    }

                    dm.highlightDependency(depRecord);
                }
            }
        }, this);

        this.addCls('sch-gantt-critical-chain');
    },


    /**
     * Removes the highlighting of the critical path(s).
     */
    unhighlightCriticalPaths : function () {
        this.el.removeCls('sch-gantt-critical-chain');

        this.clearSelectedTasksAndDependencies();
    },


    //private
    getXOffset               : function (task, isBaseline) {
        var offset      = 0;

        if (task.isMilestone(isBaseline)) {
            // For milestones, the offset should be half the square diagonal
            offset      = Math.floor(this.rowHeight * Math.sqrt(2) / 4) - 2;
        } else
            // baseline parent tasks are rendered as regular tasks and don't need the additional offset
            if (!task.isLeaf() && !isBaseline) {
                offset  = this.parentTaskOffset;
            }

        return offset;
    },

    //private
    onDestroy                : function () {
        if (this.dependencyView) {
            this.dependencyView.destroy();
        }

        if (this.rendered) Ext.dd.ScrollManager.unregister(this.el);

        this.callParent(arguments);
    },

    /**
     * Convenience method wrapping the dependency manager method which highlights the elements representing a particular dependency
     * @param {Mixed} record Either the id of a record or a record in the dependency store
     */
    highlightDependency : function (record) {
        this.dependencyView.highlightDependency(record);
    },

    /**
     * Convenience method wrapping the dependency manager method which unhighlights the elements representing a particular dependency
     * @param {Mixed} depId Either the id of a record or a record in the dependency store
     */
    unhighlightDependency  : function (record) {
        this.dependencyView.unhighlightDependency(record);
    },


    // private
    onBeforeDependencyDrag : function (dm, sourceTask) {
        return this.fireEvent('beforedependencydrag', this, sourceTask);
    },

    // private
    onDependencyDragStart  : function (dm) {
        this.fireEvent('dependencydragstart', this);
        if (this.tip) {
            this.tip.disable();
        }
    },

    onDependencyDrop          : function (dm, fromId, toId, type) {
        this.fireEvent('dependencydrop', this, this.taskStore.getById(fromId), this.taskStore.getById(toId), type);
    },

    // private
    onAfterDependencyDragDrop : function () {
        this.fireEvent('afterdependencydragdrop', this);

        // Enable tooltip after drag again
        if (this.tip) {
            this.tip.enable();
        }
    },

    // Disconnect the store 'update' listener for the view
    // private
    onBeforeCascade           : function (dm, r) {
        this.taskStore.un('update', this.onUpdate, this);
    },

    // Reconnect the store 'update' listener for the view
    // private
    onCascade                 : function (dm, r) {
        this.taskStore.on('update', this.onUpdate, this);
    },

    /**
     * Returns the editor defined for the left task field
     * @return {Gnt.feature.LabelEditor} editor The editor
     */
    getLeftEditor : function () {
        return this.leftLabelField.editor;
    },

    /**
     * Returns the editor defined for the right task field
     * @return {Gnt.feature.LabelEditor} editor The editor
     */
    getRightEditor : function () {
        return this.rightLabelField.editor;
    },

    /**
     * Returns the editor defined for the top task field
     * @return {Gnt.feature.LabelEditor} editor The editor
     */
    getTopEditor : function () {
        return this.topLabelField.editor;
    },

    /**
     * Returns the editor defined for the bottom task field
     * @return {Gnt.feature.LabelEditor} editor The editor
     */
    getBottomEditor : function () {
        return this.bottomLabelField.editor;
    },

    /**
     * Programmatically activates the editor for the left field
     * @param {Gnt.model.Task} record The task record
     */
    editLeftLabel : function (record) {
        var ed = this.leftLabelField && this.leftLabelField.editor;
        if (ed) {
            ed.edit(record);
        }
    },

    /**
     * Programmatically activates the editor for the right field
     * @param {Gnt.model.Task} record The task record
     */
    editRightLabel                 : function (record) {
        var ed = this.rightLabelField && this.rightLabelField.editor;
        if (ed) {
            ed.edit(record);
        }
    },

    /**
     * Programmatically activates the editor for the top field
     * @param {Gnt.model.Task} record The task record
     */
    editTopLabel : function (record) {
        var ed = this.topLabelField && this.topLabelField.editor;
        if (ed) {
            ed.edit(record);
        }
    },

    /**
     * Programmatically activates the editor for the bottom field
     * @param {Gnt.model.Task} record The task record
     */
    editBottomLabel                 : function (record) {
        var ed = this.bottomLabelField && this.bottomLabelField.editor;
        if (ed) {
            ed.edit(record);
        }
    },

    // symmetric method `getElementFromEventRecord` - always returns the outer-most element for event/task in both scheduler/gantt
    getOuterElementFromEventRecord : function (record) {
        var prev = this.callParent([ record ]);

        return prev && prev.up(this.eventWrapSelector) || null;
    },


    // deprecated
    getDependenciesForTask         : function (record) {
        console.warn('`ganttPanel.getDependenciesForTask()` is deprecated, use `task.getAllDependencies()` instead');
        return record.getAllDependencies();
    },

    // Performance tweak, preventing extra layout cycles
    // @OVERRIDE
    onAdd                          : function () {
        Ext.suspendLayouts();
        this.callParent(arguments);
        Ext.resumeLayouts();
    },

    // Performance tweak, preventing extra layout cycles
    // @OVERRIDE
    onRemove                       : function () {
        Ext.suspendLayouts();
        this.callParent(arguments);
        Ext.resumeLayouts();
    },

    // @OVERRIDE
    // Preventing extra reflows due to the expensive re-layout performed by the superclass
    onUpdate                       : function (store, record, operation, changedFieldNames) {
        Ext.suspendLayouts();
        this.callParent(arguments);
        Ext.resumeLayouts();
    },


    handleScheduleEvent : function (e) {
        var t = e.getTarget('.' + this.timeCellCls, 3);

        if (t) {
            var rowNode = this.findRowByChild(t);

            this.fireEvent('schedule' + e.type, this, this.getDateFromDomEvent(e, 'floor'), this.indexOf(rowNode), e);
        }
    },


    /**
     *  Scrolls a task record into the viewport.
     *  This method will also expand all relevant parent nodes to locate the event.
     *
     *  @param {Gnt.model.Task} taskRec, the task record to scroll into view
     *  @param {Boolean/Object} highlight, either `true/false` or a highlight config object used to highlight the element after scrolling it into view
     *  @param {Boolean/Object} animate, either `true/false` or an animation config object used to scroll the element
     */
    scrollEventIntoView : function (taskRec, highlight, animate, callback, scope) {
        scope = scope || this;

        var me = this;
        var taskStore = this.taskStore;

        var basicScroll = function (el) {

            // HACK
            // After a time axis change, the header is resized and Ext JS TablePanel reacts to the size change.
            // Ext JS reacts after a short delay, so we cancel this task to prevent Ext from messing up the scroll sync
            me.up('panel').scrollTask.cancel();

            el.scrollIntoView(me.el, true, animate);

            if (highlight) {
                if (typeof highlight === "boolean") {
                    el.highlight();
                } else {
                    el.highlight(null, highlight);
                }
            }

            // XXX callback will be called too early, need to wait for scroll & highlight to complete
            callback && callback.call(scope);
        };

        // Make sure the resource is expanded all the way up first.
        if (!taskRec.isVisible()) {
            taskRec.bubble(function (node) {
                node.expand();
            });
        }

        var targetEl;

        var startDate = taskRec.getStartDate();
        var endDate = taskRec.getEndDate();

        if (startDate && endDate) {
            var timeAxis = this.timeAxis;

            // If task is not in the currently viewed time span, change time span
            if (!timeAxis.dateInAxis(startDate) || !timeAxis.dateInAxis(endDate)) {
                var range = timeAxis.getEnd() - timeAxis.getStart();

                timeAxis.setTimeSpan(new Date(startDate.getTime() - range / 2), new Date(endDate.getTime() + range / 2));
            }
            targetEl = this.getElementFromEventRecord(taskRec);
        } else {
            // No date information in the task, scroll to row element instead
            targetEl = this.getNode(taskRec);

            if (targetEl) {
                targetEl = Ext.fly(targetEl).down(this.getCellSelector());
            }
        }

        if (targetEl) {
            basicScroll(targetEl);
        } else {
            if (this.bufferedRenderer) {

                Ext.Function.defer(function () {
                    me.bufferedRenderer.scrollTo(taskStore.getIndexInTotalDataset(taskRec), false, function () {
                        // el should be present now
                        var targetEl = me.getElementFromEventRecord(taskRec);

                        if (targetEl) {
                            basicScroll(targetEl);
                        } else {
                            callback && callback.call(scope);
                        }
                    });

                }, 10);
            }
        }
    }
});

/**

 @class Gnt.view.ResourceHistogram
 @extends Sch.view.TimelineGridView

 A view of the resource histogram panel. Use the {@link Gnt.panel.ResourceHistogram#getSchedulingView} method to get its instance from gantt panel.

 */
 Ext.define('Gnt.view.ResourceHistogram', {
    extend              : 'Sch.view.TimelineGridView',

    alias               : 'widget.resourcehistogramview',

    requires    : [
        'Ext.XTemplate',
        'Ext.util.Format',
        'Sch.util.Date',
        'Gnt.model.Resource'
    ],

    _cmpCls             : 'gnt-resourcehistogramview',

    scheduledEventName  : 'bar',

    // private
    eventSelector       : '.gnt-resourcehistogram-bar',

    barTpl              : null,

    barCls              : 'gnt-resourcehistogram-bar',

    lineTpl             : null,

    lineCls             : 'gnt-resourcehistogram-line',

    limitLineTpl        : null,

    limitLineCls        : 'gnt-resourcehistogram-limitline',

    limitLineWidth      : 1,

    rowHeight           : 60,

    labelMode           : false,

    labelPercentFormat  : '0',

    labelUnitsFormat    : '0.0',

    unitHeight          : null,

    constructor : function (config) {

        this.callParent(arguments);

        if (this.barCls) {
            this.eventSelector = '.' + this.barCls;
        }

        // calculate pixels per scale step
        this.unitHeight = this.getAvailableHeight() / (this.scaleMax - this.scaleMin + this.scaleStep);

        // bar template
        if (!this.barTpl) {
            this.barTpl = new Ext.XTemplate(
                '<tpl for=".">',
                    '<div id="{id}" class="'+ this.barCls +' {cls}" gnt-bar-index="{index}" style="left:{left}px;top:{top}px;height:{height}px;width:{width}px"></div>',
                    '<tpl if="text !== \'\'">',
                        '<span class="'+ this.barCls +'-text" style="left:{left}px;">{text}</span>',
                    '</tpl>',
                '</tpl>'
            );
        }

        // scale line template
        if (!this.lineTpl) {
            this.lineTpl = new Ext.XTemplate(
                '<tpl for=".">',
                    '<div class="'+ this.lineCls +' {cls}" style="top:{top}px;"></div>',
                '</tpl>'
            );
        }

        // limit line template
        if (!this.limitLineTpl) {
            this.limitLineTpl = new Ext.XTemplate(
                '<tpl for=".">',
                    '<div class="'+ this.limitLineCls +' {cls}" style="left:{left}px;top:{top}px;bottom:{bottom}px;width:{width}px;height:{height}px"></div>',
                '</tpl>'
            );
        }

        this.addEvents(
            /**
            * @event barclick
            * Fires when a histogram bar is clicked
            *
            * @param {Gnt.view.ResourceHistogram} view The histogram panel view.
            * @param {Object} context Object containing a description of the clicked bar.
            * @param {Gnt.model.Resource} context.resource The resource record.
            * @param {Date} context.startDate Start date of corresponding period.
            * @param {Date} context.endDate End date of corresponding period.
            * @param {Number} context.allocationMS Resource allocation time in milliseconds.
            * @param {Number} context.totalAllocation Resource allocation (in percents).
            * @param {Gnt.model.Assignment[]} context.assignments List of resource assignments for the corresponding period.
            * @param {Ext.EventObject} e The event object
            */
            'barclick',
            /**
            * @event bardblclick
            * Fires when a histogram bar is double clicked
            *
            * @param {Gnt.view.ResourceHistogram} view The histogram panel view.
            * @param {Object} context Object containing description of clicked bar.
            * @param {Gnt.model.Resource} context.resource The resource record.
            * @param {Date} context.startDate Start date of corresponding period.
            * @param {Date} context.endDate End date of corresponding period.
            * @param {Number} context.allocationMS Resource allocation time in milliseconds.
            * @param {Number} context.totalAllocation Resource allocation (in percents).
            * @param {Gnt.model.Assignment[]} context.assignments List of resource assignments for the corresponding period.
            * @param {Ext.EventObject} e The event object
            */
            'bardblclick',
            /**
            * @event barcontextmenu
            * Fires when contextmenu is activated on a histogram bar
            *
            * @param {Gnt.view.ResourceHistogram} view The histogram panel view.
            * @param {Object} context Object containing description of clicked bar.
            * @param {Gnt.model.Resource} context.resource The resource record.
            * @param {Date} context.startDate Start date of corresponding period.
            * @param {Date} context.endDate End date of corresponding period.
            * @param {Number} context.allocationMS Resource allocation time in milliseconds.
            * @param {Number} context.totalAllocation Resource allocation (in percents).
            * @param {Gnt.model.Assignment[]} context.assignments List of resource assignments for the corresponding period.
            * @param {Ext.EventObject} e The event object
            */
            'barcontextmenu'
        );

    },

    onUpdate : function (store, resource, operation, changedFieldNames) {
        // if calendar on resource was changed
        if (Ext.Array.indexOf(Gnt.model.Resource.prototype.calendarIdField, changedFieldNames) > -1) {

            // reload allocation data for resource
            this.histogram.loadAllocationData(resource, true);

            // unbind old listeners from resource calendar
            this.histogram.unbindResourceCalendarListeners(resource);

            // if new resource calendar differs from project one
            var calendar    = resource.getOwnCalendar();
            if (calendar && calendar !== this.histogram.calendar) {
                // bind listener on it
                this.histogram.bindResourceCalendarListeners(resource, calendar);
            }
        }

        this.callParent(arguments);
    },

    onDataRefresh : function () {
        // reload allocation data
        this.histogram.loadAllocationData(null, true);

        // bind listeners to resources calendars
        this.histogram.bindCalendarListeners();

        this.callParent(arguments);
    },

    // histogram scale lines renderer
    renderLines : function (histogram) {
        return this.lineTpl.apply(this.prepareLines(histogram));
    },

    // prepare data for scale lines renderer
    prepareLines : function (histogram) {
        var value       = histogram.scaleMin,
            labelStep   = histogram.scaleLabelStep,
            rowHeight   = this.getAvailableHeight(),
            tplData     = [],
            line        = {},
            lineCls     = this.lineCls,
            cls         = lineCls+'min';

        // if scale point array specified
        if (histogram.scalePoints) {
            var point;
            for (var i = 0, l = histogram.scalePoints.length; i < l; i++) {
                point = histogram.scalePoints[i];

                tplData.push({
                    value   : point.value,
                    top     : point.top || Math.round(rowHeight - this.unitHeight * (point.value - histogram.scaleMin)),
                    cls     : point.cls + (point.label ? ' '+lineCls+'-label' : '') + (i === 0 ? ' '+lineCls+'-min' : (i == l ? ' '+lineCls+'-max' : ''))
                });
            }

        // otherwise we have to calculate line top-coordinates
        } else {
            // loop from scaleMin up to scaleMax
            while (value <= histogram.scaleMax) {

                tplData.push({
                    value   : value,
                    top     : Math.round(rowHeight - this.unitHeight * (value - histogram.scaleMin)),
                    cls     : cls
                });

                // increment by scale step size
                value   += histogram.scaleStep;

                cls     = value % labelStep ? '' : lineCls+'-label';

                if (value == histogram.scaleMax) cls += ' '+lineCls+'-max';
            }

            // ensure that we have scaleMax as last tplData element (we can step over it for some stepSize values)
            if (tplData.length && tplData[tplData.length - 1].value !== histogram.scaleMax) {
                tplData.push({
                    value   : histogram.scaleMax,
                    top     : Math.round(rowHeight - this.unitHeight * (histogram.scaleMax - histogram.scaleMin)),
                    cls     : (histogram.scaleMax % labelStep ? '' : lineCls+'-label') + ' '+lineCls+'-max'
                });
            }
        }

        return tplData;
    },

    renderLimitLines : function (histogram, data) {
        return this.limitLineTpl.apply(this.prepareLimitLines(histogram, data));
    },

    prepareLimitLines : function (histogram, data) {
        var tplData     = [],
            rowHeight   = this.getAvailableHeight(),
            lineCls     = this.limitLineCls,
            tplItem, prevAllocation, allocation, top, prop, visible, startDate;

        for (var i = 0, l = data.length; i < l; i++) {

            startDate   = this.getXFromDate(data[i].startDate || histogram.getStart(), true);

            tplItem     = {
                left    : startDate,
                width   : this.getXFromDate(data[i].endDate || histogram.getEnd(), true) - startDate,
                top     : '',
                bottom  : '',
                height  : 0,
                cls     : ''
            };

            // get allocation in histogram.scaleUnit units
            allocation  = histogram.calendar.convertMSDurationToUnit(data[i].allocationMS, histogram.scaleUnit);

            visible     = true;
            // if the line doesn't fit into row height
            if (allocation * this.unitHeight > rowHeight) {
                allocation  = histogram.scaleMax + histogram.scaleStep;
                visible     = false;

            } else if (allocation < histogram.scaleMin) {
                allocation  = histogram.scaleMin;
                visible     = false;
            }

            tplItem.height  = 0;

            // if prev line level was greater than current one then we gonna use bottom border to draw the line
            if (prevAllocation > allocation) {
                // get bottom-position based on max possible allocation
                tplItem.bottom  = Math.round((allocation - histogram.scaleMin) * this.unitHeight) - this.limitLineWidth;

                prop            = 'bottom';
                tplItem.top     = '';
                if (visible) {
                    tplItem.cls += ' '+lineCls+'-bottom';
                }
            } else {
                // get top-position based on max possible allocation
                tplItem.top     = Math.round(rowHeight - (allocation - histogram.scaleMin) * this.unitHeight);

                prop            = 'top';
                tplItem.bottom  = '';
                if (visible) {
                    tplItem.cls += ' '+lineCls+'-top';
                }
            }

            // if it's not the first segment let's calculate current segment height
            if (tplData[0]) {
                // if prev line segment was positioned by the same property (top/bottom) as current one
                if (tplData[tplData.length - 1][prop]) {
                    // then height is just the difference between them
                    tplItem.height  = (tplData[tplData.length - 1][prop] - tplItem[prop]) + this.limitLineWidth;
                // if it's top-vs-bottom
                } else {
                    // then height is total height minus bottom+top
                    tplItem.height  = rowHeight - (tplItem[prop] + tplData[tplData.length - 1][prop == 'top' ? 'bottom' : 'top']);
                }
            }

            tplItem.height  = Math.round(Math.abs(tplItem.height));

            prevAllocation  = allocation;

            tplData.push(tplItem);
        }

        return tplData;
    },

    renderBars : function (histogram, data, resourceId) {
        return this.barTpl.apply(this.prepareBars(histogram, data, resourceId));
    },

    prepareBars : function (histogram, data, resourceId) {
        // loop over periods that we have for the resource
        var tplData     = [],
            rowHeight   = this.getAvailableHeight(),
            barCls      = this.barCls,
            tplItem,
            allocation;
        for (var i = 0, l = data.length; i < l; i++) {

            // if resource is allocated
            if (data[i].totalAllocation) {

                // get allocation in units (hours by default)
                allocation          = histogram.calendar.convertMSDurationToUnit(data[i].allocationMS, histogram.scaleUnit);

                tplItem = {
                    id      : resourceId + '-' + i,
                    index   : i,
                    left    : this.getXFromDate(data[i].startDate, true),
                    width   : this.getXFromDate(data[i].endDate, true) - this.getXFromDate(data[i].startDate, true),
                    height  : rowHeight,
                    top     : 0,
                    text    : '',
                    cls     : ''
                };

                // if label has to be shown
                if (this.labelMode) {
                    // what type of label requested
                    switch (this.labelMode) {
                        case 'percent'  :
                            tplItem.text = Ext.util.Format.number(data[i].totalAllocation, this.labelPercentFormat) + '%';
                            break;

                        case 'units'    :
                            tplItem.text = Ext.util.Format.number(allocation,  this.labelUnitsFormat) + Sch.util.Date.getShortNameOfUnit(histogram.scaleUnit);
                            break;

                        // custom template
                        default         :
                            tplItem.text = this.labelMode.apply({
                                allocation  : allocation,
                                percent     : data[i].totalAllocation
                            });
                    }
                }

                // if the bar fits in row height
                if (allocation <= histogram.scaleMax + histogram.scaleStep) {
                    tplItem.height  = allocation >= histogram.scaleMin ? Math.round((allocation - histogram.scaleMin) * this.unitHeight) : 0;
                    tplItem.top     = rowHeight - tplItem.height;
                // if bar is higher than row height
                } else {
                    // add class to indicate it
                    tplItem.cls     = barCls+'-partofbar';
                }

                // overworking (allocation > 100%)
                if (data[i].totalAllocation > 100) {
                    tplItem.cls = barCls+'-overwork';
                }

                tplData.push(tplItem);
            }
        }
        return tplData;
    },

    columnRenderer : function (val, meta, resource, rowIndex, colIndex) {
        var resourceId  = resource.getInternalId(),
            view        = this.normalGrid.getView();

        // render: scale lines (if requested),
        return (this.showScaleLines ? view.renderLines(this) : '') +
            // histogram bars,
            view.renderBars(this, this.allocationData[resourceId].bars, resourceId) +
            // max resource allocation line (if requested)
            (this.showLimitLines ? view.renderLimitLines(this, this.allocationData[resourceId].maxBars) : '');
    },

    getAvailableHeight : function () {
        if (this.availableHeight) return this.availableHeight;

        this.availableHeight    = this.rowHeight - this.cellTopBorderWidth - this.cellBottomBorderWidth;

        return this.availableHeight;
    },

    resolveEventRecord : function (el) {
        var node = this.findItemByChild(el);
        if (node) {
            var resource = this.getRecord(node);
            if (resource) {
                var result = {
                    resource    : resource
                };
                var data    = this.histogram.allocationData[resource.getInternalId()];
                var index   = el.getAttribute('gnt-bar-index');
                var bar     = data.bars[index];
                result.startDate        = bar.startDate;
                result.endDate          = bar.endDate;
                result.assignments      = bar.assignments;
                result.allocationMS     = bar.allocationMS;
                result.totalAllocation  = bar.totalAllocation;

                return result;
            }
        }
        return null;
    },

    getDataForTooltipTpl : function (record) {
        return record;
    }

});

/**

@class Gnt.column.Scale
@extends Ext.grid.column.Template

A Column used to to display a vertical coordinate axis (numeric scale). This column is used by the {@link Gnt.panel.ResourceHistogram ResourceHistogram} panel.

Usage example:

    var histogram = Ext.create('Gnt.panel.ResourceHistogram', {
        taskStore           : taskStore,
        resourceStore       : resourceStore,
        startDate           : new Date(2010, 0, 11),
        endDate             : new Date(2010, 0, 21),
        renderTo            : Ext.getBody(),
        columns             : [
            {
                flex      : 1,
                dataIndex : 'Name'
            },
            {
                xtype           : 'scalecolumn'
            }
        ]
    });

#Defining the scale

The column supports two configuration modes for the numeric scale. The first one is incremental and the second one is using a fixed set of points.

#Incremental approach

To use this approach you must define the following parameters: {@link #scaleMin}, {@link #scaleMax}, {@link #scaleStep}.
Based on them, the column will build scale points taking the {@link #scaleMin} value as a start value and the {@link #scaleMax} as the last scale point.
Values between {@link #scaleMin} and {@link #scaleMax} will be calculated as:

    valueN = scaleMin + N * scaleStep

Normally this approach is meant to be used for linear scales.

#Fixed set of points

As an option to the earlier approach, you can use the {@link #scalePoints} config. This config can be used to specify an array af scale points.
The array should contain objects describing the scale points, having the following properties:

 - `value`   Scale point value. **This property is required**.
 - `label`   Label for the scale point
 - `cls`     CSS class for corresponding scale point.

For example:

    var scaleColumn = new Gnt.column.Scale({
        scalePoints : [
            {
                value   : 0
            },
            {
                value   : 1,
                label   : 'Day',
                cls     : 'dayend'
            },
            {
                value   : 0.5
            }
        ]
    });

*/
Ext.define('Gnt.column.Scale', {

    extend              : 'Ext.grid.column.Template',

    alias               : 'widget.scalecolumn',

    tpl                 : null,

    sortable            : false,

    /**
     * @cfg {Object[]} scalePoints An array of scale points. Each point should be represented as an object containing the following properties:
     *
     * - `value`   Scale point value **(required)**.
     * - `label`   Label for the scale point
     * - `cls`     CSS class for corresponding scale point.
     */
    scalePoints         : null,

    /**
     * @cfg {Number} scaleStep Defines the interval between two adjacent scale points.
     *
     * **Also,** this value is used as the margin between the top scale line (defined by {@link #scaleMax} option) and the top border of the cell.
     */
    scaleStep           : 2,

    /**
     * @cfg {Number} scaleLabelStep Defines the interval between the scale points with labels.
     * By default the scale values are used for the labels. To use custom labels please use the {@link #scalePoints} config.
     */
    scaleLabelStep      : 4,

    /**
     * @cfg {Number} scaleMin Minimum scale point value.
     */
    scaleMin            : 0,

    /**
     * @cfg {Number} scaleMax Maximum scale point value.
     */
    scaleMax            : 24,

    width               : 40,

    availableHeight     : 48,

    scaleCellCls        : 'gnt-scalecolumn',

    // Exclude in Gnt.column.AddNew list
    _isGanttColumn      : false,

    initComponent : function () {

        this.tdCls = (this.tdCls || '') + ' ' + this.scaleCellCls;

        if (!this.tpl) {
            this.tpl = new Ext.XTemplate(
                '<div class="'+this.scaleCellCls+'-wrap" style="height:{scaleHeight}px;">',
                    '<tpl for="scalePoints">',
                        '<tpl if="label !== \'\'">',
                            '<span class="'+this.scaleCellCls+'-label-line {cls}" style="top:{top}px"><span class="'+this.scaleCellCls+'-label">{label}</span></span>',
                        '<tpl else>',
                            '<span class="'+this.scaleCellCls+'-line {cls}" style="top:{top}px"></span>',
                        '</tpl>',
                    '</tpl>',
                '</div>'
            );
        }

        this.setAvailableHeight(this.availableHeight, true);

        this.callParent(arguments);
    },

    setAvailableHeight : function (height, initial) {
        this.availableHeight    = height;

        // if no ready scalePoints array specified
        if (!this.scalePoints) {

            this.scaleStepHeight    = this.availableHeight / (this.scaleMax - this.scaleMin + this.scaleStep);

            // build scale point based on min/max/step size params
            this.scalePoints = this.buildScalePoints();

        // if scale points array provided
        } else {
            if (initial) {
                this.scalePoints.sort(function (a, b) { return a.value > b.value ? 1 : -1; });

                this.scaleMin       = this.scalePoints[0].value;
                this.scaleMax       = this.scalePoints[this.scalePoints.length - 1].value;
                this.scaleStep      = (this.scaleMax - this.scaleMin) / 10;
            }

            this.scaleStepHeight    = this.availableHeight / (this.scaleMax - this.scaleMin + this.scaleStep);

            // let's fill it with calculated 'top' coordinates
            this.updateScalePointsTops();
        }
    },

    defaultRenderer : function (value, meta, record) {
        var data = {
            record      : Ext.apply({}, record.data, record.getAssociatedData()),
            scaleHeight : this.availableHeight,
            scalePoints : this.scalePoints
        };

        return this.tpl.apply(data);
    },

    buildScalePoints : function () {
        var minValue        = this.scaleMin,
            value           = minValue,
            step            = this.scaleStep,
            labelStep       = this.scaleLabelStep,
            stepHeight      = this.scaleStepHeight,
            availableHeight = this.availableHeight,
            scaleCellCls    = this.scaleCellCls,
            // additional css class for scaleMin point
            cls             = scaleCellCls+'-min',
            result          = [];

        // shorthand
        var makePoint   = function (value, label, cls) {
            return {
                top     : Math.round(availableHeight - (value - minValue) * stepHeight),
                value   : value,
                label   : label != 'undefined' ? label : '',
                cls     : cls || ''
            };
        };

        // push scale points starting from scaleMin
        while (value < this.scaleMax) {

            result.push( makePoint(value, value % labelStep || value === minValue ? '' : value, cls) );

            cls = '';

            value += step;
        }

        // push scaleMax point
        result.push( makePoint(this.scaleMax, this.scaleMax, scaleCellCls+'-max') );

        return result;
    },

    updateScalePointsTops : function () {
        var stepHeight      = this.scaleStepHeight,
            availableHeight = this.availableHeight,
            point;

        for (var i = 0, l = this.scalePoints.length; i < l; i++) {
            point       = this.scalePoints[i];
            point.top   = Math.round(availableHeight - point.value * stepHeight);
        }
    }
});

/**

@class Gnt.panel.Gantt
@extends Sch.panel.TimelineTreePanel

A gantt panel, which allows you to visualize and manage tasks and their dependencies.

Please refer to the <a href="#!/guide/gantt_getting_started">getting started guide</a> for a detailed introduction.

{@img gantt/images/gantt-panel.png}

*/
Ext.define("Gnt.panel.Gantt", {
    extend              : "Sch.panel.TimelineTreePanel",

    alias               : ['widget.ganttpanel'],
    alternateClassName  : ['Sch.gantt.GanttPanel'],

    requires            : [
        'Ext.layout.container.Border',
        'Gnt.model.Dependency',
        'Gnt.data.ResourceStore',
        'Gnt.data.AssignmentStore',
        'Gnt.feature.WorkingTime',
        'Gnt.data.Calendar',
        'Gnt.data.TaskStore',
        'Gnt.data.DependencyStore',
        'Gnt.view.Gantt'
    ],

    uses                : [
        'Sch.plugin.CurrentTimeLine'
    ],

    viewType        : 'ganttview',
    layout          : 'border',
    rowLines        : true,
    syncRowHeight   : false,
    useSpacer       : false,
    rowHeight       : 24,

    /**
     * @cfg {String/Object} leftLabelField
     * A configuration used to show/edit the field to the left of the task.
     * It can be either string indicating the field name in the data model or a custom object where you can set the following possible properties:
     *
     * - `dataIndex` : String - The field name in the data model
     * - `editor` : Ext.form.Field - The field used to edit the value inline
     * - `renderer` : Function - A renderer method used to render the label. The renderer is called with the 'value' and the record as parameters.
     * - `scope` : Object - The scope in which the renderer is called
     */
    leftLabelField              : null,

     /**
     * @cfg {String/Object} rightLabelField
     * A configuration used to show/edit the field to the right of the task.
     * It can be either string indicating the field name in the data model or a custom object where you can set the following possible properties:
     *
     * - `dataIndex` : String - The field name in the data model
     * - `editor` : Ext.form.Field - The field used to edit the value inline
     * - `renderer` : Function - A renderer method used to render the label. The renderer is called with the 'value' and the record as parameters.
     * - `scope` : Object - The scope in which the renderer is called
     */
    rightLabelField             : null,

    /**
     * @cfg {Boolean} highlightWeekends
     * True (default) to highlight weekends and holidays, using the {@link Gnt.feature.WorkingTime} plugin.
     */
    highlightWeekends           : true,

    /**
     * @cfg {Boolean} weekendsAreWorkdays
     * Set to `true` to treat *all* days as working, effectively removing the concept of non-working time from gantt. Defaults to `false`.
     * This option just will be translated to the {@link Gnt.data.Calendar#weekendsAreWorkdays corresponding option} of the calendar
     */
    weekendsAreWorkdays         : false,

    /**
     * @cfg {Boolean} skipWeekendsDuringDragDrop
     * True to skip the weekends/holidays during drag&drop operations (moving/resizing) and also during cascading. Default value is `true`.
     *
     * Note, that holidays will still be excluded from the duration of the tasks. If you need to completely disable holiday skipping you
     * can do that on the gantt level with the {@link #weekendsAreWorkdays} option, or on the task level with the `SchedulingMode` field.
     *
     *
     * This option just will be translated to the {@link Gnt.data.TaskStore#skipWeekendsDuringDragDrop corresponding option} of the task store
     */
    skipWeekendsDuringDragDrop  : true,

    /**
     * @cfg {Boolean} enableTaskDragDrop
     * True to allow drag drop of tasks (defaults to `true`). To customize the behavior of drag and drop, you can use {@link #dragDropConfig} option
     */
    enableTaskDragDrop          : true,

    /**
     * @cfg {Boolean} enableDependencyDragDrop
     * True to allow creation of dependencies by using drag and drop between task terminals (defaults to `true`)
     */
    enableDependencyDragDrop    : true,

    /**
     * @cfg {Boolean} enableProgressBarResize
     * True to allow resizing of the progress bar indicator inside tasks (defaults to `false`)
     */
    enableProgressBarResize     : false,


    /**
     * @cfg {Boolean} toggleParentTasksOnClick
     * True to toggle the collapsed/expanded state when clicking a parent task bar (defaults to `true`)
     */
    toggleParentTasksOnClick    : true,

    /**
     * @cfg {Boolean} addRowOnTab
     * True to automatically insert a new row when tabbing out of the last cell of the last row. Defaults to true.
     */
    addRowOnTab : true,

    /**
     * @cfg {Boolean} recalculateParents
     * True to update parent start/end dates after a task has been updated (defaults to `true`). This option just will be translated
     * to the {@link Gnt.data.TaskStore#recalculateParents corresponding option} of the task store
     */
    recalculateParents          : true,

    /**
     * @cfg {Boolean} cascadeChanges
     * True to cascade changes to dependent tasks (defaults to `false`). This option just will be translated
     * to the {@link Gnt.data.TaskStore#cascadeChanges corresponding option} of the task store
     */
    cascadeChanges              : false,

   /**
    * @cfg {Boolean} showTodayLine
    * True to show a line indicating current time. Default value is `false`.
    */
    showTodayLine               : false,


    /**
    * @cfg {Boolean} enableBaseline
    * True to enable showing a base lines for tasks. Baseline information should be provided as the `BaselineStartDate`, `BaselineEndDate` and `BaselinePercentDone` fields.
    * Default value is `false`.
    */
    enableBaseline              : false,

    /**
     * @cfg {Boolean} baselineVisible
     * @property {Boolean} baselineVisible
    * True to show the baseline in the initial rendering. You can show and hide the baseline programmatically via {@link #showBaseline} and {@link #hideBaseline}.
    * Default value is `false`.
    */
    baselineVisible : false,

    /**
    * @cfg {Boolean} enableAnimations
    * EXPERIMENTAL! True to enable the animations when expanding/collapsing parent tasks. Default value is `false`.
    */
    enableAnimations            : false,

    /**
     * If the {@link #highlightWeekends} option is set to true, you can access the created zones plugin through this property.
     * @property {Sch.plugin.Zones} workingTimePlugin
     */
    workingTimePlugin           : null,
    todayLinePlugin             : null,

    /**
     * @cfg {Boolean} allowParentTaskMove True to allow moving parent tasks. Please note, that when moving a parent task, the
     * {@link Gnt.data.TaskStore#cascadeDelay cascadeDelay} option will not be used and cascading will happen synchronously (if enabled).
     * 
     * Also, its possible to move the parent task as a group (along with its child tasks) or as individual task. This can be controlled with 
     * {@link Gnt.data.TaskStore#moveParentAsGroup} option.
     */
    allowParentTaskMove         : true,

    /**
     * @cfg {Boolean} enableDragCreation
     * True to allow dragging to set start and end dates
     */
    enableDragCreation          : true,

    /**
    * @cfg {Function} eventRenderer
    * An empty function by default, but provided so that you can override it. This function is called each time a task
    * is rendered into the gantt grid. The function should return an object with properties that will be applied to the relevant task template.
    * By default, the task templates include placeholders for :
    *
    * - `cls` - CSS class which will be added to the task bar element
    * - `ctcls` - CSS class which will be added to the 'root' element containing the task bar and labels
    * - `style` - inline style declaration for the task bar element
    * - `progressBarStyle` - an inline CSS style to be applied to the progress bar of this task
    * - `leftLabel` - the content for the left label (usually being extracted from the task, using the {@link Gnt.panel.Gantt#leftLabelField leftLabelField} option.
    *   You still need to provide some value for the `leftLabelField` to activate the label rendering
    * - `rightLabel` - the content for the right label (usually being extracted from the task, using the {@link Gnt.panel.Gantt#rightLabelField rightLabelField} option
    *   You still need to provide a value for the `rightLabelField` to activate the label rendering
    * - `topLabel` - the content for the top label (usually being extracted from the task, using the {@link Gnt.panel.Gantt#topLabelField topLabelField} option
    *   You still need to provide a value for the `topLabelField` to activate the label rendering
    * - `bottomLabel` - the content for the bottom label (usually being extracted from the task, using the {@link Gnt.panel.Gantt#bottomLabelField bottomLabelField} option
    *   You still need to provide some value for the `bottomLabelField` to activate the label rendering
    * - `basecls` - a CSS class to be add to the baseline DOM element, only applicable when the {@link Gnt.panel.Gantt#showBaseline showBaseline} option is true and the task contains baseline information
    * - `baseProgressBarStyle` - an inline CSS style to be applied to the baseline progress bar element
    *
    * Here is a sample usage of eventRenderer:

        eventRenderer : function (taskRec) {
            return {
                style : 'background-color:white',        // You can use inline styles too.
                cls   : taskRec.get('Priority'),         // Read a property from the task record, used as a CSS class to style the event
                foo   : 'some value'                     // Some custom value in your own template
            };
        }
    *
    * @param {Gnt.model.Task} taskRecord The task about to be rendered
    * @param {Gnt.data.TaskStore} ds The task store
    * @return {Object} The data which will be applied to the task template, creating the actual HTML
    */
    eventRenderer           : Ext.emptyFn,

    /**
    * @cfg {Object} eventRendererScope The scope (the "this" object)to use for the `eventRenderer` function
    */
    eventRendererScope      : null,

    /**
     * @cfg {Ext.XTemplate} eventTemplate The template used to render leaf tasks in the gantt view. See {@link Ext.XTemplate} for more information, see also {@link Gnt.template.Task} for the definition.
     */
    eventTemplate           : null,

    /**
     * @cfg {Ext.XTemplate} parentEventTemplate The template used to render parent tasks in the gantt view. See {@link Ext.XTemplate} for more information, see also {@link Gnt.template.ParentTask} for the definition
     */
    parentEventTemplate     : null,

    /**
     * @cfg {Ext.XTemplate} milestoneTemplate The template used to render milestone tasks in the gantt view. See {@link Ext.XTemplate} for more information, see also {@link Gnt.template.Milestone} for the definition. </p>
     */
    milestoneTemplate       : null,

    /**
     * @cfg {String} taskBodyTemplate The markup making up the body of leaf tasks in the gantt view. See also {@link Gnt.template.Task#innerTpl} for the definition.
     */
    taskBodyTemplate        : null,

    /**
     * @cfg {String} parentTaskBodyTemplate The markup making up the body of parent tasks in the gantt view. See also {@link Gnt.template.ParentTask#innerTpl} for the definition.
     */
    parentTaskBodyTemplate  : null,

    /**
     * @cfg {String} milestoneBodyTemplate The markup making up the body of milestone tasks in the gantt view. See also {@link Gnt.template.Milestone#innerTpl} for the definition.
     */
    milestoneBodyTemplate   : null,

    /**
     * @cfg {Boolean} autoHeight Always hardcoded to null, the `true` value is not yet supported (by Ext JS).
     */
    autoHeight              : null,

    /**
     * @cfg {Gnt.data.Calendar} calendar a {@link Gnt.data.Calendar calendar} instance for this gantt panel. Can be also provided
     * as a {@link Gnt.data.TaskStore#calendar configuration option} of the `taskStore`.
     */
    calendar        : null,

    /**
     * @cfg {Gnt.data.TaskStore} taskStore The {@link Gnt.data.TaskStore store} holding the tasks to be rendered into the gantt chart (required).
     */
    taskStore       : null,

    /**
     * @cfg {Gnt.data.DependencyStore} dependencyStore The {@link Gnt.data.DependencyStore store} holding the dependency information (optional).
     * See also {@link Gnt.model.Dependency}
     */
    dependencyStore : null,

    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore The {@link Gnt.data.ResourceStore store} holding the resources that can be assigned to the tasks in the task store(optional).
     * See also {@link Gnt.model.Resource}
     */
    resourceStore   : null,

    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore The {@link Gnt.data.AssignmentStore store} holding the assignments information (optional).
     * See also {@link Gnt.model.Assignment}
     */
    assignmentStore : null,

    columnLines     : false,

    /**
     * @method dndValidatorFn
     * An empty function by default, but provided so that you can perform custom validation on
     * the task being dragged. This function is called during the drag and drop process and also after the drop is made.
     *
     * @param {Gnt.model.Task} taskRecord The task record being dragged
     * @param {Date} date The new start date
     * @param {Int} duration The duration of the item being dragged, in minutes
     * @param {Ext.EventObject} e The event object
     *
     * @return {Boolean} true if the drop position is valid, else false to prevent a drop
     */
    dndValidatorFn      : Ext.emptyFn,

    /**
    * @method createValidatorFn
    * An empty function by default, but provided so that you can perform custom validation when a new task is being scheduled using drag and drop.
    * To indicate the newly scheduled dates of a task are invalid, simply return false from this method.
    * To control what 'this' points to inside this function, use the {@link #validatorFnScope} config option.
    * @param {Gnt.model.Task} taskRecord the task
    * @param {Date} startDate The start date
    * @param {Date} endDate The end date
    * @param {Event} e The browser event object
    * @return {Boolean} true if the creation event is valid, else false
    */
    createValidatorFn   : Ext.emptyFn,

    /**
     * @cfg {String} resizeHandles A string containing one of the following values
     *
     * - `none` - to disable resizing of tasks
     * - `left` - to enable changing of start date only
     * - `right` - to enable changing of end date only
     * - `both` - to enable changing of both start and end dates
     *
     * Default value is `both`. Resizing is performed with the {@link Gnt.feature.TaskResize} plugin.
     * You can customize it with the {@link #resizeConfig} and {@link #resizeValidatorFn} options
     */
    resizeHandles       : 'both',

    /**
     * @method resizeValidatorFn
     * An empty function by default, but provided so that you can perform custom validation on
     * a task being resized. Simply return false from your function to indicate that the new duration is invalid.
     *
     * @param {Gnt.model.Task} taskRecord The task being resized
     * @param {Date} startDate The new start date
     * @param {Date} endDate The new end date
     * @param {Ext.EventObject} e The event object
     *
     * @return {Boolean} true if the resize state is valid, else false to cancel
     */
    resizeValidatorFn   : Ext.emptyFn,

    /**
     *  @cfg {Object} resizeConfig A custom config object to pass to the {@link Gnt.feature.TaskResize} feature.
     */
    resizeConfig        : null,

    /**
     *  @cfg {Object} progressBarResizeConfig A custom config object to pass to the {@link Gnt.feature.ProgressBarResize} feature.
     */
    progressBarResizeConfig        : null,

    /**
     *  @cfg {Object} dragDropConfig A custom config object to pass to the {@link Gnt.feature.TaskDragDrop} feature.
     */
    dragDropConfig      : null,

    /**
     *  @cfg {Object} createConfig A custom config to pass to the {@link Gnt.feature.DragCreator} instance
     */
    createConfig        : null,

    /**
     *  @cfg {Boolean} autoFitOnLoad True to change the timeframe of the gantt to fit all the tasks in it after every task store load.
     *
     * See also {@link #zoomToFit}.
     */
    autoFitOnLoad       : false,

    refreshLockedTreeOnDependencyUpdate     : false,
    _lockedDependencyListeners : null,

    wbsColumn           : null,
    sequenceColumn       : null,
    earlyStartColumn    : null,
    earlyEndColumn      : null,
    lateStartColumn     : null,
    lateEndColumn       : null,

    earlyDatesListeners : null,
    lateDatesListeners  : null,
    slackListeners      : null,

    refreshTimeout      : 100,
    
    lastFocusedRecord           : null,
    lastFocusedRecordFrom       : null,
    

    getEventSelectionModel : function() {
        // By default return the underlying grid selection model
        return this.getSelectionModel();
    },


    initStores : function() {
        if (!this.taskStore) {
            Ext.Error.raise("You must specify a taskStore config.");
        }

        var taskStore = Ext.StoreMgr.lookup(this.taskStore);

        if (!taskStore) {
            Ext.Error.raise("You have provided an incorrect taskStore identifier");
        }

        if (!(taskStore instanceof Gnt.data.TaskStore)) {
            Ext.Error.raise("A `taskStore` should be an instance of `Gnt.data.TaskStore` (or of a subclass)");
        }

        Ext.apply(this, {
            store       : taskStore,          // For the grid panel API
            taskStore   : taskStore
        });

        var calendar    = this.calendar = taskStore.calendar;

        if (this.dependencyStore) {
            this.dependencyStore    = Ext.StoreMgr.lookup(this.dependencyStore);
            taskStore.setDependencyStore(this.dependencyStore);
        } else {
            this.dependencyStore    = taskStore.dependencyStore;
        }

        if (!(this.dependencyStore instanceof Gnt.data.DependencyStore)) {
            Ext.Error.raise("The Gantt dependency store should be a Gnt.data.DependencyStore, or a subclass thereof.");
        }

        // this resource store will be assigned to the task store in the "bindResourceStore" method
        var resourceStore           = this.resourceStore ? Ext.StoreMgr.lookup(this.resourceStore) : taskStore.getResourceStore();

        if (!(resourceStore instanceof Gnt.data.ResourceStore)) {
            Ext.Error.raise("A `ResourceStore` should be an instance of `Gnt.data.ResourceStore` (or of a subclass)");
        }

        // this assignment store will be assigned to the task store in the "bindAssignmentStore" method
        var assignmentStore         = this.assignmentStore ? Ext.StoreMgr.lookup(this.assignmentStore) : taskStore.getAssignmentStore();

        if (!(assignmentStore instanceof Gnt.data.AssignmentStore)) {
            Ext.Error.raise("An `assignmentStore` should be an instance of `Gnt.data.AssignmentStore` (or of a subclass)");
        }

        this.bindAssignmentStore(assignmentStore, true);
        this.bindResourceStore(resourceStore, true);

        if (this.needToTranslateOption('weekendsAreWorkdays')) {
            // may trigger a renormalization of all tasks - need all stores to be defined
            calendar.setWeekendsAreWorkDays(this.weekendsAreWorkdays);
        }
    },

    initComponent : function() {
        var me = this;

        // @BackwardsCompat, remove in Gantt 3.0
        if (Ext.isBoolean(this.showBaseline)) {
            this.enableBaseline = this.baselineVisible = this.showBaseline;
            this.showBaseline = Gnt.panel.Gantt.prototype.showBaseline;
        }

        this.autoHeight     = false;

        this.initStores();

        if (this.needToTranslateOption('cascadeChanges')) {
            this.setCascadeChanges(this.cascadeChanges);
        }

        if (this.needToTranslateOption('recalculateParents')) {
            this.setRecalculateParents(this.recalculateParents);
        }

        if (this.needToTranslateOption('skipWeekendsDuringDragDrop')) {
            this.setSkipWeekendsDuringDragDrop(this.skipWeekendsDuringDragDrop);
        }

        var viewConfig = this.normalViewConfig = this.normalViewConfig || {};

        // Copy some properties to the view instance
        Ext.apply(this.normalViewConfig, {
            taskStore               : this.taskStore,
            dependencyStore         : this.dependencyStore,

            enableDependencyDragDrop    : this.enableDependencyDragDrop,
            enableTaskDragDrop          : this.enableTaskDragDrop,
            enableProgressBarResize     : this.enableProgressBarResize,
            enableDragCreation          : this.enableDragCreation,

            allowParentTaskMove         : this.allowParentTaskMove,
            toggleParentTasksOnClick    : this.toggleParentTasksOnClick,

            resizeHandles               : this.resizeHandles,
            enableBaseline              : this.baselineVisible || this.enableBaseline,

            leftLabelField              : this.leftLabelField,
            rightLabelField             : this.rightLabelField,
            topLabelField               : this.topLabelField,
            bottomLabelField            : this.bottomLabelField,

            eventTemplate               : this.eventTemplate,
            parentEventTemplate         : this.parentEventTemplate,
            milestoneTemplate           : this.milestoneTemplate,

            taskBodyTemplate            : this.taskBodyTemplate,
            parentTaskBodyTemplate      : this.parentTaskBodyTemplate,
            milestoneBodyTemplate       : this.milestoneBodyTemplate,

            resizeConfig                : this.resizeConfig,
            dragDropConfig              : this.dragDropConfig
        });


        if (this.topLabelField || this.bottomLabelField) {
            this.addCls('sch-gantt-topbottom-labels ' + (this.topLabelField ? 'sch-gantt-top-label' : ''));
            this.normalViewConfig.rowHeight = 52;
        }

        this.configureFunctionality();

        this.mon(this.taskStore, {
            beforecascade   : this.onBeforeCascade,
            cascade         : this.onAfterCascade,

            beforeindentationchange     : this.onBeforeIndentChange,
            indentationchange           : this.onIndentChange,

            scope           : this
        });

        this.callParent(arguments);

        if (this.autoFitOnLoad) {
            // if store already loaded
            if (this.store.getCount()) {
                this.zoomToFit();
            }

            this.mon(this.store, 'load', function () {
                this.zoomToFit();
            }, this);
        }

        this.bodyCls = (this.bodyCls || '') + " sch-ganttpanel-container-body";

        var ganttView = this.getSchedulingView();
        ganttView.store.calendar = this.calendar;

        this.relayEvents(ganttView, [
            /**
            * @event taskclick
            * Fires when a task is clicked
            *
            * @param {Gnt.view.Gantt} gantt The gantt panel instance
            * @param {Gnt.model.Task} taskRecord The task record
            * @param {Ext.EventObject} e The event object
            */
            'taskclick',

            /**
            * @event taskdblclick
            * Fires when a task is double clicked
            *
            * @param {Gnt.view.Gantt} gantt The gantt panel instance
            * @param {Gnt.model.Task} taskRecord The task record
            * @param {Ext.EventObject} e The event object
            */
            'taskdblclick',

            /**
            * @event taskcontextmenu
            * Fires when contextmenu is activated on a task
            *
            * @param {Gnt.view.Gantt} gantt The gantt panel instance
            * @param {Gnt.model.Task} taskRecord The task record
            * @param {Ext.EventObject} e The event object
            */
            'taskcontextmenu',

            // Resizing events start --------------------------
            /**
            * @event beforetaskresize
            * Fires before a resize starts, return false to stop the execution
            *
            * @param {Gnt.view.Gantt} gantt The gantt panel instance
            * @param {Gnt.model.Task} taskRecord The task about to be resized
            * @param {Ext.EventObject} e The event object
            */
            'beforetaskresize',

            /**
            * @event taskresizestart
            * Fires when resize starts
            *
            * @param {Gnt.view.Gantt} gantt The gantt panel instance
            * @param {Gnt.model.Task} taskRecord The task about to be resized
            */
            'taskresizestart',

            /**
            * @event partialtaskresize
            * Fires during a resize operation and provides information about the current start and end of the resized event
            * @param {Gnt.view.Gantt} gantt The gantt panel instance
            * @param {Gnt.model.Task} taskRecord The task being resized
            * @param {Date} startDate The start date of the task
            * @param {Date} endDate The end date of the task
            * @param {Ext.Element} The element being resized
            */
            'partialtaskresize',

            /**
            * @event aftertaskresize
            * Fires after a succesful resize operation
            * @param {Gnt.view.Gantt} gantt The gantt panel instance
            * @param {Gnt.model.Task} taskRecord The task that has been resized
            */
            'aftertaskresize',
            // Resizing events end --------------------------

            // Task progress bar resizing events start --------------------------
            /**
            * @event beforeprogressbarresize
            * Fires before a progress bar resize starts, return false to stop the execution
            * @param {Gnt.view.Gantt} gantt The gantt panel instance
            * @param {Gnt.model.Task} taskRecord The record about to be have its progress bar resized
            */
            'beforeprogressbarresize',

            /**
            * @event progressbarresizestart
            * Fires when a progress bar resize starts
            * @param {Gnt.view.Gantt} gantt The gantt panel instance
            * @param {Gnt.model.Task} taskRecord The record about to be have its progress bar resized
            */
            'progressbarresizestart',

            /**
            * @event afterprogressbarresize
            * Fires after a succesful progress bar resize operation
            * @param {Gnt.view.Gantt} gantt The gantt panel instance
            * @param {Gnt.model.Task} taskRecord record The updated record
            */
            'afterprogressbarresize',
            // Task progressbar resizing events end --------------------------

            // Dnd events start --------------------------
            /**
            * @event beforetaskdrag
            * Fires before a task drag drop is initiated, return false to cancel it
            * @param {Gnt.view.Gantt} gantt The gantt panel instance
            * @param {Gnt.model.Task} taskRecord The task record that's about to be dragged
            * @param {Ext.EventObject} e The event object
            */
            'beforetaskdrag',

            /**
            * @event taskdragstart
            * Fires when a dnd operation starts
            * @param {Gnt.view.Gantt} gantt The gantt panel instance
            * @param {Gnt.model.Task} taskRecord The record being dragged
            */
            'taskdragstart',

            /**
            * @event taskdrop
            * Fires after a succesful drag and drop operation
            * @param {Gnt.view.Gantt} gantt The gantt panel instance
            * @param {Gnt.model.Task} taskRecord The dropped record
            */
            'taskdrop',

            /**
            * @event aftertaskdrop
            * Fires after a drag and drop operation, regardless if the drop valid or invalid
            * @param {Gnt.view.Gantt} gantt The gantt panel instance
            */
            'aftertaskdrop',
            // Dnd events end --------------------------

            /**
            * @event labeledit_beforestartedit
            * Fires before editing is started for a field
            * @param {Gnt.view.Gantt} gantt The gantt view instance
            * @param {Gnt.model.Task} taskRecord The task record
            * @param {Mixed} value The field value being set
            * @param {Gnt.feature.LabelEditor} editor The editor instance
            */
            'labeledit_beforestartedit',

            /**
            * @event labeledit_beforecomplete
            * Fires after a change has been made to a label field, but before the change is reflected in the underlying field.
            * @param {Gnt.view.Gantt} gantt The gantt view instance
            * @param {Mixed} value The current field value
            * @param {Mixed} startValue The original field value
            * @param {Gnt.model.Task} taskRecord The affected record
            * @param {Gnt.feature.LabelEditor} editor The editor instance
            */
            'labeledit_beforecomplete',

            /**
            * @event labeledit_complete
            * Fires after editing is complete and any changed value has been written to the underlying field.
            * @param {Gnt.view.Gantt} gantt The gantt view instance
            * @param {Mixed} value The current field value
            * @param {Mixed} startValue The original field value
            * @param {Gnt.model.Task} taskRecord The affected record
            * @param {Gnt.feature.LabelEditor} editor The editor instance
            */
            'labeledit_complete',

            // Dependency drag drop events --------------------------
            /**
            * @event beforedependencydrag
            * Fires before a dependency drag operation starts (from a "task terminal"). Return false to prevent this operation from starting.
            * @param {Gnt.view.Dependency} gantt The gantt panel instance
            * @param {Gnt.model.Task} taskRecord The source task record
            */
            'beforedependencydrag',

            /**
            * @event dependencydragstart
            * Fires when a dependency drag operation starts
            * @param {Gnt.view.Dependency} gantt The gantt panel instance
            */
            'dependencydragstart',

            /**
            * @event dependencydrop
            * Fires when a dependency drag drop operation has completed successfully and a new dependency has been created.
            * @param {Gnt.view.Dependency} gantt The gantt panel instance
            * @param {Gnt.model.Task} fromRecord The source task record
            * @param {Gnt.model.Task} toRecord The destination task record
            * @param {Int} type The dependency type
            */
            'dependencydrop',

            /**
            * @event afterdependencydragdrop
            * Always fires after a dependency drag-drop operation
            * @param {Gnt.view.Dependency} gantt The gantt panel instance
            */
            'afterdependencydragdrop',

            /**
             * @event dependencyclick
             * Fires after clicking on a dependency line/arrow
             * @param {Gnt.view.Dependency} g The dependency view instance
             * @param {Gnt.model.Dependency} record The dependency record
             * @param {Ext.EventObject} event The event object
             * @param {HTMLElement} target The target of this event
             */
            'dependencyclick',

            /**
             * @event dependencycontextmenu
             * Fires after right clicking on a dependency line/arrow
             * @param {Gnt.view.Dependency} g The dependency view instance
             * @param {Gnt.model.Dependency} record The dependency record
             * @param {Ext.EventObject} event The event object
             * @param {HTMLElement} target The target of this event
             */
            'dependencycontextmenu',

            /**
            * @event dependencydblclick
            * Fires after double clicking on a dependency line/arrow
            * @param {Gnt.view.Dependency} g The dependency view instance
            * @param {Gnt.model.Dependency} record The dependency record
            * @param {Ext.EventObject} event The event object
            * @param {HTMLElement} target The target of this event
            */
            'dependencydblclick',
            // EOF Dependency drag drop events --------------------------

            /**
             * @event scheduleclick
             * Fires after a click on the schedule area
             * @param {Gnt.panel.Gantt} gantt The gantt panel object
             * @param {Date} clickedDate The clicked date
             * @param {Int} rowIndex The row index
             * @param {Ext.EventObject} e The event object
             */
            'scheduleclick',

            /**
             * @event scheduledblclick
             * Fires after a doubleclick on the schedule area
             * @param {Gnt.panel.Gantt} gantt The gantt panel object
             * @param {Date} clickedDate The clicked date
             * @param {Int} rowIndex The row index
             * @param {Ext.EventObject} e The event object
             */
            'scheduledblclick',

            /**
             * @event schedulecontextmenu
             * Fires after a context menu click on the schedule area
             * @param {Gnt.panel.Gantt} gantt The gantt panel object
             * @param {Date} clickedDate The clicked date
             * @param {Int} rowIndex The row index
             * @param {Ext.EventObject} e The event object
             */
            'schedulecontextmenu'
        ]);

        if (this.addRowOnTab) {
            var sm = this.getSelectionModel();

            // HACK overwriting private Ext JS method
            sm.onEditorTab = Ext.Function.createInterceptor(sm.onEditorTab, this.onEditorTabPress, this);
        }

        var view = this.getSchedulingView();
        this.registerRenderer(view.columnRenderer, view);

        var cls = ' sch-ganttpanel sch-horizontal ';

        if (this.highlightWeekends) {
            cls += ' sch-ganttpanel-highlightweekends ';
        }

        if (!this.rtl) {
            cls += ' sch-ltr ';
        }

        this.addCls(cls);

        if (this.baselineVisible) {
            this.showBaseline();
        }

        // Editors belong in the locked grid, otherwise they float visibly on top of the normal grid when scrolling the locked grid
        this.on('add', function(me, cmp) {
            if (cmp instanceof Ext.Editor) {
                me.lockedGrid.suspendLayouts();
                Ext.suspendLayouts();
                me.lockedGrid.add(cmp);
                Ext.resumeLayouts();

                me.lockedGrid.resumeLayouts();
            }
        });

        // Prevent editing of non-editable fields
        this.on('beforeedit', function(editor, o) {
            return o.record.isEditable(o.field);
        }, this);

        var lockedHeader = this.lockedGrid.headerCt;

        this.wbsColumn          = lockedHeader.down('wbscolumn');
        if (this.wbsColumn) {
            this.bindAutoGeneratedListeners(this.wbsColumn);
        }

        this.sequenceColumn      = lockedHeader.down('sequencecolumn');
        if (this.sequenceColumn) {
            this.bindAutoGeneratedListeners(this.sequenceColumn);
        }

        this.slackColumn        = lockedHeader.down('slackcolumn');
        if (this.slackColumn) {
            this.bindSlackListeners();
        }

        this.earlyStartColumn   = lockedHeader.down('earlystartdatecolumn');
        this.earlyEndColumn     = lockedHeader.down('earlyenddatecolumn');
        if (this.earlyStartColumn || this.earlyEndColumn) {
            this.bindEarlyDatesListeners();
        }

        this.lateStartColumn    = lockedHeader.down('latestartdatecolumn');
        this.lateEndColumn      = lockedHeader.down('lateenddatecolumn');
        if (this.lateStartColumn || this.lateEndColumn) {
            this.bindLateDatesListeners();
        }
    },


    // Make sure views doesn't react to store changes during cascading
    onBeforeCascade : function () {
        var normalStore = this.normalGrid.getView().store;

        normalStore.suspendEvents();

        Ext.suspendLayouts();
    },


    // Re-activate view->store listeners and update views if needed
    onAfterCascade : function (treeStore, context) {
        var me              = this;
        var normalStore     = this.normalGrid.getView().store;

        normalStore.resumeEvents();
        Ext.resumeLayouts();

        if (context.nbrAffected > 0) {
            var normalView  = this.normalGrid.getView();
            var lockedView  = this.lockedGrid.getView();
            var ed = this.lockedGrid.plugins[0] && this.lockedGrid.plugins[0].activeEditor;
            var old, old2, old3, old4;

            if (ed) {
                // MONSTERHACK, To avoid scroll position + editor moving around after the side-effect refresh
                // we need to get rid of some methods, which also causes crashes in IE8.
                old = ed.realign;
                old2 = ed.alignTo;
                old3 = ed.setPosition;
                old4 = lockedView.preserveScrollOnRefresh;
                ed.realign = Ext.emptyFn;
                ed.alignTo = Ext.emptyFn;
                ed.setPosition = Ext.emptyFn;
                lockedView.preserveScrollOnRefresh = true;
            }

            normalView.refreshKeepingScroll(true);

            Ext.suspendLayouts();

            lockedView.refresh();

            Ext.resumeLayouts(true);

            // MONSTERHACK, continued
            if (ed) {
                ed.realign = old;
                ed.alignTo = old2;
                ed.setPosition = old3;
                lockedView.preserveScrollOnRefresh = old4;
            }
        }
    },

    onBeforeIndentChange : function(store) {
        var lockedView      = this.lockedGrid.view;
        var activeElement   = document.activeElement;
        
        // sometimes activeElement is empty, sometimes (in IE10) its an empty JS object (not a DOM element at all)
        if (!lockedView.rendered || !activeElement || !activeElement.tagName) return;
        
        var rowEl           = Ext.fly(activeElement).findParent(lockedView.itemSelector);
        
        if (rowEl) {
            var lastFocusedRecord   = lockedView.getRecord(rowEl);
            
            if (lastFocusedRecord) {
                this.lastFocusedRecordFrom = lockedView.el.contains(rowEl) ? 'lockedGrid' : 'normalGrid';
            }
            
            this.lastFocusedRecord  = lastFocusedRecord;
        }
    },

    onIndentChange : function(store) {
        var lastFocusedRecord       = this.lastFocusedRecord;
        
        if (lastFocusedRecord) {
            this[ this.lastFocusedRecordFrom ].view.focusRow(lastFocusedRecord);
            
            this.lastFocusedRecord  = null;
        }
    },

    bindAutoGeneratedListeners: function (column) {
        var lockedView = this.lockedGrid.view;

        this.mon(this.taskStore, {
            insert     : function(store, records, refNode) {
                this.updateAutoGeneratedCells(column, refNode ? lockedView.store.indexOf(refNode) : 1);
            },

            remove : function(store, record) {
                // HACK private property 'removeContext'
                var ctx = record.removeContext;
                var recordBelow = ctx.nextSibling || (ctx.parentNode && ctx.parentNode.nextSibling);
                var index = recordBelow ? lockedView.store.indexOf(recordBelow) : -1;

                if (index >= 0) {
                    this.updateAutoGeneratedCells(column, index);
                }
            },
            scope : this
        });
    },


    bindSlackListeners : function () {
        var lockedView = this.lockedGrid.getView();

        var updateSlackColumns = Ext.Function.createBuffered(this.updateSlackColumns, this.refreshTimeout, this, []);

        this.slackListeners = this.mon(this.taskStore, {
            resetearlydates : updateSlackColumns,
            resetlatedates  : updateSlackColumns,
            scope           : this,
            destroyable     : true
        });
    },

    bindEarlyDatesListeners : function () {
        var lockedView = this.lockedGrid.getView();

        var updateEarlyDateColumns = Ext.Function.createBuffered(this.updateEarlyDateColumns, this.refreshTimeout, this, []);

        this.earlyDatesListeners = this.mon(this.taskStore, {
            resetearlydates : updateEarlyDateColumns,
            scope           : this,
            destroyable     : true
        });
    },

    bindLateDatesListeners : function () {
        var lockedView = this.lockedGrid.getView();

        var updateLateDateColumns = Ext.Function.createBuffered(this.updateLateDateColumns, this.refreshTimeout, this, []);

        this.lateDatesListeners = this.mon(this.taskStore, {
            resetlatedates  : updateLateDateColumns,
            scope           : this,
            destroyable     : true
        });
    },

    onEditorTabPress : function(editingPlugin, e) {
        var view = this.lockedGrid.view,
            record = editingPlugin.getActiveRecord(),
            header = editingPlugin.getActiveColumn(),
            position = view.getPosition(record, header),
            headerCt = this.lockedGrid.headerCt,
            isLastRow = position.row === this.lockedGrid.view.store.getCount()- 1,
            isLastColChecker = function(col) {
                return headerCt.items.indexOf(col) > position.column && col.isVisible() && col.getEditor();
            };

        // Check if this is the last (visible) column of the last row
        if (isLastRow && headerCt.items.findIndexBy(isLastColChecker) < 0) {
            record.addTaskBelow({ leaf : true });
        }
    },

    // this function checks whether the configuration option should be translated to task store or calendar
    // idea is that some configuration option (`cascadeChanges` for example) actually belongs to TaskStore
    // so they are not persisted in the gantt panel (panel only provides accessors which reads/write from/to TaskStore)
    // however the values for those options could also be specified in the prototype of the Gnt.panel.Gantt subclass
    // see #172
    needToTranslateOption : function (optionName) {
        return this.hasOwnProperty(optionName) || this.self.prototype.hasOwnProperty(optionName) && this.self != Gnt.panel.Gantt;
    },

    /**
     * Getter function returning the dependency view instance
     * @return {Gnt.view.Dependency} dependencyView The dependency view instance
     */
    getDependencyView : function() {
        return this.getSchedulingView().getDependencyView();
    },

    /**
     * Toggles the weekend highlighting on or off
     * @param {Boolean} disabled
     */
    disableWeekendHighlighting : function(disabled) {
        this.workingTimePlugin.setDisabled(disabled);
    },

    /**
     * <p>Returns the task record for a DOM node</p>
     * @param {Ext.Element/HTMLElement} el The DOM node or Ext Element to lookup
     * @return {Gnt.model.Task} The task record
     */
    resolveTaskRecord: function (el) {
        return this.getSchedulingView().resolveTaskRecord(el);
    },

    /**
     * Tries to fit the time columns to the available view width
     */
    fitTimeColumns : function() {
        this.getSchedulingView().fitColumns();
    },

    /**
     * Returns the resource store associated with the Gantt panel instance
     * @return {Gnt.data.ResourceStore}
     */
    getResourceStore : function() {
        return this.getTaskStore().getResourceStore();
    },

    /**
     * Returns the assignment store associated with the Gantt panel instance
     * @return {Gnt.data.AssignmentStore}
     */
    getAssignmentStore : function() {
        return this.getTaskStore().getAssignmentStore();
    },

    /**
     * Returns the associated task store
     * @return {Gnt.data.TaskStore}
     */
    getTaskStore : function() {
        return this.taskStore;
    },


    /**
     * Returns the associated dependency store
     * @return {Gnt.data.DependencyStore}
     */
    getDependencyStore : function() {
        return this.dependencyStore;
    },



    // private
    onDragDropStart : function() {
        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }
    },

    // private
    onDragDropEnd : function() {
        if (this.tip) {
            this.tip.enable();
        }
    },


    // private
    configureFunctionality : function() {
        // Normalize to array
        var plugins     = this.plugins    = [].concat(this.plugins || []);

        if (this.highlightWeekends) {

            this.workingTimePlugin = Ext.create("Gnt.feature.WorkingTime", {
                calendar        : this.calendar
            });

            plugins.push(this.workingTimePlugin);
        }

        if (this.showTodayLine) {
            this.todayLinePlugin = new Sch.plugin.CurrentTimeLine();
            plugins.push(this.todayLinePlugin);
        }
    },

    /**
     * If configured to highlight non-working time, this method returns the {@link Gnt.feature.WorkingTime workingTime} feature
     * responsible for providing this functionality.
     * @return {Gnt.feature.WorkingTime} workingTime
     */
    getWorkingTimePlugin : function() {
        return this.workingTimePlugin;
    },

    registerLockedDependencyListeners : function() {
        var me = this;
        var depStore = this.getDependencyStore();

        // Need to save these to be able to deregister them properly.
        this._lockedDependencyListeners = this._lockedDependencyListeners || {
            load    : function() {
                var taskStore = me.getTaskStore();

                // reset cached early/late dates
                taskStore.resetEarlyDates();
                taskStore.resetLateDates();

                me.lockedGrid.getView().refresh();
            },
            
            clear : function () {
                var taskStore = me.getTaskStore();

                // reset cached early/late dates
                taskStore.resetEarlyDates();
                taskStore.resetLateDates();

                me.lockedGrid.getView().refresh();
            },

            add     : function(depStore, records) {
                for (var i = 0; i < records.length; i++) {
                    me.updateDependencyTasks(records[i]);
                }
            },

            update  : function(depStore, record) {
                var view = me.lockedGrid.view;
                var viewStore = view.store;

                if (record.previous[record.fromField]) {
                    var prevFromTask = me.taskStore.getByInternalId(record.previous[record.fromField]);

                    if (prevFromTask) {
                        view.refreshNode(viewStore.indexOf(prevFromTask));
                    }
                }

                if (record.previous[record.toField]) {
                    var prevToTask = me.taskStore.getByInternalId(record.previous[record.toField]);

                    if (prevToTask) {
                        view.refreshNode(viewStore.indexOf(prevToTask));
                    }
                }

                me.updateDependencyTasks(record);
            },

            remove  : function(depStore, record) {
                me.updateDependencyTasks(record);
            }
        };

        // This could be called multiple times, if both predecessor and successor columns are used
        depStore.un(this._lockedDependencyListeners);
        depStore.on(this._lockedDependencyListeners);
    },

    updateDependencyTasks : function(depRecord) {
        var sourceTask = depRecord.getSourceTask(this.taskStore);
        var targetTask = depRecord.getTargetTask(this.taskStore);
        var lockedView = this.lockedGrid.getView();
        var sourceIndex = lockedView.store.indexOf(sourceTask);
        var targetIndex = lockedView.store.indexOf(targetTask);

        if (sourceTask && sourceIndex >= 0) {
            lockedView.refreshNode(sourceIndex);
        }
        if (targetTask && targetIndex >= 0) {
            lockedView.refreshNode(targetIndex);
        }
    },

    /**
     * Shows the baseline tasks
     */
    showBaseline : function() {
        this.addCls('sch-ganttpanel-showbaseline');
    },

    /**
     * Hides the baseline tasks
     */
    hideBaseline : function() {
        this.removeCls('sch-ganttpanel-showbaseline');
    },

    /**
     * Toggles the display of the baseline
     */
    toggleBaseline : function () {
        this.toggleCls('sch-ganttpanel-showbaseline');
    },

    /**
     * Changes the timeframe of the gantt to fit all the tasks in it.
     * @param {Gnt.model.Task/Gnt.model.Task[]} [tasks] List of tasks to fit.
     * If not specified then the gantt will try to fit all the tasks from the {@link #taskStore task store}.
     */
    zoomToFit : function (tasks) {
        var span = tasks ? this.taskStore.getTasksTimeSpan(tasks) : this.taskStore.getTotalTimeSpan();

        if (this.zoomToSpan(span) === null) {
            // if no zooming was performed - fit columns to view space
            if (!tasks) this.fitTimeColumns();
        }
    },


    /**
     * "Get" accessor for the `cascadeChanges` option
     */
    getCascadeChanges : function () {
        return this.taskStore.cascadeChanges;
    },


    /**
     * "Set" accessor for the `cascadeChanges` option
     */
    setCascadeChanges : function (value) {
        this.taskStore.cascadeChanges = value;
    },


    /**
     * "Get" accessor for the `recalculateParents` option
     */
    getRecalculateParents : function () {
        return this.taskStore.recalculateParents;
    },


    /**
     * "Set" accessor for the `recalculateParents` option
     */
    setRecalculateParents : function (value) {
        this.taskStore.recalculateParents = value;
    },


    /**
     * "Set" accessor for the `skipWeekendsDuringDragDrop` option
     */
    setSkipWeekendsDuringDragDrop : function (value) {
        this.taskStore.skipWeekendsDuringDragDrop = this.skipWeekendsDuringDragDrop = value;
    },


    /**
     * "Get" accessor for the `skipWeekendsDuringDragDrop` option
     */
    getSkipWeekendsDuringDragDrop : function () {
        return this.taskStore.skipWeekendsDuringDragDrop;
    },

    bindResourceStore : function(resourceStore, initial) {
        var me = this;
        var listeners = {
            scope       : me,
            update      : me.onResourceStoreDataChanged,
            datachanged : me.onResourceStoreDataChanged //TODO Wasteful
        };

        if (!initial && me.resourceStore) {
            if (resourceStore !== me.resourceStore && me.resourceStore.autoDestroy) {
                me.resourceStore.destroy();
            }
            else {
                me.mun(me.resourceStore, listeners);
            }
            if (!resourceStore) {
                me.resourceStore = null;
            }
        }
        if (resourceStore) {
            resourceStore = Ext.data.StoreManager.lookup(resourceStore);
            me.mon(resourceStore, listeners);
            this.taskStore.setResourceStore(resourceStore);
        }

        me.resourceStore = resourceStore;

        if (resourceStore && !initial) {
            me.refreshViews();
        }
    },

    refreshViews : function() {
        this.lockedGrid.getView().refresh();
        this.getSchedulingView().refreshKeepingScroll();
    },

    bindAssignmentStore : function(assignmentStore, initial) {
        var me = this;

        if (!initial && me.assignmentStore) {
            if (assignmentStore !== me.assignmentStore && me.assignmentStore.autoDestroy) {
                me.assignmentStore.destroy();
            }
            else {
                me.mun(me.assignmentStore, {
                    scope       : me,
                    update      : me.onAssignmentStoreDataChanged,
                    datachanged : me.onAssignmentStoreDataChanged //TODO Wasteful
                });
            }
            if (!assignmentStore) {
                me.assignmentStore = null;
            }
        }
        if (assignmentStore) {
            assignmentStore = Ext.data.StoreManager.lookup(assignmentStore);
            me.mon(assignmentStore, {
                scope       : me,
                update      : me.onAssignmentStoreDataChanged,
                datachanged : me.onAssignmentStoreDataChanged //TODO Wasteful
            });
            this.taskStore.setAssignmentStore(assignmentStore);
        }

        me.assignmentStore = assignmentStore;

        if (assignmentStore && !initial) {
            me.refreshViews();
        }
    },

    onResourceStoreDataChanged : function() {
        if (this.taskStore.getRootNode().childNodes.length > 0) {
            this.refreshViews();
        }
    },

    onAssignmentStoreDataChanged : function() {
        if (this.taskStore.getRootNode().childNodes.length > 0) {
            this.refreshViews();
        }
    },

    expandAll : function() {
        // Base implementation triggers too many unnecessary relayouts
        Ext.suspendLayouts();
        this.callParent(arguments);
        Ext.resumeLayouts();
    },


    collapseAll : function() {
        // Base implementation triggers too many unnecessary relayouts
        Ext.suspendLayouts();
        this.callParent(arguments);
        Ext.resumeLayouts();
    },

    updateAutoGeneratedCells : function(column, rowIndex) {
        if (rowIndex < 0) return;

        var view = this.lockedGrid.view;

        for (var i = rowIndex; i < view.getNodes().length; i++)  {
            var rec = view.store.getAt(i);
            var cell = view.getCell(rec, column);

            if (cell) {
                cell.dom.firstChild.innerHTML = column.renderer(null, null, rec);
            }
        }
    },

    redrawColumns : function (cols) {
        var view = this.lockedGrid.view;

        if (cols.length) {
            var isLessThan422   = Ext.getVersion('extjs').isLessThan('4.2.2.1144');
            
            for (var i = 0, l = view.getNodes().length; i < l; i++)  {
                var rec = view.store.getAt(i);

                for (var j = 0, ll = cols.length; j < ll; j++)  {

                    var cell = view.getCell(rec, cols[j]);
                    var out = [];

                    if (isLessThan422) { 
                        view.renderCell(cols[j], rec, i, cols[j].getIndex(), out);
                    } else {
                        view.renderCell(cols[j], rec, i, cols[j].getIndex(), i, out);
                    }
                        
                    cell.update(out.join(''));
                }
            }
        }
    },

    updateSlackColumns : function () {
        var view = this.lockedGrid.view;

        if (this.slackColumn) this.redrawColumns([ this.slackColumn ]);
    },

    updateEarlyDateColumns : function () {
        var view = this.lockedGrid.view;

        var cols = [];
        if (this.earlyStartColumn) cols.push(this.earlyStartColumn);
        if (this.earlyEndColumn) cols.push(this.earlyEndColumn);

        if (cols.length) this.redrawColumns(cols);
    },

    updateLateDateColumns : function () {
        var view = this.lockedGrid.view;

        var cols = [];
        if (this.lateStartColumn) cols.push(this.lateStartColumn);
        if (this.lateEndColumn) cols.push(this.lateEndColumn);

        if (cols.length) this.redrawColumns(cols);
    },

    afterRender : function() {
        this.callParent(arguments);

        // HACK to solve a bug with cell editing in Ext 4.2.1
        this.getSelectionModel().view = this.lockedGrid.getView();
    }
});

/**

@class Gnt.panel.ResourceHistogram
@extends Sch.panel.TimelineGridPanel

A histogram panel, which allows you to visualize resource utilization and highlight overallocation.
The panel is a subclass of the Ext.grid.Panel class so any normal grid configs can be applied to it.

#Two ways of using

You can either use this widget as a standalone panel or it can be used together with a {@link Gnt.panel.Gantt gantt panel}.
When using it together with a {@link Gnt.panel.Gantt gantt panel} you need to specify its instance as the {@link #partnerTimelinePanel} config.

#Predefined columns

The panel has a default set of columns which is used if no `columns` config has been specified.
The default columns include a resource name column and a {@link Gnt.column.Scale scale column} to display a resource utilization scale.

For example in the following code snippet, the histogram will be created with a default set of columns:

    var histogram = Ext.create('Gnt.panel.ResourceHistogram', {
        taskStore           : taskStore,
        resourceStore       : resourceStore,
        viewPreset          : 'weekAndDayLetter',
        startDate           : new Date(2010, 0, 11),
        endDate             : new Date(2010, 1, 11),
        renderTo            : Ext.getBody()
    });


{@img gantt/images/histogram-panel.png}

*/
Ext.define('Gnt.panel.ResourceHistogram', {
    extend                  : 'Sch.panel.TimelineGridPanel',

    requires                : [
        'Ext.XTemplate',
        'Sch.util.Date',
        'Gnt.feature.WorkingTime',
        'Gnt.column.Scale',
        'Gnt.view.ResourceHistogram'
    ],

    alias                   : 'widget.resourcehistogram',

    viewType                : 'resourcehistogramview',

    layout                  : 'border',

    preserveScrollOnRefresh : true,

    /**
     * @cfg {Ext.XTemplate} barTpl The template used to render the bars in the histogram view.
     *
     * When specifying a custom template please make sure that the bar element must have:
     *
     *  - unique `id` attribute, like this: ... id="{id}" ...
     *  - `gnt-bar-index` attribute defined this way: ... gnt-bar-index="{index}" ...
     *  - support for {@link #barCls} config.
     *  - support bar labels
     *
     * Please take a look at the default markup of this template to see an example of how the above restrictions can be applied:
     *
     *      this.barTpl = new Ext.XTemplate(
     *          '<tpl for=".">',
     *              '<div id="{id}" class="'+ this.barCls +' {cls}" gnt-bar-index="{index}" style="left:{left}px;top:{top}px;height:{height}px;width:{width}px"></div>',
     *              // here we check if this bar should have a label
     *              '<tpl if="text !== \'\'">',
     *                  '<span class="'+ this.barCls +'-text" style="left:{left}px;">{text}</span>',
     *              '</tpl>',
     *          '</tpl>'
     *      );
     *
     * See {@link Ext.XTemplate} for more information on templates syntax.
     */

    /**
     * @cfg {String} barCls The CSS class to apply to rendered bars in the histogram view.
     * This can be used if you want to implement your own bar styling.
     */

    /**
     * @cfg {Ext.XTemplate} lineTpl The template used to render the scale line in the histogram view.
     */

    /**
     * @cfg {String} lineCls The CSS class to apply to scale lines in the histogram view.
     * This can be used if you want to implement your own line styling.
     */

    /**
     * @cfg {Ext.XTemplate} limitLineTpl The template used to render the maximum resource utilization line in the histogram view.
     */

    /**
     * @cfg {String} limitLineCls The CSS class to apply to the maximum resource utilization lines in the histogram view.
     * This can be used if you want to implement your own line styling.
     */

    /**
     * @cfg {Number} limitLineWidth The width of the maximum resource utilization line. Used for the line coordinates calculations.
     * Should be specified only if the width of that utilization line was changed as result of any custom styling.
     */

    /**
     * @cfg {Mixed} labelMode Defines the type of scale labels to be used or disables labels completely.
     * Possible values are:
     *
     *  - empty string or `false` to disable labels (default).
     *  - `units` - displays the per day allocation in {@link #scaleUnit units}.
     *  - `percent` - displays the per day allocation in percents.
     *  - any other non-empty value will be considered as compiled `Ext.XTemplate` instance.
     */

    /**
     * @cfg {String} labelPercentFormat Defines the label format to use when the {@link #labelMode} is set to `percent`.
     *
     * For more details on format usage please refer to the `Ext.util.Format.number` method description.
     */

    /**
     * @cfg {String} labelUnitsFormat Defines the label format to use when the {@link #labelMode} is set to `units`.
     *
     * For more details on format usage please refer to the `Ext.util.Format.number` method description.
     */

    /**
     * @cfg {Object[]} scalePoints Alternative way of defining the utilization scale.
     * Can be used instead of setting {@link #scaleMin}, {@link #scaleMax}, {@link #scaleStep} configs.
     * When using the default columns, this config will be applied to the {@link Gnt.column.Scale} instance.
     *
     * For usage details please refer to the {@link Gnt.column.Scale#scalePoints scalePoints} property.
     */

    /**
     * @cfg {Boolean} showScaleLines Whether to show scale lines or not.
     */
    showScaleLines          : false,

    /**
     * @cfg {Boolean} showLimitLines Whether to show maximum resource allocation lines or not.
     */
    showLimitLines          : true,

    calendarListeners       : null,

    calendarListenersHash   : null,

    /**
     * @cfg {Gnt.data.Calendar} calendar A {@link Gnt.data.Calendar calendar} instance for this histogram panel. Can be also provided
     * as a {@link Gnt.data.TaskStore#calendar configuration option} of the `taskStore`.
     *
     * **Please note,** that this option is required if the {@link #taskStore} option is not specified.
     */
    calendar                : null,

    /**
     * @cfg {Gnt.data.TaskStore} taskStore The {@link Gnt.data.TaskStore store} holding the tasks.
     * When using this option, the histogram will instantly reflect any changes made to a task.
     *
     * **Please note,** that this option is required if the {@link #calendar} option is not specified.
     */
    taskStore               : null,

    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore The {@link Gnt.data.ResourceStore store} holding the resources to be rendered into the histogram (required).
     *
     * See also {@link Gnt.model.Resource}
     */
    resourceStore           : null,

    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore The {@link Gnt.data.AssignmentStore store} holding the assignments information (optional).
     *
     * If not specified, it will be taken from the {@link #resourceStore} or {@link #taskStore}.
     *
     * See also {@link Gnt.model.Assignment}
     */
    assignmentStore         : null,

    /**
     * @cfg {Date} startDate Defines the start date of this panel.
     *
     * **Note:** This option is **required** if a {@link #partnerTimelinePanel} is not specified.
     */
    startDate               : null,

    /**
     * @cfg {Date} endDate Defines the end date of this panel.
     *
     * **Note:** This option is **required** if a {@link #partnerTimelinePanel} is not specified.
     */
    endDate                 : null,

    /**
     * @cfg {Sch.mixin.TimelinePanel} timelinePanelThe timeline panel to synchronize histogram panel with.
     * @deprecated In favor of the {@link Sch.mixin.TimelinePanel#partnerTimelinePanel partnerTimelinePanel} config.
     * If a timelinePanel is specified then the histogram will:
     *
     * - take {@link #startDate}, {@link #endDate} configs from specified panel.
     * - reuse {@link Sch.data.TimeAxis} timeAxis with provided panel.
     * - set and synchronize the width of the locked grid panels.
     * - synchronize horizontal scrolling between two panels.
     */
    timelinePanel           : null,

    /**
     * @cfg {Boolean} highlightWeekends `True` to highlight weekends and holidays, using the {@link Gnt.feature.WorkingTime} plugin.
     */
    highlightWeekends       : true,

    allocationData          : null,

    /**
     * @cfg {String} scaleUnit Name of the resource utilization scale unit. `Sch.util.Date` constants can be used, like `Sch.util.Date.HOUR`.
     */
    scaleUnit               : 'HOUR',

    /**
     * @cfg {Number} scaleMin Minimum for the resource utilization scale (required).
     */
    scaleMin                : 0,

    /**
     * @cfg {Number} scaleMax Maximum for the resource utilization scale.
     *
     * **Note:** this option is **required** except in cases when you use {@link #scalePoints} to define utilization scale.
     */
    scaleMax                : 24,

    /**
     * @cfg {Number} scaleLabelStep Defines the interval between two adjacent scale lines which have labels.
     * The histogram itself does not render any labels but corresponding lines will get a specific CSS class for styling purposes.
     */
    scaleLabelStep          : 4,

    /**
     * @cfg {Number} scaleStep Defines the interval between two adjacent scale lines.
     *
     * **Also,** this value is used as a margin between the top scale line (defined by {@lin #scaleMax} option) and the top border of the cell
     * containing the histogram for a resource.
     */
    scaleStep               : 2,

    rowHeight               : 50,

    /**
     * @cfg {String} resourceText The text to show in the resource name column header (which is used for the default columns).
     */
    resourceText            : 'Resource',

    // private
    initComponent : function () {
        this.partnerTimelinePanel = this.partnerTimelinePanel || this.timelinePanel;

        this.lockedViewConfig = this.lockedViewConfig || {};
        this.normalViewConfig = this.normalViewConfig || {};

        this.normalViewConfig.histogram = this;
        this.normalViewConfig.trackOver = false;

        this.lockedGridConfig = this.lockedGridConfig || {};

        Ext.applyIf(this.lockedGridConfig, { width : 300, forceFit : true });

        // Copy some properties to the view instance
        this.lockedViewConfig.rowHeight                = this.normalViewConfig.rowHeight = this.rowHeight;
        this.lockedViewConfig.preserveScrollOnRefresh  = this.normalViewConfig.preserveScrollOnRefresh = this.preserveScrollOnRefresh;

        // if scale was specified by scalePoints
        if (this.scalePoints) {
            this.scalePoints.sort(function (a, b) { return a.value > b.value ? 1 : -1; });

            this.scaleMin   = this.scalePoints[0].value;
            this.scaleMax   = this.scalePoints[this.scalePoints.length - 1].value;
            this.scaleStep  = (this.scaleMax - this.scaleMin) / 10;
        }

        // if no columns provided we'll generate default column set: resource name & scale
        if (!this.columns) {
            var resourceNameCol, scaleCol;

            this.columns = [];

            resourceNameCol = this.resourceNameCol = new Ext.grid.column.Column({
                header      : this.resourceText,
                dataIndex   : this.resourceStore.model.prototype.nameField
            });

            this.columns.push(resourceNameCol);

            scaleCol = { width : 40, fixed: true };

            // map some scale column configs from this panel
            Ext.Array.forEach(
                [ 'scalePoints', 'scaleStep', 'scaleLabelStep', 'scaleMin', 'scaleMax', 'scaleLabelStep', 'scaleStep' ],
                function (prop) {
                    scaleCol[prop] = this[prop];
                },
                this
            );

            scaleCol = this.scaleCol = new Gnt.column.Scale(scaleCol);

            // before column render we'll give it information about row height
            this.mon(scaleCol, {
                beforerender    : function () {
                    scaleCol.setAvailableHeight(this.getSchedulingView().getAvailableHeight());
                    if (this.scalePoints) {
                        // we update scalePoints since it was
                        // filled in with calculated top-coordinates
                        this.scalePoints    = scaleCol.scalePoints;
                    }
                },
                scope           : this,
                single          : true
            });

            // if scale was specified by scalePoints let's set params equal to scale column ones
            // since they were calculated there
            if (this.scalePoints) {
                this.scaleMin       = scaleCol.scaleMin;
                this.scaleMax       = scaleCol.scaleMax;
                this.scaleStep      = scaleCol.scaleStep;
            }

            this.columns.push(scaleCol);

        // if columns specified we try to find Gnt.column.Scale instances and set its configs
        } else {
            var columns = !Ext.isArray(this.columns) ? [this.columns] : this.columns, col;
            for (var i = 0; i < columns.length; i++) {
                col = columns[i];

                if (col instanceof Gnt.column.Scale || col.xtype == 'scalecolumn') {

                    // map some scale column configs from this panel
                    Ext.Array.forEach(
                        [ 'scalePoints', 'scaleStep', 'scaleLabelStep', 'scaleMin', 'scaleMax', 'scaleLabelStep', 'scaleStep' ],
                        function (prop) {
                            if (!(prop in col)) col[prop] = this[prop];
                        },
                        this
                    );

                    if (!(col instanceof Gnt.column.Scale)) {
                        col = columns[i] = Ext.ComponentManager.create(col, 'scalecolumn');
                    }

                    // before column render let's give it information about row height
                    this.mon(col, {
                        beforerender    : function () {
                            col.setAvailableHeight(this.getSchedulingView().getAvailableHeight());
                        },
                        scope           : this,
                        single          : true
                    });
                }
            }
        }

        // Copy some properties to the view instance
        Ext.Array.forEach(
            [ 'barCls', 'barTpl', 'lineTpl', 'lineCls', 'limitLineTpl', 'limitLineCls', 'limitLineWidth', 'labelMode', 'labelPercentFormat', 'labelUnitsFormat', 'scaleMin', 'scaleMax', 'scaleStep', 'loadMask' ],
            function(prop) {
                if (prop in this) this.normalViewConfig[prop] = this[prop];
            },
            this
        );

        // resourceStore act as store for our grid
        this.store  = this.resourceStore;

        this.taskStore = this.taskStore || this.store.getTaskStore();

        if (this.taskStore) {
            this.mon(this.taskStore, {
                update  : this.onTaskUpdate,
                scope   : this
            });
        }

        // get project calendar
        this.calendar   = this.calendar || this.taskStore && this.taskStore.getCalendar();

        if (!this.calendar) throw 'Cannot get project calendar instance: please specify either "calendar" or "taskStore" option';

        // on calendar change we gonna rebuild bars & re-render grid
        this.mon(this.calendar, {
            calendarchange  : this.onProjectCalendarChange,
            scope           : this
        });

        // bind listeners to resources calendars
        this.bindCalendarListeners();

        this.assignmentStore = this.assignmentStore || this.store.getAssignmentStore() || this.taskStore && this.taskStore.getAssignmentStore();

        if (this.assignmentStore) {
            // on assignments change we gonna update corresponding resource row
            this.mon(this.assignmentStore, {
                refresh : this.onAssignmentsRefresh,
                remove  : this.onAssignmentsChange,
                update  : this.onAssignmentsChange,
                add     : this.onAssignmentsChange,

                scope   : this
            });
        }

        this.plugins    = [].concat(this.plugins || []);

        // if we need to highlight weekends
        if (this.highlightWeekends) {

            // add Gnt.feature.WorkingTime instance
            this.workingTimePlugin = new Gnt.feature.WorkingTime({
                calendar    : this.calendar
            });

            this.plugins.push(this.workingTimePlugin);
        }

        this.callParent(arguments);

        var cls     = 'gnt-resourcehistogram sch-horizontal ';

        // if we need to highlight weekends
        if (this.highlightWeekends) {
            cls     += ' gnt-resourcehistogram-highlightweekends ';
        }

        this.addCls(cls);

        var view = this.getSchedulingView();

        // register our renderer
        this.registerRenderer(view.columnRenderer, this);

        this.relayEvents(view, [
            /**
            * @event barclick
            * Fires when a histogram bar is clicked
            *
            * @param {Gnt.view.ResourceHistogram} view The histogram panel view.
            * @param {Object} context Object containing a description of the clicked bar.
            * @param {Gnt.model.Resource} context.resource The resource record.
            * @param {Date} context.startDate Start date of corresponding period.
            * @param {Date} context.endDate End date of corresponding period.
            * @param {Number} context.allocationMS Resource allocation time in milliseconds.
            * @param {Number} context.totalAllocation Resource allocation (in percents).
            * @param {Gnt.model.Assignment[]} context.assignments List of resource assignments for the corresponding period.
            * @param {Ext.EventObject} e The event object
            */
            'barclick',
            /**
            * @event bardblclick
            * Fires when a histogram bar is double clicked
            *
            * @param {Gnt.view.ResourceHistogram} view The histogram panel view.
            * @param {Object} context Object containing description of clicked bar.
            * @param {Gnt.model.Resource} context.resource The resource record.
            * @param {Date} context.startDate Start date of corresponding period.
            * @param {Date} context.endDate End date of corresponding period.
            * @param {Number} context.allocationMS Resource allocation time in milliseconds.
            * @param {Number} context.totalAllocation Resource allocation (in percents).
            * @param {Gnt.model.Assignment[]} context.assignments List of resource assignments for the corresponding period.
            * @param {Ext.EventObject} e The event object
            */
            'bardblclick',
            /**
            * @event barcontextmenu
            * Fires when contextmenu is activated on a histogram bar
            *
            * @param {Gnt.view.ResourceHistogram} view The histogram panel view.
            * @param {Object} context Object containing description of clicked bar.
            * @param {Gnt.model.Resource} context.resource The resource record.
            * @param {Date} context.startDate Start date of corresponding period.
            * @param {Date} context.endDate End date of corresponding period.
            * @param {Number} context.allocationMS Resource allocation time in milliseconds.
            * @param {Number} context.totalAllocation Resource allocation (in percents).
            * @param {Gnt.model.Assignment[]} context.assignments List of resource assignments for the corresponding period.
            * @param {Ext.EventObject} e The event object
            */
            'barcontextmenu'
        ]);

        if (!this.syncRowHeight) this.enableRowHeightInjection(this.lockedGrid.getView(), this.normalGrid.getView());

        // load resources allocation from stores
        this.loadAllocationData(null, true);


        // MONSTERHACK we don't want the grid to save space for the vertical scrollbar
        // http://www.sencha.com/forum/showthread.php?264476-Configurable-if-scrollbar-width-should-be-take-into-account
        var colLayout = this.lockedGrid.headerCt.layout;
        var oldGetContainerSize = colLayout.getContainerSize;
        var oldGetSize = Ext.getScrollbarSize;
        var size = Ext.getScrollbarSize();
        // since 4.2.2 scrollbarWidth property is used to get scrollbar width
        colLayout.scrollbarWidth = 0;

        colLayout.getContainerSize = function(ownerContext) {
            Ext.getScrollbarSize = function() {
                return {
                    width   : 0,
                    height  : size.height
                };
            };
            var retVal = oldGetContainerSize.apply(this, arguments);

            Ext.getScrollbarSize = oldGetSize;
            return retVal;
        };
    },


    destroy : function () {
        this.unbindCalendarListeners();

        if (this.assignmentStore) {
            this.mun(this.assignmentStore, {
                refresh : this.onAssignmentsRefresh,
                remove  : this.onAssignmentsChange,
                update  : this.onAssignmentsChange,
                add     : this.onAssignmentsChange,

                scope   : this
            });
        }

        if (this.taskStore) {
            this.mun(this.taskStore, {
                update  : this.onTaskUpdate,
                scope   : this
            });
        }

        this.mun(this.calendar, {
            calendarchange  : this.onProjectCalendarChange,
            scope           : this
        });
    },

    onProjectCalendarChange : function () {
        // reload all allocations data
        this.loadAllocationData();
    },

    unbindResourceCalendarListeners : function (resource) {
        var listeners   = this.calendarListenersHash && this.calendarListenersHash[resource.getInternalId()];
        if (listeners) {
            Ext.Array.remove(this.calendarListeners, listeners);
            Ext.destroy(listeners);
        }
    },

    bindResourceCalendarListeners : function (resource, calendar) {
        var me      = this;

        calendar    = calendar || resource.getOwnCalendar();

        // on calendar load/change we'll recalculate allocation data and redraw row
        var fn  = function () { me.loadAllocationData(resource); };

        var listeners   = me.mon(calendar, {
            load            : fn,
            calendarchange  : fn,
            scope           : me,
            destroyable     : true
        });

        me.calendarListenersHash[resource.getInternalId()] = listeners;
        me.calendarListeners.push(listeners);
    },

    bindCalendarListeners : function () {
        // unbind exisiting listeners (if any)
        this.unbindCalendarListeners();

        var me = this;

        this.store.each(function (resource) {
            // if resource has own calendar and it differs from project one
            var calendar    = resource.getOwnCalendar();
            if (calendar && calendar !== me.calendar) {
                me.bindResourceCalendarListeners(resource, calendar);
            }
        });
    },

    unbindCalendarListeners : function () {
        if (this.calendarListeners && this.calendarListeners.length) {
            Ext.destroy.apply(Ext, this.calendarListeners);
        }
        // reset array of listeners
        this.calendarListeners      = [];
        this.calendarListenersHash  = {};
    },

    onResourcesLoad : function () {
        // reload all allocations data
        this.loadAllocationData();

        // bind listeners to resources calendars
        this.bindCalendarListeners();
    },

    onTaskUpdate : function (taskStore, task) {
        var assignments;

        if (this.assignmentStore) {
            assignments     = this.assignmentStore.queryBy(function (assignment) {
                return assignment.getTaskId() == task.getInternalId();
            });
            assignments     = assignments.getRange();
        } else {
            assignments     = task.getAssignments();
        }

        this.onAssignmentsChange(this.assignmentStore, assignments);
    },

    onAssignmentsRefresh : function (assignmentStore) {
        this.onAssignmentsChange(assignmentStore, assignmentStore.getRange());
    },

    onAssignmentsChange : function (assignmentStore, assignments) {
        var resource;

        if (!Ext.isArray(assignments)) assignments = [assignments];

        // for each provided assignment
        for (var i = 0, l = assignments.length; i < l; i++) {
            // get assigned resource
            resource = this.resourceStore.getByInternalId(assignments[i].getResourceId());

            if (resource) {
                // reload resource allocation
                this.loadAllocationData(resource);
            }
        }
    },

    enableRowHeightInjection : function (lockedView, schedulingView) {
        var originalRenderRow       = lockedView.renderRow;
        var originalRenderCell      = lockedView.renderCell;

        var cellTpl                 = new Ext.XTemplate(
            '{%',
                'this.processCellValues(values);',
                'this.nextTpl.applyOut(values, out, parent);',
            '%}',
            {
                priority            : 1,
                processCellValues   : function (cellValues) {
                    if (schedulingView.orientation == 'horizontal') {
                        var height          = schedulingView.getRowHeight() - schedulingView.cellTopBorderWidth - schedulingView.cellBottomBorderWidth;

                        cellValues.style    = (cellValues.style || '') + ';height:' + height + 'px;';
                    }
                }
            }
        );

        lockedView.addCellTpl(cellTpl);
        schedulingView.addCellTpl(cellTpl);
    },

    loadAllocationData : function (resource, preventRefresh) {
        if (this.resourceStore) {
            // load allocation for all the resources
            if (!resource) {
                this.allocationData = {};
                var me = this;
                var start = this.getStartDate();
                var end = this.getEndDate();

                this.store.each(function(resource) {
                    me.allocationData[resource.getInternalId()] = me.processAllocationData(resource.getAllocationInfo({
                        startDate               : start,
                        endDate                 : end,
                        includeResCalIntervals  : true
                    }));
                });

                if (!preventRefresh && this.rendered) this.getView().refresh();

            // load allocation of specified resource
            } else {
                this.allocationData = this.allocationData || {};

                this.allocationData[resource.getInternalId()] = this.processAllocationData(resource.getAllocationInfo({
                    startDate               : this.getStartDate(),
                    endDate                 : this.getEndDate(),
                    includeResCalIntervals  : true
                }));

                if (!preventRefresh && this.rendered) this.getView().refreshNode(this.store.indexOf(resource));
            }
        }
    },

    // This function processes report made by resource.getAllocationInfo() method and build arrays of
    // histogram bars and levels of max resource allocation.
    // Returns:
    //      {
    //        bars: [], // array of histogram bars
    //        maxBars: [] // levels of max resource allocation
    //      }
    processAllocationData : function (data) {
        var period, bar, maxBar, prevDay, closeDate, openDate,
            allocationMS, prevAllocationMS, maxAllocationMS, prevMaxAllocationMS,
            bars        = [],
            maxBars     = [],
            barOpened   = false;

        // another set of task started
        var taskFinished = function () {
            if (!bar.assignments || !period.inResourceCalendar || !period.totalAllocation || !period.inTasksCalendar) return false;

            for (var i = 0, l = bar.assignments.length; i < l; i++) {
                if (period.assignmentsHash[ bar.assignments[i].getTaskId() ]) return false;
            }

            // no intersection with previous set of tasks
            return true;
        };

        // open histogram bar
        var openBar     = function (openDate) {
            bar = {
                startDate       : openDate,
                totalAllocation : period.totalAllocation,
                allocationMS    : allocationMS * period.totalAllocation / 100,
                assignments     : period.assignments
            };

            barOpened = true;
        };

        // close histogram bar
        var closeBar    = function (closeDate) {
            if (!barOpened) return false;

            if (closeDate) bar.endDate = closeDate;
            bars.push(bar);

            barOpened   = false;
        };

        var newDay;
        for (var i = 0, l = data.length; i < l; i++) {
            period = data[i];

            newDay = Ext.Date.clearTime(period.startDate, true);
            // if it's 1st period of a new day
            if (newDay - prevDay !== 0) {
                prevDay             = newDay;

                prevAllocationMS    = allocationMS;
                prevMaxAllocationMS = maxAllocationMS;
                // reset allocation time counters
                allocationMS        = 0;
                maxAllocationMS     = 0;
                var j = i;
                // let's calculate allocation time for the day
                while (data[j] && Ext.Date.clearTime(data[j].startDate, true) - newDay === 0) {
                    // if it's working time according to resource calendar
                    if (data[j].inResourceCalendar) {
                        // increment maximum possible resource allocation time
                        maxAllocationMS     += data[j].endDate - data[j].startDate;
                        // if it's working time and task is in progress
                        if (data[j].totalAllocation && data[j].inTasksCalendar) {
                            // increment allocation time
                            allocationMS    += data[j].endDate - data[j].startDate;
                        }
                    }
                    j++;
                }
            } else {
                newDay = false;
            }

            // if we need to render limits lines
            if (this.showLimitLines) {
                // here we trace resource max available allocation changes
                if (newDay && maxAllocationMS != prevMaxAllocationMS) {
                    // on change we close existing line
                    if (maxBar) {
                        maxBar.endDate      = period.startDate;
                        maxBars.push(maxBar);
                    }
                    // ..and start new one with new allocationMS value
                    maxBar = {
                        startDate       : period.startDate,
                        allocationMS    : maxAllocationMS
                    };
                }

                // update end of max available allocation line
                maxBar.endDate  = period.endDate;
            }

            // if no bar opened
            if (!barOpened) {
                // if period belongs to some task(s)
                // need to open new bar
                if (period.inTask) {
                    openBar(new Date(period.startDate));
                }

            // bar opened & task is finished
            // need to close opened bar
            } else if (!period.inTask) {
                closeBar();

            // bar opened & task in progress
            } else {

                var splitBar = false;

                // if there is a gap we need to close old bar and start new one
                // ("gap" is when we have no periods during day before newDay)
                if (newDay && bar.endDate <= Sch.util.Date.add(newDay, Sch.util.Date.DAY, -1)) {

                    // close bar at midnight after bar.endDate
                    closeDate   = Ext.Date.clearTime(bar.endDate, true);
                    if (closeDate < bar.endDate) {
                        closeDate   = Sch.util.Date.add(closeDate, Sch.util.Date.DAY, 1);
                    }

                    // open new bar at midnight before period.startDate
                    openDate    = Ext.Date.clearTime(period.startDate, true);
                    splitBar    = true;

                // if day allocation has changed (due to calendars)
                } else if (newDay && allocationMS !== prevAllocationMS) {

                    closeDate   = openDate = period.startDate;
                    splitBar    = true;

                // another task(s) started
                } else if (period.totalAllocation && taskFinished()) {

                    closeDate   = bar.endDate;
                    openDate    = new Date(period.startDate);
                    splitBar    = true;

                // if % of allocation was changed (result of assignments change)
                } else if (period.totalAllocation && period.totalAllocation != bar.totalAllocation) {

                    closeDate   = openDate = period.totalAllocation > bar.totalAllocation ? new Date(period.startDate) : bar.endDate;
                    splitBar    = true;

                }


                if (splitBar) {
                    closeBar(closeDate);
                    openBar(openDate);
                }
            }

            // if we have opened bar
            if (barOpened) {
                // update its end date
                bar.endDate     = period.endDate;
            }

        }

        // close bar if task goes after timeline end
        closeBar();

        // if we need to render limits lines
        if (this.showLimitLines) {
            // push last line to lines array
            if (maxBar) {
                maxBars.push(maxBar);
            }

            // updating start of 1st and end of last max available allocation lines with nulls
            // will make view to call timeAxis.getStart() and timeAxis.getEnd() respectively to get these values
            if (maxBars.length) {
                maxBars[0].startDate                = null;
                maxBars[maxBars.length - 1].endDate = null;
            }
        }

        return {
            bars    : bars,
            maxBars : maxBars
        };
    }

});

/**
@class Gnt.field.mixin.TaskField

A mixin with common functionality for all fields used to edit {@link Gnt.model.Task} information.

*/
Ext.define('Gnt.field.mixin.TaskField', {

    taskField               : '',

    /**
     * @cfg {Gnt.model.Task} task Task being edited. Field will apply all it's value changes directly to this task (if {@link #instantUpdate} is `true`).
     */
    task                    : null,

    /**
     * @cfg {Gnt.data.TaskStore} taskStore Task store should provided if task being edited is not in any task store yet and thus does not have a calendar.
     * In such case we'll retrieve a calendar from the task store (project calendar).
     */
    taskStore               : null,

    /**
     * @cfg {Number} suppressTaskUpdate A number flag, when greater than 0 prevents task updates.
     */
    suppressTaskUpdate      : 0,

    /**
     * @cfg {Boolean} highlightTaskUpdates When set to `true`, field will highlight itself when its value is changed due to changes in some other field.
     * For example when changing the end date of the task, its duration will change as well and will highlight itself.
     */
    highlightTaskUpdates    : true,

    /**
     * @cfg {String} highlightColor A color to use when highlighting the field. See {@link #highlightTaskUpdates} option.
     */
    highlightColor          : '#009900',

    lastHighlight           : 0,

    /**
     * @cfg {Boolean} instantUpdate Set to `false` to prevent automatic applying changes to task on each {@link #setValue} call.
     * To apply changes manually one can use {@link #applyChanges} method.
     */
    instantUpdate           : true,
    
    /**
     * Binds task to the field.
     * @param {Gnt.model.Task} task Task to bind.
     */
    setTask : function (task) {
        if (!task) return;

        this.setReadOnly(!task.isEditable(task[this.taskField]));

        this.destroyTaskListener();

        this.task = task;

        task.on('taskupdated', this.onTaskUpdateProcess, this);

        // we need calendar to be assigned to task or task should be part of taskStore with
        // assigned calendar, if we dont`t have it lets imitate it by binding task to provided taskStore
        if (!task.getCalendar(true) && !task.getTaskStore(true)) {

            task.taskStore = task.getTaskStore(true) || this.taskStore;

            if (!task.taskStore) throw 'Configuration issue: Gnt.data.taskStore instance should be provided.';
            if (!task.getCalendar(true) && !task.taskStore.getCalendar()) throw 'Configuration issue: Gnt.data.Calendar instance should be provided.';
        }

        this.setSuppressTaskUpdate(true);
        if (this.onSetTask) this.onSetTask(task);
        this.setSuppressTaskUpdate(false);
    },
    
    
    setSuppressTaskUpdate : function (inc) {
        inc ? this.suppressTaskUpdate++ : this.suppressTaskUpdate--;
    },
    
    
    getSuppressTaskUpdate : function () {
        return this.suppressTaskUpdate;
    },
    

    onTaskUpdateProcess : function (task, initiator) {
        if (initiator !== this) {
            var prev    = this.getValue();

            // update field editability
            this.setReadOnly(!task.isEditable(task[this.taskField]));

            this.setSuppressTaskUpdate(true);
            if (this.onTaskUpdate) {
                this.onTaskUpdate(task, initiator);
            } else {
                if (this.onSetTask) this.onSetTask();
            }
            this.setSuppressTaskUpdate(false);

            if (this.highlightTaskUpdates) {
                var curr    = this.getValue(),
                    isDate  = Ext.isDate(prev);

                if (isDate && (prev - curr !== 0) || (!isDate && String(prev) !== String(curr))) {
                    this.highlightField();
                }
            }
        }
    },

    highlightField : function (color, options) {
        if (this.rendered && (new Date() - this.lastHighlight > 1000)) {
            this.lastHighlight = new Date();
            this.inputEl.highlight(color || this.highlightColor, options || { attr : 'color' });
        }
    },

    destroyTaskListener : function () {
        if (this.task) {
            this.task.un('taskupdated', this.onTaskUpdateProcess, this);
        }
    }

});

/**
@class Gnt.field.EndDate
@extends Ext.form.field.Date

A specialized field for editing the task end date value. This class inherits from the `Ext.form.field.Date` field
and any of its configuration options can be used. You can find this field used in the {@link Gnt.widget.TaskForm}
and in the {@link Gnt.column.StartDate} classes but you can also use it in your own components.
See "Using field standalone" in the documentation of {@link Gnt.field.StartDate}.

This field must be bound to a {@link Gnt.model.Task task} instance, which is used for date value processing
(calendars, holidays etc).

#Task interaction

By default the field instantly applies all changes to the bound task. This can be turned off with the {@link #instantUpdate} option.

#Using field standalone

Please refer to {@link Gnt.field.StartDate} for details.

* **Note**, that the value displayed in the field can be different from the value in the data model when editing milestones
or when the date does not contain any time information (hours/minutes etc). This is because in our component, an end date represents a distinct point
on the timeaxis. For example: if from a user perspective, a task starts at 2013/01/01 and ends at 2013/01/02 -
this means that the task actually ends at 2013/01/02 23:59:59.9999. In the task model we store
2013/01/03 00:00:00, but in the field we show 2013/01/02. See also {@link #adjustMilestones}.

*/
Ext.define('Gnt.field.EndDate', {

    extend              : 'Ext.form.field.Date',

    requires            : ['Sch.util.Date'],

    mixins              : ['Gnt.field.mixin.TaskField', 'Gnt.mixin.Localizable'],

    alias               : 'widget.enddatefield',

    /**
     * @cfg {Boolean} adjustMilestones When set to `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*. The task model will still hold the raw unmodified date.
     */
    adjustMilestones    : true,

    /**
     * @cfg {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the task), `false` to change the duration ("resize" the task).
     */
    keepDuration        : false,

    taskField           : 'endDateField',

    /**
     * @cfg {Boolean} validateStartDate When set to `true`, the field will validate a "startDate <= endDate" condition and will not allow user to save invalid value.
     * Set it to `false` if you use different validation mechanism.
     */
    validateStartDate   : true,

    /**
     * @cfg {String} endBeforeStartText Text shown when field value is less than start date of corresponding task.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - endBeforeStartText : 'End date is before start date'
     */

    constructor : function (config) {
        config      = config || {};

        Ext.apply(this, config);

        if (config.task && !config.value) config.value = config.task.getEndDate();

        this.setSuppressTaskUpdate(true);
        this.callParent([ config ]);
        this.setSuppressTaskUpdate(false);

        if (this.task) this.setTask(this.task);
    },

    destroy : function () {
        this.destroyTaskListener();

        this.callParent();
    },

    onSetTask : function () {
        this.setValue(this.task.getEndDate());
    },

    rawToValue : function (rawValue) {
        if (!rawValue) return null;

        return this.visibleToValue(this.parseDate(rawValue));
    },

    valueToRaw : function (value) {
        if (!value) return value;

        return Ext.Date.format(this.valueToVisible(value), this.format);
    },

    valueToVisible : function (value, task) {
        task = task || this.task;

        return task.getDisplayEndDate(this.format, this.adjustMilestones, value, true);
    },

    visibleToValue : function (value) {
        if (value && this.task) {

            if (!Ext.Date.formatContainsHourInfo(this.format) && value - Ext.Date.clearTime(value, true) === 0) {
                // the standard ExtJS date picker will only allow to choose the date, not time
                // we set the time of the selected date to the latest availability hour for that date
                // in case the date has no availbility intervals we use the date itself
                value = this.task.getCalendar().getCalendarDay(value).getAvailabilityEndFor(value) ||
                    Sch.util.Date.add(value, Sch.util.Date.DAY, 1);
            }

        } else {
            value = null;
        }

        return value;
    },

    // @OVERRIDE
    getErrors : function (value) {
        var errors = this.callParent([value]);
        if (errors && errors.length) {
            return errors;
        }

        if (this.validateStartDate) {
            value = this.rawToValue(value);
            if (this.task && value) {
                if (value < this.task.getStartDate()) {
                    return [this.L('endBeforeStartText')];
                }
            }
        }
    },

    // @OVERRIDE
    onExpand : function () {
        var value = this.valueToVisible(this.getValue());

        if (!this.isValid()) {
            value = this.getRawValue();
            if (value) {
                value = Ext.Date.parse(value, this.format);
            }
        }

        this.picker.setValue(Ext.isDate(value) ? value : new Date());
    },

    // @OVERRIDE
    onSelect : function (picker, pickerDate) {
        // if we display the date with hours, then we (probably) want to keep the task end date's hour/minutes
        // after selecting the date from the picker. In the same time picker will clear the time portion
        // so we need to restore it from original date
        // see also: http://www.bryntum.com/forum/viewtopic.php?f=9&t=4294
        if (Ext.Date.formatContainsHourInfo(this.format)) {
            var originalDate    = this.task.getEndDate();
            pickerDate.setHours(originalDate.getHours());
            pickerDate.setMinutes(originalDate.getMinutes());
        }
        
        var me          = this;
        var oldValue    = me.getValue();
        var newValue    = this.visibleToValue(pickerDate);
        var rawValue    = Ext.Date.format(pickerDate, this.format);

        if (oldValue != newValue) {
            if (this.getErrors(rawValue)) {
                me.setRawValue(rawValue);
                // don`t know if we need to fire in this case
                //me.fireEvent('select', me, newValue);
                me.collapse();
                me.validate();
            } else {
                me.setValue(newValue, true);
                me.fireEvent('select', me, newValue);
                me.collapse();
            }
        }
    },

    /**
     * This method applies the changes from the field to the bound task or to the task provided as 1st argument.
     * If {@link #instantUpdate} option is enabled this method is called automatically after any change in the field.
     *
     * @param {Gnt.model.Task} [toTask] The task to apply the changes to. If not provided, changes will be applied to the last bound task
     * (with {@link #task} config option or {@link #setTask) method)
     */
    applyChanges : function (toTask) {
        toTask          = toTask || this.task;

        var taskStore   = toTask.getTaskStore(true) || this.taskStore;

        if (this.value) {
            toTask.setEndDate(this.value, this.keepDuration, taskStore.skipWeekendsDuringDragDrop);
        } else {
            toTask.setEndDate(null);
        }
    },

    setVisibleValue : function (value) {
        this.setValue(this.rawToValue(Ext.Date.format(value, this.format)));
    },

    getVisibleValue : function () {
        if (!this.getValue()) return null;
        return Ext.Date.parse(this.valueToRaw(this.getValue()), this.format);
    },

    /**
     * Sets the value of the field.
     *
     * **Note**, that this method accept the actual end date value, as it is stored in the data model.
     * The displayed value can be different, when date does not contain time information or when editing milestones.
     *
     * @param {Date} value New value of the field.
     */
    setValue : function (value, forceUpdate) {
        this.callParent([ value ]);

        if ((forceUpdate || this.instantUpdate) && !this.getSuppressTaskUpdate() && this.task) {

            // invoke all the Task magic
            this.applyChanges();

            // potentially value can be changed during applyChanges() call
            // because of skipping holidays
            // so let`s check it after call and set final value again
            var endDate = this.task.getEndDate();
            if (endDate - this.getValue() !== 0) {
                this.callParent([ endDate ]);
            }

            this.task.fireEvent('taskupdated', this.task, this);
        }
    },

    /**
     * Returns the value of the field.
     *
     * **Note**, that this method returns the actual end date value, as it is stored in the data model.
     * The displayed value can be different, when date does not contain time information or when editing milestones.
     *
     * @return {Date}
     */
    getValue : function () {
        return this.value;
    },

    // @private
    // it's called in editor.completeEdit()
    assertValue : function () {
        var me          = this,
            oldRaw      = me.rawValue,
            newRaw      = me.getRawValue(),
            oldValue    = me.getValue(),
            newValue    = me.rawToValue(newRaw),
            focusTask   = me.focusTask;

        if (focusTask) {
            focusTask.cancel();
        }

        if ((oldRaw != newRaw) && (newValue - oldValue !== 0)) {
            // set value only if field is valid
            if (!me.validateOnBlur || me.isValid()) {
                // at this point `setValue` should apply any changes from the field to the task
                // even if `instantUpdate` is disabled
                me.setValue(newValue, true);
            }
        }
    },

    // @OVERRIDE
    beforeBlur : function () {
        this.assertValue();
    }
});

/**

@class Gnt.field.StartDate
@extends Ext.form.field.Date

A specialized field for editing the task start date value. This class inherits from the `Ext.form.field.Date` field
so any of its configuration options can be used. You can find this field in {@link Gnt.widget.TaskForm}
and in {@link Gnt.column.StartDate} but you can use it in your own components as well (see "Using field standalone" below).

This field requires to be bound to {@link Gnt.model.Task task} instance, which is used for date value processing
(calendars, holidays etc).

#Task interacting

By default field instantly applies all changes to the bound task. This can be turned off with the {@link #instantUpdate} option.

#Using field standalone

To use this field standalone you have to provide {@link Gnt.model.Task task} instance to it. You can make it by two ways:

 - Set the {@link #task} configuration option at field constructing step. Like this:

        var startDateField = Ext.create('Gnt.field.StartDate', {
            task : someTask
        });

 - Or by calling {@link #setTask} method after field was created. Like this:

        startDateField.setTask(someTask);

* **Note:** If task does not belong to any {@link Gnt.data.TaskStore} you also **have to** specify {@link #taskStore} config option for this field otherwise it won't work:

        // some task not inserted in the task store yet
        var someTask    = new Gnt.model.Task({ ... })

        var startDateField = Ext.create('Gnt.field.StartDate', {
            task        : someTask,
            // need to provide a task store instance in this case
            taskStore   : taskStore
        });

* **Note**, that value displayed in the field can be different from the value in the task model when editing milestones.
Please refer to {@link #adjustMilestones} for details.

*/
Ext.define('Gnt.field.StartDate', {
    extend              : 'Ext.form.field.Date',

    requires            : ['Sch.util.Date'],

    mixins              : ['Gnt.field.mixin.TaskField'],

    alias               : 'widget.startdatefield',

    /**
     * @cfg {Boolean} adjustMilestones When set to `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*. The task model will still hold unmodified date.
     */
    adjustMilestones    : true,

    /**
     * @cfg {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the task), `false` to change the duration ("resize" the task).
     */
    keepDuration        : true,

    taskField           : 'startDateField',

    constructor : function (config) {
        config      = config || {};

        if (config.task && !config.value) config.value = config.task.getStartDate();

        this.setSuppressTaskUpdate(true);
        this.callParent([ config ]);
        this.setSuppressTaskUpdate(false);

        if (this.task) this.setTask(this.task);
    },

    destroy : function () {
        this.destroyTaskListener();

        this.callParent();
    },

    onSetTask : function () {
        this.setValue(this.task.getStartDate());
    },

    // @OVERRIDE
    rawToValue : function (rawValue) {
        if (!rawValue) return null;

        return this.visibleToValue(this.parseDate(rawValue));
    },

    // @OVERRIDE
    valueToRaw : function (value) {
        if (!value) return value;

        return Ext.Date.format(this.valueToVisible(value), this.format);
    },

    valueToVisible : function (value, task) {
        task = task || this.task;

        return task.getDisplayStartDate(this.format, this.adjustMilestones, value, true);
    },

    visibleToValue : function (value) {
        var task = this.task;

        // Special treatment of milestone task dates
        if (task && value) {
            var endDate = task.getEndDate();

            var isMidnight = !this.lastValue || this.lastValue - Ext.Date.clearTime(this.lastValue, true) === 0;

            if (this.adjustMilestones && task.isMilestone() && value - Ext.Date.clearTime(value, true) === 0 && isMidnight) {

                // the standard ExtJS date picker will only allow to choose the date, not time
                // we set the time of the selected date to the earliest availability hour for that date
                // in case the date has no availbility intervals we use the date itself

                value   = task.getCalendar().getCalendarDay(value).getAvailabilityEndFor(value) || value;

            }
        }

        return value;
    },

    // @OVERRIDE
    onExpand: function () {
        var value = this.valueToVisible(this.getValue());

        this.picker.setValue(Ext.isDate(value) ? value : new Date());
    },

    // @OVERRIDE
    onSelect: function (picker, pickerDate) {
        // if we display the date with hours, then we (probably) want to keep the task end date's hour/minutes
        // after selecting the date from the picker. In the same time picker will clear the time portion
        // so we need to restore it from original date
        // see also: http://www.bryntum.com/forum/viewtopic.php?f=9&t=4294
        if (Ext.Date.formatContainsHourInfo(this.format)) {
            var originalDate    = this.task.getStartDate();
            pickerDate.setHours(originalDate.getHours());
            pickerDate.setMinutes(originalDate.getMinutes());
        }
        
        
        var me          = this,
            rawValue    = Ext.Date.format(pickerDate, this.format),
            oldValue    = me.getValue(),
            newValue    = this.visibleToValue(pickerDate),
            errors      = this.getErrors(rawValue);

        if (oldValue != newValue) {
            if (errors && errors.length) {
                me.setRawValue(rawValue);
                // unsure if we need to fire 'select' in this case
                //me.fireEvent('select', me, newValue);
                me.collapse();
                me.validate();
            } else {
                me.setValue(newValue);
                me.fireEvent('select', me, newValue);
                me.collapse();
            }
        }
    },

    /**
     * This method applies the changes from the field to the bound task or to the task provided as 1st argument.
     * If {@link #instantUpdate} option is enabled this method is called automatically after any change in the field.
     *
     * @param {Gnt.model.Task} [toTask] The task to apply the changes to. If not provided, changes will be applied to the last bound task
     * (with {@link #task} config option or {@link #setTask) method)
     */
    applyChanges : function (toTask) {
        toTask          = toTask || this.task;

        var taskStore   = toTask.getTaskStore(true) || this.taskStore;

        // invoke all the Task magic
        toTask.setStartDate(this.value, this.keepDuration, taskStore.skipWeekendsDuringDragDrop);
    },

    setVisibleValue : function (value) {
        this.setValue(this.rawToValue(Ext.Date.format(value, this.format)));
    },

    getVisibleValue : function () {
        if (!this.getValue()) return null;
        return Ext.Date.parse(this.valueToRaw(this.getValue()), this.format);
    },

    // @OVERRIDE
    /**
     * Sets the value of the field.
     *
     * **Note**, that this method accept the actual start date value, as it is stored in the data model.
     * The displayed value can be different, when editing milestones.
     *
     * @param {Date} value New value of the field.
     */
    setValue : function (value, forceUpdate) {
        this.callParent([ value ]);
        
        var task        = this.task;

        if ((forceUpdate || this.instantUpdate) && !this.getSuppressTaskUpdate() && task && task.taskStore && value) {
            // apply changes to task
            this.applyChanges();

            // potentially value can be changed during setStartDate() call
            // because of skipping holidays
            // so let`s check it after call and set final value again
            var startDate = task.getStartDate();
            
            if (startDate - this.getValue() !== 0) {
                this.callParent([ startDate ]);
            }

            task.fireEvent('taskupdated', task, this);
        }
    },

    // @OVERRIDE
    /**
     * Returns the value of the field.
     *
     * **Note**, that this method returns the actual start date value, as it is stored in the data model.
     * The displayed value can be different, when editing milestones.
     *
     * @return {Date}
     */
    getValue : function () {
        return this.value;
    },

    // @private
    // it's called in editor.completeEdit()
    assertValue : function () {
        var me          = this,
            oldRaw      = me.rawValue,
            newRaw      = me.getRawValue(),
            oldValue    = me.getValue(),
            newValue    = me.rawToValue(newRaw),
            focusTask   = me.focusTask;

        if (focusTask) {
            focusTask.cancel();
        }

        if ((oldRaw != newRaw) && (newValue - oldValue !== 0)) {
            // set value only if field is valid
            if (!me.validateOnBlur || me.isValid()) {
                // at this point `setValue` should apply any changes from the field to the task
                // even if `instantUpdate` is disabled
                me.setValue(newValue, true);
            }
        }
    },

    // @OVERRIDE
    beforeBlur : function () {
        this.assertValue();
    }
});

/**
@class Gnt.field.Duration
@extends Ext.form.field.Number

A specialized field allowing a user to also specify duration unit when editing the duration value.
This class inherits from the standard Ext JS "number" field, so any usual `Ext.form.field.Number`
configs can be used (like `minValue/maxValue` etc).



*/
Ext.define('Gnt.field.Duration', {
    extend                  : 'Ext.form.field.Number',

    requires                : ['Gnt.util.DurationParser'],

    mixins                  : ['Gnt.field.mixin.TaskField', 'Gnt.mixin.Localizable'],

    alias                   : 'widget.durationfield',
    alternateClassName      : ['Gnt.column.duration.Field', 'Gnt.widget.DurationField'],

    disableKeyFilter        : true,
    allowExponential        : false,
    minValue                : 0,


    /**
     * @cfg {String} durationUnit The default duration unit to use when editing the value.
     * This is usually being set automatically, using the `DurationUnit` field of the task.
     */
    durationUnit            : 'h',

    /**
     * @cfg {String} invalidText Text shown when field value cannot be parsed to valid duration.
     * If you want to change the text for all instances of this class please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - invalidText : 'Invalid duration value'
     */

    /**
     * @cfg {Boolean} useAbbreviation When set to `true` the field will use short names of unit durations
     * (as returned by {@link Sch.util.Date#getShortNameOfUnit})
     */
    useAbbreviation         : false,

    getDurationUnitMethod   : 'getDurationUnit',
    setDurationMethod       : 'setDuration',
    getDurationMethod       : 'getDuration',

    taskField               : 'durationField',

    durationParser          : null,
    durationParserConfig    : null,

    constructor : function (config) {
        var me = this;
        Ext.apply(this, config);

        this.durationParser = new Gnt.util.DurationParser(Ext.apply({
            // Since we're reusing the NumberField's parsing of numbers, we have to pass this on to the parser
            // to avoid having the same definitions in the parser too
            parseNumberFn   : function() { return me.parseValue.apply(me, arguments); },
            allowDecimals   : this.decimalPrecision > 0

        }, this.durationParserConfig));

        this.setSuppressTaskUpdate(true);
        this.callParent(arguments);
        this.setSuppressTaskUpdate(false);

        this.invalidText = this.L('invalidText');

        if (this.task) {
            this.setTask(this.task);
        }
    },

    destroy : function () {
        this.destroyTaskListener();

        this.callParent();
    },

    onSetTask : function () {
        this.durationUnit = this.task[this.getDurationUnitMethod]();

        var value = this.getDurationMethod ? this.task[this.getDurationMethod]() : this.task.get(this.task[this.taskField]);

        this.setValue(value);

        this.setSpinUpEnabled(value == null || value > this.minValue, true);
        this.setSpinDownEnabled(value < this.maxValue, true);
    },

    rawToValue : function (rawValue) {
        var parsed  = this.parseDuration(rawValue);

        if (!parsed) return null;

        this.durationUnit    = parsed.unit;

        return parsed.value != null ? parsed.value : null;
    },

    valueToVisible : function (value, durationUnit) {
        if (Ext.isNumber(value)) {
            return parseFloat(Ext.Number.toFixed(value, this.decimalPrecision)) + ' ' +
                Sch.util.Date[ this.useAbbreviation ? 'getShortNameOfUnit' : 'getReadableNameOfUnit' ](durationUnit || this.durationUnit, value !== 1);
        }

        return '';
    },

    valueToRaw : function (value) {
        return this.valueToVisible(value, this.durationUnit, this.decimalPrecision, this.useAbbreviation);
    },

    parseDuration : function (value) {
        if (value == null) {
            return null;
        }

        var me = this;
        var duration = this.durationParser.parse(value);

        if (!duration) {
            return null;
        }

        duration.unit = duration.unit || this.durationUnit;

        return duration;
    },


    /**
     * Returns an object, representing the current value of the field:

    {
        value   : ... // duration value,
        unit    : ... // duration unit
    }

     * @return {Object}
     */
    getDurationValue : function () {
        return this.parseDuration(this.getRawValue());
    },


    getErrors : function (value) {
        var parsed;
        if (value) {
            parsed   = this.parseDuration(value);

            if (!parsed) {
                return [ this.L('invalidText') ];
            }

            value   = parsed.value;
        }

        return this.callParent([ value ]);
    },


    // @OVERRIDE
    checkChange : function () {
        if (!this.suspendCheckChange) {
            var me = this,
                newVal = me.getDurationValue(),
                oldVal = me.lastValue;

            var isDifferent = newVal && !oldVal || !newVal && oldVal || newVal && oldVal &&
                (newVal.value != oldVal.value || newVal.unit != oldVal.unit);

            if (isDifferent && !me.isDestroyed) {
                me.lastValue = newVal;
                me.fireEvent('change', me, newVal, oldVal);
                me.onChange(newVal, oldVal);
            }
        }
    },

    // @OVERRIDE
    getValue : function () {
        return this.value;
    },


    /**
     * This method applies the changes from the field to the bound task or to the task provided as 1st argument.
     * If {@link #instantUpdate} option is enabled this method is called automatically after any change in the field.
     *
     * @param {Gnt.model.Task} [toTask] The task to apply the changes to. If not provided, changes will be applied to the last bound task
     * (with {@link #task} config option or {@link #setTask) method)
     */
    applyChanges : function (toTask) {
        toTask = toTask || this.task;

        toTask[this.setDurationMethod](this.getValue(), this.durationUnit);
    },

    // @OVERRIDE
    setValue : function (value, forceUpdate) {
        var val                 = value;

        if (Ext.isObject(value)) {
            this.durationUnit   = value.unit;
            val                 = value.value;
        }

        this.callParent([ val ]);

        if ((forceUpdate || this.instantUpdate) && !this.getSuppressTaskUpdate() && this.task) {

            // apply changes to task
            this.applyChanges();

            this.task.fireEvent('taskupdated', this.task, this);
        }
    },

    // @private
    // it's called in editor.completeEdit()
    assertValue : function () {
        var me      = this,
            oldVal  = me.getValue(),
            oldUnit = me.durationUnit,
            newVal  = me.getDurationValue();

        if (this.isValid()) {
            var isDifferent = newVal && !oldVal || !newVal && oldVal || newVal &&
                (newVal.value != oldVal || newVal.unit != oldUnit);

            if (isDifferent) {
                // at this point `setValue` should apply any changes from the field to the task
                // even if `instantUpdate` is disabled
                me.setValue(newVal, true);
            }
        }
    },

    // @OVERRIDE
    beforeBlur : function () {
        this.assertValue();
    },

    onSpinUp: function() {
        var me = this;

        if (!me.readOnly) {
            var value   = me.getValue() || 0;

            me.setSpinValue(Ext.Number.constrain(value + me.step, me.minValue, me.maxValue));
        }
    },

    onSpinDown: function() {
        var me = this;

        if (!me.readOnly) {
            var value   = me.getValue() || 0;

            me.setSpinValue(Ext.Number.constrain(value - me.step, me.minValue, me.maxValue));
        }
    }
});

/**
@class Gnt.field.Effort
@extends Gnt.field.Duration

A specialized field, allowing a user to also specify duration unit when editing the effort value.
This class inherits from the Gnt.field.Duration field, which inherits from `Ext.form.field.Number` so any usual `Ext.form.field.Number` configs can be used (like `minValue/maxValue` etc).

*/
Ext.define('Gnt.field.Effort', {
    extend                  : 'Gnt.field.Duration',

    requires                : ['Gnt.util.DurationParser'],

    alias                   : 'widget.effortfield',
    alternateClassName      : ['Gnt.column.effort.Field', 'Gnt.widget.EffortField'],

    /**
     * @cfg {String} invalidText Text shown when field value cannot be parsed to valid effort amount.
     */
    invalidText             : 'Invalid effort value',

    taskField               : 'effortField',
    getDurationUnitMethod   : 'getEffortUnit',
    setDurationMethod       : 'setEffort',
    getDurationMethod       : 'getEffort'
});

/**

A specialized field, allowing a user to also specify task scheduling mode value.
This class inherits from the standard Ext JS "combo" field, so any usual `Ext.form.field.ComboBox` configs can be used.

The value of this field can be one of the following strings: `Normal`, `Manual`, `FixedDuration`,
`EffortDriven`, `DynamicAssignment`.

@class Gnt.field.SchedulingMode
@extends Ext.form.field.ComboBox

*/
Ext.define('Gnt.field.SchedulingMode', {
    extend                  : 'Ext.form.field.ComboBox',

    mixins                  : ['Gnt.field.mixin.TaskField'],

    alias                   : 'widget.schedulingmodefield',

    alternateClassName      : ['Gnt.column.schedulingmode.Field'],

    taskField               : 'schedulingModeField',

    store                   : [
        [ 'Normal',             'Normal' ],
        [ 'Manual',             'Manual' ],
        [ 'FixedDuration',      'Fixed duration' ],
        [ 'EffortDriven',       'Effort driven' ],
        [ 'DynamicAssignment',  'Dynamic assignment' ]
    ],

    /**
     * @cfg {String} pickerAlign The align for combo-box's picker.
     */
    pickerAlign             : 'tl-bl?',

    /**
     * @cfg {Boolean} matchFieldWidth Whether the picker dropdown's width should be explicitly set to match the width of the field. Defaults to true.
     */
    matchFieldWidth         : true,

    editable                : false,

    forceSelection          : true,

    triggerAction           : 'all',

    constructor : function(config) {
        var me = this;

        Ext.apply(this, config);

        this.setSuppressTaskUpdate(true);
        this.callParent(arguments);
        this.setSuppressTaskUpdate(false);

        if (this.task) this.setTask(this.task);
    },

    destroy : function () {
        this.destroyTaskListener();

        this.callParent();
    },


    onSetTask : function () {
        this.setValue(this.task.getSchedulingMode());
    },


    // will be used in the column's renderer
    valueToVisible : function (value, task) {
        var me              = this,
            displayTplData  = [];

        var record = this.findRecordByValue(value);

        if (record) {
            displayTplData.push(record.data);
        } else if (Ext.isDefined(me.valueNotFoundText)) {
            displayTplData.push(me.valueNotFoundText);
        }

        return me.displayTpl.apply(displayTplData);
    },


    /**
     * This method applies the changes from the field to the bound task or to the task provided as 1st argument.
     * If {@link #instantUpdate} option is enabled this method is called automatically after any change in the field.
     *
     * @param {Gnt.model.Task} [toTask] The task to apply the changes to. If not provided, changes will be applied to the last bound task
     * (with {@link #task} config option or {@link #setTask) method)
     */
    applyChanges : function (toTask) {
        toTask = toTask || this.task;

        toTask.setSchedulingMode(this.getValue());
    },


    getValue : function () {
        return this.value;
    },

    setValue : function (value) {

        this.callParent([ value ]);

        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task && this.value) {
            // apply changes to task
            this.applyChanges();

            this.task.fireEvent('taskupdated', this.task, this);

        }
    }

});

/**
@class Gnt.field.Calendar
@extends Ext.form.field.ComboBox

A specialized field allowing a user to select particular calendar for a task.
This class inherits from the standard Ext JS "combo box" field, so any standard `Ext.form.field.ComboBox`
configs can be used.
*/

Ext.define('Gnt.field.Calendar', {
    extend                  : 'Ext.form.field.ComboBox',

    requires                : ['Gnt.data.Calendar'],

    mixins                  : ['Gnt.field.mixin.TaskField', 'Gnt.mixin.Localizable'],

    alias                   : 'widget.calendarfield',
    alternateClassName      : ['Gnt.column.calendar.Field'],

    taskField               : 'calendarIdField',

    /**
     * @cfg {String} pickerAlign The align for combo-box's picker.
     */
    pickerAlign             : 'tl-bl?',

    /**
     * @cfg {Boolean} matchFieldWidth Defines if the picker dropdown width should be explicitly set to match the width of the field. Defaults to true.
     */
    matchFieldWidth         : true,

    editable                : true,

    triggerAction           : 'all',

    valueField              : 'Id',

    displayField            : 'Name',

    queryMode               : 'local',

    forceSelection          : true,

    allowBlank              : true,

    constructor : function(config) {
        var me = this;

        Ext.apply(this, config);

        this.store = this.store || Ext.create('Ext.data.Store', {
            fields: [ 'Id', 'Name' ]
        });

        this.setSuppressTaskUpdate(true);
        this.callParent(arguments);
        this.setSuppressTaskUpdate(false);

        // if it`s rendered already
        if (this.rendered) {
            // fill store with data
            this.store.loadData(this.getCalendarData());
        // else fill store after render
        } else {
            this.on({
                render  : function() {
                    this.store.loadData(this.getCalendarData());
                },
                show    : this.setReadOnlyIfEmpty,
                scope   : this
            });
        }

        if (this.task) this.setTask(this.task);
    },

    destroy : function () {
        this.destroyTaskListener();

        this.callParent();
    },

    // @private
    // Sets field to readonly if no calendars found.
    setReadOnlyIfEmpty : function () {
        var cals    = Gnt.data.Calendar.getAllCalendars();
        if (!cals || !cals.length) {
            this.setReadOnly(true);
        }
    },

    getCalendarData : function () {
        var result = [];
        Ext.Array.each(Gnt.data.Calendar.getAllCalendars(), function(cal) {
            result.push({
                Id      : cal.calendarId,
                Name    : cal.name || cal.calendarId
            });
        });
        return result;
    },


    onSetTask : function () {
        // set field to readonly if no calendars
        this.setReadOnlyIfEmpty();

        this.setValue(this.task.getCalendarId());
    },

    onTaskUpdate : function (task, initiator) {
        // set field to readonly if no calendars
        this.setReadOnlyIfEmpty();

        this.setValue(this.task.getCalendarId());
    },


    // will be used in the column's renderer
    valueToVisible : function (value, task) {
        var me              = this,
            displayTplData  = [];

        var record = this.findRecordByValue(value);

        if (record) {
            displayTplData.push(record.data);
        } else if (Ext.isDefined(me.valueNotFoundText)) {
            displayTplData.push(me.valueNotFoundText);
        }

        return me.displayTpl.apply(displayTplData);
    },


    // @OVERRIDE
    getValue : function () {
        return this.value;
    },


    /**
     * This method applies the changes from the field to the bound task or to the task provided as 1st argument.
     * If {@link #instantUpdate} option is enabled this method is called automatically after any change in the field.
     *
     * @param {Gnt.model.Task} [toTask] The task to apply the changes to. If not provided, changes will be applied to the last bound task
     * (with {@link #task} config option or {@link #setTask) method)
     */
    applyChanges : function (toTask) {
        toTask = toTask || this.task;

        toTask.setCalendarId(this.value);
    },


    getErrors : function (value) {
        if (value) {
            var record = this.findRecordByDisplay(value);
            if (record) {
                if (this.task && !this.task.isCalendarApplicable(record.data.Id)) return [ this.L('calendarNotApplicable') ];
            }
        }

        return this.callParent(arguments);
    },


    // @OVERRIDE
    setValue : function (value) {

        this.callParent([ value ]);

        // we keep '' for empty field
        if (undefined === value || null === value || '' === value) this.value = '';

        if (!this.getSuppressTaskUpdate() && this.task) {

            if (this.task.getCalendarId() != this.value) {
                // apply changes to task
                this.applyChanges();

                this.task.fireEvent('taskupdated', this.task, this);
            }

        }
    },


    // @OVERRIDE
    assertValue : function () {
        var raw = this.getRawValue();
        if (!raw && this.value) {
            this.setValue('');
        } else {
            this.callParent(arguments);
        }
    }
});

/**

A specialized field to enter percent values.
This class inherits from the standard Ext JS "number" field, so any usual `Ext.form.field.Number` configs can be used.

@class Gnt.field.Percent
@extends Ext.form.field.Number

*/
Ext.define('Gnt.field.Percent', {
    extend              : 'Ext.form.field.Number',

    alias               : 'widget.percentfield',

    alternateClassName  : ['Gnt.widget.PercentField'],

    disableKeyFilter    : true,

    minValue            : 0,
    maxValue            : 100,

    invalidText         : 'Invalid percent value',

    valueToRaw: function (value) {
        if (Ext.isNumber(value)) {
            return parseFloat(Ext.Number.toFixed(value, this.decimalPrecision)) + '%';
        }
        return '';
    },

    getErrors: function (value) {
        var percent = this.parseValue(value);
        if (percent === null) {
            if (value !== null && value !== '') {
                return [this.invalidText];
            } else {
                percent = '';
            }
        }
        return this.callParent([percent]);
    }
});

/**
@class Gnt.field.Dependency
@extends Ext.form.field.Text

A specialized field allowing a user to change the dependencies of a task. The type of dependecies
created by this field is controlled by the {@link #type} config.

The text describing a dependency can be one or more values in the following format, separated with a {@link #separator} string:

    [TaskId][DependecyType][Lag]

where:

- `TaskId` is the id of the predecessor/successor task, can be a "real" or "sequential" id, see below.
- `DependecyType` (optional, default value is FS) is one of the following:
    - `FS` - for "Finish-To-Start"
    - `FF` - for "Finish-To-Finish"
    - `SF` - for "Start-To-Finish"
    - `SS` - for "Start-To-Start"
- `Lag` (optional). Should start with `+` or `-` followed by a number indicating the lag amount
and duration unit.

The `TaskId` part can contain either "real" id of the task (the id that is stored in the database) or "sequential" id.
The sequential id corresponds to the ordinal position of the task in the whole dataset. When you add or remove tasks 
from the dataset, the sequential id of the tasks may change. Which type of id is used is controled by the 
{@link #useSequenceNumber} config.

For example:
    10          - Finish to start dependency from task with Id 10
    10SS        - Start to start dependency from task with Id 10
    3FS+1d      - Finish to start dependency from task with Id 3, with +1 day lag
    3FS-10h      - Finish to start dependency from task with Id 3, with -10 hours lag

*/
Ext.define("Gnt.field.Dependency", {
    extend              : "Ext.form.field.Text",

    alternateClassName  : "Gnt.widget.DependencyField",
    alias               : "widget.dependencyfield",

    requires            : [
        'Gnt.util.DependencyParser'
    ],

    /**
     * @cfg {String} type Either `predecessors` or `successors`. Defines the type of dependencies managed by this field. Defaults to 'predecessors'.
     */
    type                : 'predecessors',        // Or successors

    /**
     * @cfg {String} separator A separator between the dependency values in the text field.
     */
    separator           : ';',

    task                : null,

    dependencyParser    : null,

    /**
     * @cfg {String} invalidFormatText An error message when the value is not in a recognized format.
     */
    invalidFormatText   : "Invalid dependency format",

    /**
     * @cfg {String} invalidDependencyText An error message when one of the dependencies being created
     * is invalid - ie forms a cycle.
     */
    invalidDependencyText : "Invalid dependency found, please make sure you have no cyclic paths between your tasks",

    /**
     * @cfg {Boolean} useSequenceNumber Set to `true` to use auto-generated sequential identifiers
     * to reference other tasks (see {@link Gnt.model.Task#getSequenceNumber} for definition). 
     * If value is `false`then "real" id (that is stored in the database) will be used.
     */
    useSequenceNumber : false,

    constructor         : function(config) {
        var me = this;
        Ext.apply(this, config);

        this.dependencyParser = new Gnt.util.DependencyParser({
            // Since we're reusing the NumberField's parsing of numbers, we have to pass this on to the parser
            // to avoid having the same definitions in the parser too
            parseNumberFn : function() { return Gnt.widget.DurationField.prototype.parseValue.apply(me, arguments); }
        });

        this.callParent(arguments);

        this.addCls('gnt-field-dependency');
    },


    isPredecessor : function() {
        return this.type === 'predecessors';
    },

    /**
     * Set the task this field is bound to.
     *
     * @param {Gnt.model.Task} task
     */
    setTask : function(task) {
        this.task   = task;
        this.setRawValue(this.getDisplayValue(task));
    },

    /**
     * Returns an array of dependency objects representing the current value of the field:

        [
            {
                taskId  : 3,    // Int, always present
                type    : "FS", // String, always present
                lag     : 3,    // Int, optional
                lagUnit : 'd'   // String, optional
            },
            ...
        ]

     * @return {Object} The dependencies
     */
    getDependencies: function () {
        return this.dependencyParser.parse(this.getRawValue());
    },


    getTaskIdFromDependency : function (dependencyData) {
        var store = this.task.getTaskStore(),
            taskId = dependencyData.taskId,
            task;

        if (this.useSequenceNumber) {
            task = store.getBySequenceNumber(taskId);
            taskId = task && task.getInternalId();
        }

        return taskId;
    },


    getErrors : function (value) {
        if (!value) return;

        var parsed   = this.dependencyParser.parse(value);

        if (!parsed) {
            return [ this.invalidFormatText ];
        }

        var dependencies  = this.getDependencies(),
            isPredecessor = this.isPredecessor(),
            task = this.task,
            dependencyStore = task.getTaskStore().dependencyStore,
            taskId, fromId, toId;

        for (var i = 0; i < dependencies.length; i++) {
            taskId = this.getTaskIdFromDependency(dependencies[i]);

            if (!taskId) {
                return [ this.invalidDependencyText ];
            }

            fromId = isPredecessor ? taskId : task.getInternalId();
            toId  = !isPredecessor ? taskId : task.getInternalId();

            // Verify all referenced tasks exist in the store and that the dependency is not cyclic etc.
            if (!dependencyStore.areTasksLinked(fromId, toId) &&
                !dependencyStore.isValidDependency(fromId, toId)) {

                return [ this.invalidDependencyText ];
            }
        }

        return this.callParent([ parsed.value ]);
    },

    getDisplayValue    : function (task) {
        var isPredecessor   = this.isPredecessor(),
            deps            = isPredecessor ? task.getIncomingDependencies(true) : task.getOutgoingDependencies(true),
            dpTypes         = Gnt.util.DependencyParser.prototype.types,
            endToStart      = Gnt.model.Dependency.Type.EndToStart,
            strings         = [],
            depTask;

        for (var i = 0; i < deps.length; i++) {
            var dep     = deps[i];
            
            depTask     = isPredecessor ? dep.getSourceTask() : dep.getTargetTask();

            if (depTask && dep.isValid(false)) {
                var type        = dep.getType(),
                    lag         = dep.getLag(),
                    lagUnit     = dep.getLagUnit();

                strings.push(Ext.String.format(
                    '{0}{1}{2}{3}{4}',
                    this.useSequenceNumber ? depTask.getSequenceNumber() : depTask.getInternalId(),
                    lag || type !== endToStart ? dpTypes[type] : '',
                    lag > 0 ? '+' : '',
                    lag || '',
                    lag && lagUnit !== 'd' ? lagUnit : '')
                );
            }
        }

        return strings.join(this.separator);
    },

    /**
     * This method applies the changes from the field to the bound task or to the task provided as 1st argument.
     *
     * @param {Gnt.model.Task} [toTask] The task to apply the changes to. If not provided, changes will be applied to the last bound task
     * (with {@link #task} config option or {@link #setTask) method)
     */
    applyChanges : function(task) {
        task = task || this.task;

        var depStore      = task.getTaskStore().dependencyStore,
            dependencies  = this.getDependencies(),
            ids           = [],
            isPredecessor = this.isPredecessor(),
            currentDeps   = isPredecessor ? task.getIncomingDependencies(true) : task.getOutgoingDependencies(true),
            toRemove      = [];

        for (var i = 0, l = dependencies.length; i < l; i++) {
            ids.push(this.getTaskIdFromDependency(dependencies[i]));
        }

        // First remove deleted dependencies
        for (i = 0; i < currentDeps.length; i++) {
            if (!Ext.Array.contains(ids, currentDeps[i][isPredecessor ? 'getSourceId' : 'getTargetId']())) {
                toRemove.push(currentDeps[i]);
            }
        }
        if (toRemove.length > 0) {
            depStore.remove(toRemove);
        }

        var toAdd = [];

        // Now iterate cell value, to update or add new dependencies
        for (i = 0; i < dependencies.length; i++) {
            var depData = dependencies[i];
            var predId = this.getTaskIdFromDependency(depData);
            var dep = depStore.getByTaskIds(predId, task.getInternalId());

            if (dep) {
                dep.beginEdit();
                dep.setType(depData.type);
                dep.setLag(depData.lag);
                dep.setLagUnit(depData.lagUnit);
                dep.endEdit();
            } else {
                toAdd.push(new depStore.model({
                    fromTask    : isPredecessor ? predId : task.getInternalId(),
                    toTask      : isPredecessor ? task.getInternalId() : predId,
                    type        : depData.type,
                    lag         : depData.lag,
                    lagUnit     : depData.lagUnit
                }));
            }
        }

        if (toAdd.length > 0) {
            depStore.add(toAdd);
        }

        if (toAdd.length || toRemove.length) task.triggerUIUpdate();
    }
});

/**
@class Gnt.field.Milestone
@extends Ext.form.field.ComboBox

A specialized field allowing a user to convert regular task to milestone and back.

*/
Ext.define('Gnt.field.Milestone', {
    extend                  : 'Ext.form.field.ComboBox',
    requires                : 'Ext.data.JsonStore',
    mixins                  : ['Gnt.field.mixin.TaskField', 'Gnt.mixin.Localizable'],

    alias                   : 'widget.milestonefield',

    instantUpdate           : false,
    allowBlank              : false,
    forceSelection          : true,
    displayField            : 'text',
    valueField              : 'value',
    queryMode               : 'local',

    constructor : function (config) {

        Ext.apply(this, config);

        this.store  = new Ext.data.JsonStore({
            fields  : ['value', 'text'],
            data    : [
                { value : 0, text : this.L('no') },
                { value : 1, text : this.L('yes') }
            ]
        });

        this.setSuppressTaskUpdate(true);
        this.callParent(arguments);
        this.setSuppressTaskUpdate(false);

        if (this.task) {
            this.setTask(this.task);
        }
    },

    destroy : function () {
        this.destroyTaskListener();

        this.callParent();
    },

    onSetTask : function () {
        this.setValue(this.task.isMilestone() ? 1 : 0);
    },

    valueToVisible : function (value) {
        return value ? this.L('yes') : this.L('no');
    },

    // @OVERRIDE
    setValue : function (value) {
        this.callParent([value]);

        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task) {

            if (this.task.isMilestone() != Boolean(this.value)) {
                // apply changes to task
                this.applyChanges();

                this.task.fireEvent('taskupdated', this.task, this);
            }

        }
    },

    getValue : function () {
        return this.value;
    },

    applyChanges : function (task) {
        task    = task || this.task;
        if (this.getValue()) {
            task.convertToMilestone();
        } else {
            task.convertToRegular();
        }
    }
});

/*
 * @class Gnt.column.ResourceName
 * @extends Ext.grid.Column
 * @private
 * Private class used inside Gnt.widget.AssignmentGrid.
 */
Ext.define('Gnt.column.ResourceName', {
    extend         : 'Ext.grid.column.Column',
    alias          : 'widget.resourcenamecolumn',
    mixins         : ['Gnt.mixin.Localizable'],

    dataIndex      : 'ResourceName',
    flex           : 1,
    align          : 'left',

    // Exclude in Gnt.column.AddNew list
    _isGanttColumn : false,

    constructor : function (config) {
        config = config || {};

        this.text   = config.text || this.L('text');
        
        Ext.apply(this, config);

        this.callParent(arguments);
    }
});

/*
 * @class Gnt.column.AssignmentUnits
 * @extends Ext.grid.Column
 * @private
 * Private class used inside Gnt.widget.AssignmentGrid.
 */
Ext.define("Gnt.column.AssignmentUnits", {
    extend      : "Ext.grid.column.Number",
    mixins      : ['Gnt.mixin.Localizable'],
    alias       : "widget.assignmentunitscolumn",

    dataIndex   : 'Units',
    format      : '0 %',
    align       : 'left',

    constructor : function (config) {
        config = config || {};        

        this.text   = config.text || this.L('text');

        this.callParent(arguments);
    }
});

/**
@class Gnt.widget.AssignmentGrid
@extends Ext.grid.Panel

A class used to display and edit the task assignments. You can configure this through the {@link Gnt.widget.AssignmentField#gridConfig gridConfig} object
available on the {@link Gnt.widget.AssignmentField} class.

*/
Ext.define('Gnt.widget.AssignmentGrid', {
    extend      : 'Ext.grid.Panel',
    alias       : 'widget.assignmentgrid',

    requires    : [
        'Gnt.model.Resource',
        'Gnt.model.Assignment',
        'Gnt.column.ResourceName',
        'Gnt.column.AssignmentUnits',
        'Ext.grid.plugin.CellEditing'
    ],

    /**
     * @cfg {Ext.data.Store} assignmentStore A store with assignments
     */
    assignmentStore         : null,

    /**
     * @cfg {Ext.data.Store} resourceStore A store with resources
     */
    resourceStore           : null,

    readOnly                : false,
    cls                     : 'gnt-assignmentgrid',

    defaultAssignedUnits    : 100,
    taskId                  : null,

    sorter : {
        sorterFn: function(o1, o2){
            var un1 = o1.getUnits(),
                un2 = o2.getUnits();

            if ((!un1 && !un2) || (un1 && un2)) {
                return o1.get('ResourceName') < o2.get('ResourceName') ? -1 : 1;
            }

            return un1 ? -1 : 1;
        }
    },

    constructor : function (config) {
       this.store = Ext.create("Ext.data.JsonStore", {
           model: Ext.define('Gnt.model.AssignmentEditing', {
               extend : 'Gnt.model.Assignment',
               fields : ['ResourceName']
           })
        });

        this.columns = this.buildColumns();

        if (!this.readOnly) {
            this.plugins = this.buildPlugins();
        }

        Ext.apply(this, {
            selModel: {
                selType: 'checkboxmodel',
                mode: 'MULTI',
                checkOnly : true,

                // Hack to keep records selected when tabbing in the cells
                selectByPosition : function(position) {
                    var record = this.store.getAt(position.row);
                    this.select(record, true);
                }
            }
        });

        this.callParent(arguments);
    },

    initComponent : function() {
        this.loadResources();

        this.mon(this.resourceStore, {
           datachanged : this.loadResources,
           scope       : this
        });

        // Delay required since repaint of the row happens too fast which messes up picker collapse logic!
        this.getSelectionModel().on('select', this.onSelect, this, { delay : 50 });

        this.callParent(arguments);
    },

    onSelect : function(sm, rec) {
        if ((!this.cellEditing || !this.cellEditing.getActiveEditor()) && !rec.getUnits()) {
            rec.setUnits(this.defaultAssignedUnits);
        }
    },

    loadResources: function() {
        var data = [],
            rs = this.resourceStore,
            id;

        for (var i = 0, l = rs.getCount(); i < l; i++) {
            id = rs.getAt(i).getId();
            data.push({
                ResourceId      : id,
                ResourceName    : rs.getById(id).getName(),
                Units           : ''
            });
        }
        this.store.loadData(data);
    },

    // @private
    buildPlugins : function() {

        var cellEditing = this.cellEditing = Ext.create('Ext.grid.plugin.CellEditing', {
            clicksToEdit: 1
        });

        cellEditing.on('edit', this.onEditingDone, this);

        return [
            cellEditing
        ];
    },

    hide : function() {
        this.cellEditing.cancelEdit();
        this.callParent(arguments);
    },

    onEditingDone : function(ed, e) {
        // Make sure row is selected after editing a cell
        if (e.value) {
            this.getSelectionModel().select(e.record, true);
        } else {
            this.getSelectionModel().deselect(e.record);
            e.record.reject();
        }
    },

    // @private
    buildColumns : function() {
        return [
            {
                xtype : 'resourcenamecolumn'
            },
            {
                xtype : 'assignmentunitscolumn',
                assignmentStore : this.assignmentStore,
                editor : {
                    xtype : 'numberfield',
                    minValue : 0,
                    step : 10
                }
            }
        ];
    },

    loadTaskAssignments : function(taskId) {
        var store       = this.store,
            sm          = this.getSelectionModel();

        this.taskId = taskId;

        // clear all checkboxes
        sm.deselectAll(true);

        // Reset all "Units" values of all resource assignment records first
        for (var i = 0, l = store.getCount(); i < l; i++) {
            // should be ok to use field names here, since we are inheriting directly from Gnt.model.Assignment
            store.getAt(i).data.Units = "";
            store.getAt(i).data.Id = null;
        }

        store.suspendEvents();

        var taskAssignments = this.assignmentStore.queryBy(function(a) { return a.getTaskId() == taskId; });

        taskAssignments.each(function (assignment) {
            var resourceAssignmentRecord = store.findRecord("ResourceId", assignment.getResourceId(), 0, false, true, true);

            if (resourceAssignmentRecord) {
                resourceAssignmentRecord.setUnits(assignment.getUnits());
                // can't assign to "idProperty" of the record because if "id" is missing
                // the store internal mapping will be broken (and "indexOf" method of the store will stop working)
                resourceAssignmentRecord.__id__     = assignment.getId();

                // mark the record with checkbox
                sm.select(resourceAssignmentRecord, true, true);
            }
        });
        store.resumeEvents();

        // Apply sort to show assigned resources at the top
        store.sort(this.sorter);

        this.getView().refresh();
    },

    saveTaskAssignments : function() {
        var aStore      = this.assignmentStore,
            taskId      = this.taskId;

        var assignmentsToStay   = {};
        var newAssignments      = [];

        this.getSelectionModel().selected.each(function (resourceAssignmentRecord) {
            var units = resourceAssignmentRecord.getUnits();

            if (units > 0) {
                var id      = resourceAssignmentRecord.__id__;

                if (id) {
                    assignmentsToStay[ id ] = true;

                    aStore.getById(id).setUnits(units);
                } else {
                    var newAssignment = Ext.create(aStore.model);
                    newAssignment.setTaskId(taskId);
                    newAssignment.setResourceId(resourceAssignmentRecord.getResourceId());
                    newAssignment.setUnits(units);

                    assignmentsToStay[ newAssignment.internalId ] = true;

                    newAssignments.push(newAssignment);
                }
            }
        });

        var assignmentsToRemove     = [];

        // Remove any assignments that
        // - are not phantom
        // - and have been unchecked (and thus are not included in `assignmentsToStay`)
        aStore.each(function (assignment) {
            //   assignment is for our task       | not phantom |       was unchecked
            if (assignment.getTaskId() === taskId && !assignmentsToStay[ assignment.getId() || assignment.internalId ]) {
                assignmentsToRemove.push(assignment);
            }
        });

        aStore.suspendAutoSync();

        aStore.remove(assignmentsToRemove);

        // Add selected assignments for this task
        aStore.add(newAssignments);

        aStore.resumeAutoSync();

        if (aStore.autoSync) {
            aStore.sync();
        }
    }
});

/**

@class Gnt.field.Assignment
@extends Ext.form.field.Picker

A specialized field to be used for editing in the {@link Gnt.column.ResourceAssignment} column.

*/

Ext.define('Gnt.field.Assignment', {
    extend              : 'Ext.form.field.Picker',

    alias               : ['widget.assignmentfield', 'widget.assignmenteditor'],
    alternateClassName  : 'Gnt.widget.AssignmentField',

    requires            : ['Gnt.widget.AssignmentGrid'],

    mixins              : ['Gnt.mixin.Localizable'],

    matchFieldWidth     : false,
    editable            : false,
    task                : null,

    /**
     * @cfg {String} cancelText A text for the `Cancel` button
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} closeText A text for the `Close` button
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - cancelText : 'Cancel',
            - closeText  : 'Save and Close'
     */

    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore A store with assignments
     */
    assignmentStore     : null,

    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore A store with resources
     */
    resourceStore       : null,

    /**
     * @cfg {Object} gridConfig A custom config object used to configure the Gnt.widget.AssignmentGrid instance
     */
    gridConfig          : null,

    /**
     * @cfg {String} formatString A string defining how an assignment should be rendered. Defaults to '{0} [{1}%]'
     */
    formatString        : '{0} [{1}%]',

    /**
     * @cfg {Boolean} expandPickerOnFocus true to show the grid picker when this field receives focus.
     */
    expandPickerOnFocus : false,

    afterRender : function() {
        this.callParent(arguments);
        this.on('expand', this.onPickerExpand, this);

        if (this.expandPickerOnFocus) {
            this.on('focus', function() {
                this.expand();
            }, this);
        }
    },

    createPicker: function() {
        var grid = new Gnt.widget.AssignmentGrid(Ext.apply({
            ownerCt     : this.ownerCt,

            renderTo    : document.body,

            frame       : true,
            floating    : true,
            hidden      : true,

            height      : 200,
            width       : 300,

            resourceStore       : this.task.getResourceStore(),
            assignmentStore     : this.task.getAssignmentStore(),

            fbar                : this.buildButtons()
        }, this.gridConfig || {}));

        return grid;
    },


    buildButtons : function() {
        return [
            '->',
            {
                text        : this.L('closeText'),

                handler     : function () {
                    // when clicking on "close" button with editor visible
                    // grid will be destroyed right away and seems in IE there will be no
                    // "blur" event for editor
                    // this is also sporadically reproducable in FF
                    // doing a defer to let the editor to process the "blur" first (will take 1 + 10 ms delay)
                    // only then close the editor window
                    Ext.Function.defer(this.onGridClose, Ext.isIE && !Ext.isIE9 ? 60 : 30, this);
                },
                scope       : this
            },
            {
                text        : this.L('cancelText'),

                handler     : function() {
                    this.collapse();

                    // HACK, trick the owning Editor into thinking we're no longer editing
                    this.fireEvent('blur', this);
                },
                scope       : this
            }
        ];
    },

    setTask : function(task){
        this.task = task;
        this.setRawValue(this.getDisplayValue(task));
    },

    onPickerExpand: function() {
        // Select the assigned resource in the grid
        this.picker.loadTaskAssignments(this.task.getInternalId());
    },


    onGridClose : function() {
        // Update the assignment store with the assigned resource data
        var sm = this.picker.getSelectionModel(),
            selections = sm.selected;

        this.collapse();

        // HACK, trick the owning Editor into thinking we're no longer editing
        this.fireEvent('blur', this);

        this.fireEvent('select', this, selections);

        // Without this defer, a visible field realignment is noticed
        Ext.Function.defer(this.picker.saveTaskAssignments, 1, this.picker);
    },

    // http://www.sencha.com/forum/showthread.php?187632-4.1.0-B3-getEditorParent-is-ignored-nested-cell-editing-is-not-possible&p=755211
    // @OVERRIDE
    collapseIf: function(e) {
        var me = this;

        // HACK: Not trivial to find all cases, menus, editors etc.
        if (this.picker && !e.getTarget('.' + Ext.baseCSSPrefix + 'editor') && !e.getTarget('.' + Ext.baseCSSPrefix + 'menu-item')) {
            me.callParent(arguments);
        }
    },

    // Required as of 4.1.2
    // @OVERRIDE
    mimicBlur: function(e) {
        var me = this;

        if (!e.getTarget('.' + Ext.baseCSSPrefix + 'editor') && !e.getTarget('.' + Ext.baseCSSPrefix + 'menu-item')) {
            me.callParent(arguments);
        }
    },

    getDisplayValue : function(task) {
        task = task || this.task;

        var names               = [],
            assignmentStore     = this.assignmentStore,
            assignment,
            taskId              = task.getInternalId(),
            assignments         = task.getAssignments();

        for (var i = 0, l = assignments.length; i < l; i++) {
            assignment  = assignments[i];

            if (assignment.data.Units > 0) {
                names.push(Ext.String.format(this.formatString, assignment.getResourceName(), assignment.getUnits()));
            }
        }
        return names.join(', ');
    }
}, function() {

    // @BWCOMPAT 2.2
    Gnt.widget.AssignmentCellEditor = function() {
        var con = console;
        if (con && con.log) {
            con.log('Gnt.widget.AssignmentCellEditor is deprecated and should no longer be used. Instead simply use Gnt.field.Assignment.');
        }
    };
});

/**

@class Gnt.column.ResourceAssignment
@extends Ext.grid.column.Column

{@img gantt/images/resource-assignment.png}

A Column showing the resource assignments of a task. To make the column editable,
add the {@link Sch.plugin.TreeCellEditing} plugin to your gantt panel:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your static columns
        columns         : [
            ...
            {
                xtype       : 'resourceassignmentcolumn',
                width       : 80
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

*/
Ext.define("Gnt.column.ResourceAssignment", {
    extend      : "Ext.grid.column.Column",
    alias       : "widget.resourceassignmentcolumn",
    requires    : ['Gnt.field.Assignment'],
    mixins      : ['Gnt.mixin.Localizable'],

    tdCls       : 'sch-assignment-cell',

    /**
     * @cfg {Boolean} showUnits Set to `true` to show the assignment units (in percent). Default value is `true`.
     */
    showUnits   : true,

    field       : null,

    constructor : function(config) {
        config      = config || {};



        this.text   = config.text || this.L('text');

        var field   = config.field || config.editor;
        var showUnits = config.showUnits || this.showUnits;

        delete config.field;
        delete config.editor;

        config.editor   = field || {};

        if (!(config.editor instanceof Ext.form.Field)) {
            config.editor   = Ext.ComponentManager.create(Ext.applyIf(config.editor, {
                expandPickerOnFocus : true,
                formatString        : '{0}' + (showUnits ? ' [{1}%]' : '')
            }), 'assignmentfield');
        }

        config.field = config.editor;

        this.callParent([ config ]);

        this.scope          = this;
    },

    renderer : function(value, meta, task) {
        return this.field.getDisplayValue(task);
    }
});

/**

@class Gnt.column.Name
@extends Ext.tree.Column

A Column representing the `Name` field of a task. The column is editable, however to enable the editing you will need to add a
`Sch.plugin.TreeCellEditing` pluing to your gantt panel. The overall setup will look like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your grid columns
        columns         : [
            ...
            {
                xtype       : 'namecolumn',
                width       : 200
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

*/
Ext.define('Gnt.column.Name', {
    extend      : 'Ext.tree.Column',

    alias       : 'widget.namecolumn',

    mixins      : ['Gnt.mixin.Localizable'],

    /**
     * @cfg {String} text The text to show in the column header.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

        - text : 'Task Name'
     */

    constructor : function (config) {
        config      = config || {};

        this.text   = config.text || this.L('text');

        var field   = config.field || config.editor;

        delete config.field;
        delete config.editor;

        Ext.apply(this, config);

        config.editor     = field || {
            xtype       : 'textfield',
            allowBlank  : false
        };

        this.scope      = this;

        this.callParent([ config ]);
    },

    afterRender : function() {
        var me      = this,
            tree    = this.up('treepanel');

        if (!this.dataIndex) {
            this.dataIndex = tree.store.model.prototype.nameField;
        }

        this.callParent(arguments);
    },

    renderer : function (value, meta, task) {
        if (!task.isEditable(this.dataIndex)) {
            meta.tdCls      = (meta.tdCls || '') + ' sch-column-readonly';
        }

        return value;
    }
});

/**
@class Gnt.column.Note
@extends Ext.grid.column.Column

A Column showing the `Note` field of the task.

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your static columns
        columns         : [
            ...
            {
                xtype       : 'notecolumn',
                width       : 80
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

*/
Ext.define("Gnt.column.Note", {
    extend      : "Ext.grid.column.Column",
    mixins      : ['Gnt.mixin.Localizable'],
    alias       : "widget.notecolumn",
    field       : {
        xtype   : 'textfield'
    },

    constructor : function (config) {
        config = config || {};        

        this.text   = config.text || this.L('text');

        this.callParent(arguments);

        this.scope = this;
    },


    afterRender : function () {
        var panel = this.up('treepanel');

        if (!this.dataIndex) {
            this.dataIndex = panel.store.model.prototype.noteField;
        }

        this.callParent(arguments);
    },

    renderer : function (value, meta, task) {
        if (!task.isEditable(this.dataIndex)) {
            meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';
        }
        return value;
    }
});

/**

@class Gnt.column.EndDate
@extends Ext.grid.column.Date

A Column showing the `EndDate` field of the tasks. The column is editable when adding a
`Sch.plugin.TreeCellEditing` plugin to your gantt panel. The overall setup will look like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your static columns
        columns         : [
            ...
            {
                xtype       : 'enddatecolumn',
                width       : 80
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

Note, that this column will provide only a day-level editor (using a subclassed Ext JS DateField). If you need a more precise editing (ie also specify
the start hour/minute) you will need to provide your own field (which should extend {@link Gnt.field.EndDate}). See this [forum thread][1] for more information.

[1]: http://bryntum.com/forum/viewtopic.php?f=16&t=2277&start=10#p13964

Note that the end date of task in gantt is not inclusive, however, this column will compensate the value when rendering or editing.
So for example, if you have a 1 day task which starts at 2011/07/20 and ends at 2011/07/21 (remember end date is not inclusive!),
this column will show the `2011/07/20` when rendering. It will also increase the date by 1 day after being edited.

Also note, that this class inherits from [Ext.grid.column.Date](http://docs.sencha.com/ext-js/4-1/#!/api/Ext.grid.column.Date) and supports its configuration options, notably the "format" option.

*/
Ext.define("Gnt.column.EndDate", {
    extend          : "Ext.grid.column.Date",

    alias           : "widget.enddatecolumn",

    requires        : [
        'Ext.grid.CellEditor',
        'Gnt.field.EndDate'
    ],

    mixins          : ['Gnt.mixin.Localizable'],

    /**
     * @cfg {string} text The text to show in the column header, defaults to `Finish`
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

        - text : 'Finish'
     */

    /**
     * @cfg {Number} width The width of the column.
     */
    width           : 100,

    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align           : 'left',

    /**
     * @cfg {String} editorFormat A date format to be used when editing the value of the column. By default it is the same as `format` configuration
     * option of the column itself.
     */
    editorFormat    : null,

    /**
     * @cfg {Boolean} adjustMilestones When set to `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*. The task model will still hold unmodified date.
     */
    adjustMilestones        : true,

    /**
     * @cfg {Boolean} validateStartDate When set to `true`, the column will validate a "startDate <= endDate" condition and won't allow user to save the invalid end date.
     * Set it to `false` if you use different validation mechanism.
     */
    validateStartDate       : true,

    /**
     * @cfg {Boolean} instantUpdate Set to `true` to instantly apply any changes in the field to the task.
     * This option is just translated to the {@link Gnt.field.mixin.TaskField#instantUpdate} config option.
     */
    instantUpdate           : false,

    /**
     * @cfg {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the task), `false` to change the duration ("resize" the task).
     */
    keepDuration            : false,

    field                   : null,

    constructor : function (config) {
        config = config || {};

        this.text   = config.text || this.L('text');

        // this will be a real field
        var field   = config.field || config.editor;

        delete config.field;

        var editorCfg = {
            format              : config.editorFormat || config.format || this.format || Ext.Date.defaultFormat,
            instantUpdate       : this.instantUpdate,
            adjustMilestones    : this.adjustMilestones,
            keepDuration        : this.keepDuration,
            validateStartDate   : this.validateStartDate
        };

        Ext.Array.forEach(
            [ 'instantUpdate', 'adjustMilestones', 'keepDuration', 'validateStartDate' ],
            function (prop) {
                if (prop in config) editorCfg[prop] = config[prop];
            },
            this
        );

        config.editor = field || editorCfg;

        if (!(config.editor instanceof Gnt.field.EndDate)) {

            // apply editor configs
            Ext.applyIf(config.editor, editorCfg);

            config.editor = Ext.ComponentManager.create(config.editor, 'enddatefield');
        }

        config.field = config.editor;

        // Make sure Ext 'understands' this column has its own renderer which makes sure this column is always updated
        // if any task field is changed
        this.hasCustomRenderer = true;

        this.callParent([ config ]);

        this.scope      = this;
        this.renderer   = config.renderer || this.rendererFunc;

        this.editorFormat = this.editorFormat || this.format;
    },


    rendererFunc : function (value, meta, task) {
        if (!value) return;

        if (!task.isEditable(this.dataIndex)) {
            meta.tdCls      = (meta.tdCls || '') + ' sch-column-readonly';
        }

        value = this.field.valueToVisible(value, task);

        return Ext.util.Format.date(value, this.format);
    },


    afterRender : function() {
        var tree = this.ownerCt.up('treepanel');

        if (!this.dataIndex) {
            this.dataIndex = tree.store.model.prototype.endDateField;
        }

        this.callParent(arguments);
    }
});

/**
@class Gnt.column.PercentDone
@extends Ext.grid.column.Number

A Column representing the `PercentDone` field of the task. The column is editable when adding a
`Sch.plugin.TreeCellEditing` plugin to your Gantt panel. The overall setup will look like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your static columns
        columns         : [
            ...
            {
                xtype       : 'percentdonecolumn',
                width       : 80
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })


*/
Ext.define("Gnt.column.PercentDone", {
    extend      : "Ext.grid.column.Number",
    alias       : "widget.percentdonecolumn",

    mixins      : ['Gnt.mixin.Localizable'],

    width       : 50,
    format      : '0',
    align       : 'center',

    field       : {
        xtype       : 'numberfield',
        minValue    : 0,
        maxValue    : 100
    },


    constructor : function (config) {
        config          = config || {};

        

        this.text   = config.text || this.L('text');

        this.callParent(arguments);

        this.scope      = this;
    },


    afterRender: function() {
        var panel       = this.up('treepanel');

        if (!this.dataIndex) {
            this.dataIndex = panel.store.model.prototype.percentDoneField;
        }

        this.callParent(arguments);
    },


    renderer    : function (value, meta, task) {
        if (!task.isEditable(this.dataIndex)) {
            meta.tdCls      = (meta.tdCls || '') + ' sch-column-readonly';
        }
        return this.defaultRenderer(value, meta, task);
    }

});

/**

@class Gnt.column.StartDate
@extends Ext.grid.column.Date

A Column representing a `StartDate` field of a task. The column is editable, however to enable the editing you will need to add a
`Sch.plugin.TreeCellEditing` plugin to your gantt panel. The overall setup will look like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your static columns
        columns         : [
            ...
            {
                xtype       : 'startdatecolumn',
                width       : 80
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

Note, that this column will provide only a day-level editor (using a subclassed Ext JS DateField). If you need a more precise editing (ie also specify
the start hour/minute) you will need to provide your own field which should subclass {@link Gnt.field.StartDate}. See [forumthread][1] for more information.

Also note, that this class inherits from [Ext.grid.column.Date](http://docs.sencha.com/ext-js/4-1/#!/api/Ext.grid.column.Date) and supports its configuration options, notably the "format" option.

[1]: http://bryntum.com/forum/viewtopic.php?f=16&t=2277&start=10#p13964

*/
Ext.define('Gnt.column.StartDate', {
    extend              : 'Ext.grid.column.Date',
    alias               : 'widget.startdatecolumn',

    requires            : ['Gnt.field.StartDate'],
    mixins              : ['Gnt.mixin.Localizable'],

    /**
     * @cfg {string} text The text to show in the column header, defaults to `Start`
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - text : 'Start'
     */

    /**
     * @cfg {Number} width A width of the column, default value is 100
     */
    width               : 100,

    /**
     * @cfg {String} align An align of the text in the column, default value is 'left'
     */
    align               : 'left',

    /**
     * @cfg {String} editorFormat A date format to be used when editing the value of the column. By default it is the same as `format` configuration
     * option of the column itself.
     */
    editorFormat        : null,

    /**
     * @cfg {Boolean} adjustMilestones When set to `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*. The task model will still hold unmodified date.
     */
    adjustMilestones    : true,

    /**
     * @cfg {Boolean} instantUpdate Set to `true` to instantly apply any changes in the field to the task.
     * This option is just translated to the {@link Gnt.field.mixin.TaskField#instantUpdate} config option.
     */
    instantUpdate       : false,

    /**
     * @cfg {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the task), `false` to change the duration ("resize" the task).
     */
    keepDuration        : true,

    field               : null,

    constructor : function (config) {
        config = config || {};

        this.text   = config.text || this.L('text');

        var field   = config.field || config.editor;

        delete config.field;

        var editorCfg = {
            format              : config.editorFormat || config.format || this.format || Ext.Date.defaultFormat,
            instantUpdate       : this.instantUpdate,
            adjustMilestones    : this.adjustMilestones,
            keepDuration        : this.keepDuration
        };

        Ext.Array.forEach(
            [ 'instantUpdate', 'adjustMilestones', 'keepDuration' ],
            function (prop) {
                if (prop in config) editorCfg[prop] = config[prop];
            },
            this
        );

        config.editor = field || editorCfg;

        if (!(config.editor instanceof Gnt.field.StartDate)) {

            // apply editor configs
            Ext.applyIf(config.editor, editorCfg);

            config.editor = Ext.ComponentManager.create(config.editor, 'startdatefield');
        }

        config.field = config.editor;

        // Make sure Ext 'understands' this column has its own renderer which makes sure this column is always updated
        // if any task field is changed
        this.hasCustomRenderer = true;

        this.callParent([ config ]);

        this.renderer   = config.renderer || this.rendererFunc;
        this.editorFormat = this.editorFormat || this.format;
    },

    afterRender : function() {
        var tree        = this.up('treepanel');
        var taskStore   = tree.store;

        if (!this.dataIndex) {
            this.dataIndex = taskStore.model.prototype.startDateField;
        }

        this.callParent(arguments);
    },

    rendererFunc : function (value, meta, task) {
        if (!value) return;

        if (!task.isEditable(this.dataIndex)) {
            meta.tdCls      = (meta.tdCls || '') + ' sch-column-readonly';
        }

        value   = this.field.valueToVisible(value, task);

        return Ext.util.Format.date(value, this.format);
    }
});

/**

@class Gnt.column.WBS
@extends Ext.grid.column.Date

A "calculated" Column which displays the WBS (Work Breakdown Structure) for the tasks - the position of the task in the project tree structure.
*/
Ext.define("Gnt.column.WBS", {
    extend      : "Ext.grid.column.Column",
    alias       : "widget.wbscolumn",
    mixins      : ['Gnt.mixin.Localizable'],

    /**
     * @cfg {String} text The text to show in the column header, defaults to `#`
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - text : '#'
     */

    /**
     * @cfg {Number} width The width of the column.
     */
    width       : 40,

    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align       : 'left',

    sortable    : false,
    dataIndex   : 'index',

    constructor : function (config) {
        config = config || {};        

        this.text   = config.text || this.L('text');

        this.callParent(arguments);
    },

    renderer    : function (value, meta, task) {
        return task.getWBSCode();
    }
});

/**

@class Gnt.column.Sequence
@extends Ext.grid.column.Column

A "calculated" column which displays the sequential position of the task in the project. 
See {@link Gnt.model.Task#getSequenceNumber} for details.


*/
Ext.define("Gnt.column.Sequence", {
    extend      : "Ext.grid.column.Column",
    alias       : "widget.sequencecolumn",
    mixins      : ['Gnt.mixin.Localizable'],

    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - text : '#'
     */

    /**
     * @cfg {Number} width The width of the column.
     */
    width       : 40,

    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align       : 'right',

    sortable    : false,
    dataIndex   : 'index',

    constructor : function (config) {
        config = config || {};

        this.text   = config.text || this.L('text');

        this.callParent(arguments);
    },

    renderer    : function (value, meta, task) {
        return task.getSequenceNumber();
    }
});

/**

@class Gnt.column.SchedulingMode
@extends Ext.grid.column.Column

A Column showing the `SchedulingMode` field of a task. The column is editable when adding a
`Sch.plugin.TreeCellEditing` plugin to your Gantt panel. The overall setup will look like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your static columns
        columns         : [
            ...
            {
                xtype       : 'schedulingmodecolumn',
                width       : 80
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })


*/
Ext.define("Gnt.column.SchedulingMode", {
    extend          : "Ext.grid.column.Column",

    requires        : ['Gnt.field.SchedulingMode'],
    mixins          : ['Gnt.mixin.Localizable'],

    alias           : "widget.schedulingmodecolumn",


    /**
     * @cfg {string} text The text to show in the column header, defaults to `Mode`
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - text : 'Mode'
     */

    /**
     * @cfg {Number} width The width of the column.
     */
    width           : 100,

    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align           : 'left',

    /**
     * @cfg {Array} data A 2-dimensional array used for editing in combobox. The first item of inner arrays will be treated as "value" and 2nd - as "display"
     */
    data            : null,

    /**
     * @cfg {Boolean} instantUpdate Set to `true` to instantly apply any changes in the field to the task.
     * This option is just translated to the {@link Gnt.field.mixin.TaskField#instantUpdate} config option.
     */
    instantUpdate   : false,

    field           : null,

    constructor : function (config) {
        config = config || {};        

        this.text   = config.text || this.L('text');

        // this will be a real field
        var field   = config.field || config.editor || new Gnt.field.SchedulingMode({
            store           : config.data || Gnt.field.SchedulingMode.prototype.store,
            instantUpdate   : this.instantUpdate
        });

        delete config.field;
        delete config.editor;

        if (!(field instanceof Gnt.field.SchedulingMode)) {
            // apply default instantUpdate state
            Ext.applyIf(field, {
                instantUpdate   : this.instantUpdate
            });

            field   = Ext.ComponentManager.create(field, 'schedulingmodefield');
        }

        config.field    = config.editor   = field;

        this.scope      = this;

        this.callParent([ config ]);
    },

    renderer : function (value, meta, task) {
        return this.field.valueToVisible(value, task);
    },

    afterRender: function() {
        this.callParent(arguments);

        var panel = this.up('treepanel');

        panel.on('beforeedit', function(ed, e) {
            if (this.field.setTask) {
                this.field.setTask(e.record);
            }
        }, this);

        if (!this.dataIndex) {
            this.dataIndex = panel.store.model.prototype.schedulingModeField;
        }
    }
});

/**
@class Gnt.column.AddNew
@extends Ext.grid.column.Column

Shows an extra column allowing the user to add a new column for any field in the data model.

*/
Ext.define("Gnt.column.AddNew", {
    extend      : "Ext.grid.column.Column",

    alias       : "widget.addnewcolumn",

    requires    : [
        'Ext.form.field.ComboBox',
        'Ext.Editor'
    ],

    mixins      : ['Gnt.mixin.Localizable'],

    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

        - text  : 'Add new column...'
     */

    width       : 100,
    resizable   : false,
    sortable    : false,
    draggable   : false,

    colEditor   : null,

    /**
     * @cfg {Array} [columnList] An array of column definition objects. It should be a list containing data as seen below
     *
     *      [
     *          { clsName : 'Gnt.column.StartDate', text : 'Start Date' },
     *          { clsName : 'Gnt.column.Duration', text : 'Duration' },
     *          ...
     *      ]
     *
     * If not provided, a list containing all the columns from the `Gnt.column.*` namespace will be created.
     */
    columnList  : null,

    initComponent : function() {
        if (!this.text) this.text = this.L('text');

        this.addCls('gnt-addnewcolumn');

        this.on({
            headerclick         : this.myOnHeaderClick,
            headertriggerclick  : this.myOnHeaderClick,
            scope               : this
        });

        this.callParent(arguments);
    },

    getGantt : function () {
        if (!this.gantt) {
            this.gantt = this.up('ganttpanel');
        }

        return this.gantt;
    },

    getContainingPanel : function() {
        if (!this.panel) {
            this.panel = this.up('tablepanel');
        }

        return this.panel;
    },

    myOnHeaderClick : function() {
        if (!this.combo) {
            var panel = this.getContainingPanel();
            var list,
                me = this;

            if (this.columnList) {
                list = this.columnList;
            } else {
                list = Ext.Array.map(Ext.ClassManager.getNamesByExpression('Gnt.column.*'), function(name) {
                    var cls = Ext.ClassManager.get(name);

                    if (cls.prototype._isGanttColumn === false || me instanceof cls) return null;

                    return {
                        clsName : name,
                        text    : cls.prototype.localize ? cls.prototype.localize('text') : cls.prototype.text
                    };
                });

                list = Ext.Array.clean(list).sort(function(a, b) { return a.text > b.text ? 1 : -1; });
            }

            var editor = this.colEditor = new Ext.Editor({
                shadow      : false,
                updateEl    : false,
                itemId      : 'addNewEditor',

                // HACK: we need this editor to exist in the column header for scrolling of the grid
                renderTo    : this.el,
                offsets     : [20, 0],
                field       : new Ext.form.field.ComboBox({
                    displayField    : 'text',
                    valueField      : 'clsName',
                    hideTrigger     : true,
                    queryMode       : 'local',
                    listConfig      : {
                        itemId      : 'addNewEditorComboList',
                        minWidth    : 150
                    },
                    store           : new Ext.data.Store({
                        fields  : ['text', 'clsName'],
                        data    : list
                    }),
                    listeners : {
                        render  : function() {
                            this.on('blur', function(){
                                editor.cancelEdit();
                            });
                        },
                        select  : this.onSelect,
                        scope   : this
                    }
                })
            });
        }
        var titleEl = this.el.down('.' + Ext.baseCSSPrefix + 'column-header-text');
        this.colEditor.startEdit(titleEl, '');
        this.colEditor.field.setWidth(this.getWidth() - 20);

        this.colEditor.field.expand();

        return false;
    },

    onSelect : function(combo, records) {
        var rec = records[0];
        var owner = this.ownerCt;
        var clsName = rec.get('clsName');
        var view = this.getContainingPanel().getView();
        var hasRefreshed,
            checkerFn = function() { hasRefreshed = true; };

        view.on('refresh', checkerFn);

        this.colEditor.cancelEdit();

        Ext.require(clsName, function() {
            var col = Ext.create(clsName);
            owner.insert(owner.items.indexOf(this), col);

            var gantt = this.getGantt();

            if (col instanceof Gnt.column.WBS) {
                if (!gantt.wbsColumn) {
                    gantt.wbsColumn = col;
                    gantt.bindAutoGeneratedListeners(gantt.wbsColumn);
                }
            } else if (col instanceof Gnt.column.Sequence) {
                if (!gantt.sequenceColumn) {
                    gantt.sequenceColumn = col;
                    gantt.bindAutoGeneratedListeners(gantt.sequenceColumn);
                }
            }
            else if (col instanceof Gnt.column.EarlyStartDate) gantt.earlyStartColumn = col;
            else if (col instanceof Gnt.column.EarlyEndDate) gantt.earlyEndColumn   = col;
            else if (col instanceof Gnt.column.LateStartDate) gantt.lateStartColumn = col;
            else if (col instanceof Gnt.column.LateEndDate) gantt.lateEndColumn     = col;
            else if (col instanceof Gnt.column.Slack) gantt.slackColumn = col;

            if (!gantt.slackListeners && gantt.slackColumn) {
                gantt.bindSlackListeners();
            }

            if (!gantt.earlyDatesListeners && (gantt.earlyStartColumn || gantt.earlyEndColumn)) {
                gantt.bindEarlyDatesListeners();
            }

            if (!gantt.lateDatesListeners && (gantt.lateStartColumn || gantt.lateEndColumn)) {
                gantt.bindLateDatesListeners();
            }

            // Ext 4.2.1- doesn't refresh on header insert, 4.2.2+ does
            if (!hasRefreshed) {
                view.refresh();
            }
            view.un('refresh', checkerFn);

        }, this);
    }
});

/**

@class Gnt.column.EarlyStartDate
@extends Ext.grid.column.Date

A Column displaying the earliest possible start date of a task.
This value is calculated based on earliest end dates of task's incoming dependencies.
If a task has no incoming dependencies then its start date is taken as earliest start date.

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your static columns
        columns         : [
            ...
            {
                xtype       : 'earlystartdatecolumn',
                width       : 80
            }
            ...
        ],
        ...
    })

Note, that this class inherit from [Ext.grid.column.Date](http://docs.sencha.com/ext-js/4-2/#!/api/Ext.grid.column.Date) and supports its configuration options, notably the "format".
*/
Ext.define('Gnt.column.EarlyStartDate', {
    extend              : 'Ext.grid.column.Date',

    mixins              : ['Gnt.mixin.Localizable'],

    alias               : 'widget.earlystartdatecolumn',

    /**
     * @cfg {Number} width The width of the column.
     */
    width               : 100,

    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align               : 'left',

    /**
     * @cfg {Boolean} adjustMilestones When set to `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*. The task model will still hold unmodified date.
     */
    adjustMilestones    : true,

    constructor : function (config) {
        config          = config || {};

        

        this.text   = config.text || this.L('text');

        this.callParent(arguments);

        this.renderer   = config.renderer || this.rendererFunc;
        this.scope      = config.scope || this;

        this.hasCustomRenderer = true;
    },

    afterRender : function() {
        var panel = this.up('ganttpanel');

        // Make top Gantt panel aware of the need for refreshing locked grid after changes in the dependency store
        panel.registerLockedDependencyListeners();

        this.callParent(arguments);
    },

    rendererFunc : function (value, meta, task) {
        meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';

        return task.getDisplayStartDate(this.format, this.adjustMilestones, task.getEarlyStartDate());
    }
});

/**

@class Gnt.column.EarlyEndDate
@extends Ext.grid.column.Date

A column displaying the earliest possible end date of a task.
This value is calculated based on the earliest end dates of the task predecessors.
If a task has no predecessors then its end date will be equal to its earliest end date.

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your static columns
        columns         : [
            ...
            {
                xtype       : 'earlyenddatecolumn',
                width       : 80
            }
            ...
        ],
        ...
    })

Note, that this class inherits from [Ext.grid.column.Date](http://docs.sencha.com/ext-js/4-2/#!/api/Ext.grid.column.Date) and supports its configuration options, notably the "format" option.
*/
Ext.define('Gnt.column.EarlyEndDate', {
    extend              : 'Ext.grid.column.Date',

    mixins              : ['Gnt.mixin.Localizable'],

    alias               : 'widget.earlyenddatecolumn',

    /**
     * @cfg {Number} width The width of the column.
     */
    width               : 100,

    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align               : 'left',

    /**
     * @cfg {Boolean} adjustMilestones When set to `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*. The task model will still hold the raw unmodified date.
     */
    adjustMilestones    : true,

    constructor : function (config) {
        config          = config || {};

        

        this.text   = config.text || this.L('text');

        this.callParent(arguments);

        this.renderer   = config.renderer || this.rendererFunc;
        this.scope      = config.scope || this;

        this.hasCustomRenderer = true;
    },

    afterRender : function() {
        var panel = this.up('ganttpanel');

        // Make top Gantt panel aware of the need for refreshing locked grid after changes in the dependency store
        panel.registerLockedDependencyListeners();

        this.callParent(arguments);
    },

    rendererFunc : function (value, meta, task) {
        meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';

        return task.getDisplayEndDate(this.format, this.adjustMilestones, task.getEarlyEndDate());
    }
});

/**

@class Gnt.column.LateStartDate
@extends Ext.grid.column.Date

A Column displaying the latest possible start date of a task.
This value is calculated based on latest start dates of task's outgoing dependencies.
If task has no successors then column value is calculated as project end date minus task duration
(_project end date_ is maximum end date of all task store records).

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your static columns
        columns         : [
            ...
            {
                xtype       : 'latestartdatecolumn',
                width       : 80
            }
            ...
        ],
        ...
    })

Note, that this class inherit from [Ext.grid.column.Date](http://docs.sencha.com/ext-js/4-2/#!/api/Ext.grid.column.Date) and supports its configuration options, notably the "format".
*/
Ext.define('Gnt.column.LateStartDate', {
    extend              : 'Ext.grid.column.Date',

    mixins              : ['Gnt.mixin.Localizable'],

    alias               : 'widget.latestartdatecolumn',

    /**
     * @cfg {Number} width The width of the column.
     */
    width               : 100,

    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align               : 'left',

    /**
     * @cfg {Boolean} adjustMilestones When set to `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*. The task model will still hold unmodified date.
     */
    adjustMilestones    : true,

    constructor : function (config) {
        config          = config || {};

        

        this.text   = config.text || this.L('text');

        this.callParent(arguments);

        this.renderer   = config.renderer || this.rendererFunc;
        this.scope      = config.scope || this;

        this.hasCustomRenderer = true;
    },

    afterRender : function() {
        var panel = this.up('ganttpanel');

        // Make top Gantt panel aware of the need for refreshing locked grid after changes in the dependency store
        panel.registerLockedDependencyListeners();

        this.callParent(arguments);
    },

    rendererFunc : function (value, meta, task) {
        meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';

        return task.getDisplayStartDate(this.format, this.adjustMilestones, task.getLateStartDate());
    }
});

/**

@class Gnt.column.LateEndDate
@extends Ext.grid.column.Date

A Column displaying the latest possible end date of a task.
This value is calculated based on the latest start dates of the task successors.
If task has no successors then project end date is taken as its latest end date.

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your static columns
        columns         : [
            ...
            {
                xtype       : 'lateenddatecolumn',
                width       : 80
            }
            ...
        ],
        ...
    })

Note, that this class inherit from [Ext.grid.column.Date](http://docs.sencha.com/ext-js/4-2/#!/api/Ext.grid.column.Date) and supports its configuration options, notably the "format".
*/
Ext.define('Gnt.column.LateEndDate', {
    extend              : 'Ext.grid.column.Date',

    mixins              : ['Gnt.mixin.Localizable'],

    alias               : 'widget.lateenddatecolumn',

    width               : 100,

    align               : 'left',

    /**
     * @cfg {Boolean} adjustMilestones When set to `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*. The task model will still hold the unmodified date.
     */
    adjustMilestones    : true,

    constructor : function (config) {
        config          = config || {};

        

        this.text   = config.text || this.L('text');

        this.callParent(arguments);

        this.renderer   = config.renderer || this.rendererFunc;
        this.scope      = config.scope || this;

        this.hasCustomRenderer = true;
    },

    afterRender : function() {
        var panel = this.up('ganttpanel');

        // Make top Gantt panel aware of the need for refreshing locked grid after changes in the dependency store
        panel.registerLockedDependencyListeners();

        this.callParent(arguments);
    },

    rendererFunc : function (value, meta, task) {
        meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';

        return task.getDisplayEndDate(this.format, this.adjustMilestones, task.getLateEndDate());
    }
});

/**

@class Gnt.column.Slack
@extends Ext.grid.column.Column

A column showing the available amount of slack for a task. The _slack_ (or _float_) is the amount of time that a task can be delayed
without causing a delay to any of its successors.

The slack is displayed in units specified by the {@link #slackUnit} config (by default it's displayed in _days_).


    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your grid columns
        columns         : [
            ...
            {
                xtype       : 'slackcolumn',
                width       : 70
            }
            ...
        ],
        ...
    })

*/
Ext.define('Gnt.column.Slack', {
    extend              : 'Ext.grid.column.Column',

    requires            : ['Ext.Number', 'Sch.util.Date'],

    mixins              : ['Gnt.mixin.Localizable'],

    alias               : 'widget.slackcolumn',

    /**
     * @cfg {Number} decimalPrecision A number of digits to show after the dot when rendering the value of the slack.
     */
    decimalPrecision    : 2,

    /**
     * @cfg {Boolean} useAbbreviation When set to `true`, the column will render the abbreviated slack unit name, not full.
     * Useful if the column width is limited.
     */
    useAbbreviation     : false,

    /**
     * @cfg {String} slackUnit The time unit to use when displaying the slack amount.
     */
    slackUnit           : 'd',

    width               : 100,

    align               : 'left',

    constructor : function (config) {
        config = config || {};

        this.text   = config.text || this.L('text');

        this.callParent(arguments);

        this.renderer   = config.renderer || this.rendererFunc;
        this.scope      = config.scope || this;

        this.hasCustomRenderer = true;
    },

    afterRender : function() {
        var panel = this.up('ganttpanel');

        // Make top Gantt panel aware of the need for refreshing locked grid after changes in the dependency store
        panel.registerLockedDependencyListeners();

        this.callParent(arguments);
    },

    rendererFunc : function (value, meta, task) {
        meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';

        value = task.getSlack();

        if (Ext.isNumber(value)) {
            return parseFloat(Ext.Number.toFixed(value, this.decimalPrecision)) + ' ' +
                Sch.util.Date[ this.useAbbreviation ? 'getShortNameOfUnit' : 'getReadableNameOfUnit' ](this.slackUnit, value !== 1);
        }

        return '';
    }
});

/**

@class Gnt.column.BaselineStartDate
@extends Ext.grid.column.Date

A Column displaying the baseline start date of a task.

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your static columns
        columns         : [
            ...
            {
                xtype       : 'baselinestartdatecolumn',
                width       : 80
            }
            ...
        ],
        ...
    })

Note, that this class inherit from [Ext.grid.column.Date](http://docs.sencha.com/ext-js/4-2/#!/api/Ext.grid.column.Date) and supports its configuration options, notably the "format" option.
*/
Ext.define('Gnt.column.BaselineStartDate', {
    extend              : 'Ext.grid.column.Date',

    mixins              : ['Gnt.mixin.Localizable'],

    alias               : 'widget.baselinestartdatecolumn',

    width               : 100,

    /**
     * @cfg {Boolean} adjustMilestones When set to `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*. The task model will still hold the unmodified date.
     */
    adjustMilestones    : true,

    constructor : function (config) {
        config          = config || {};

        this.text   = config.text || this.L('text');

        this.callParent(arguments);

        this.renderer   = config.renderer || this.rendererFunc;
        this.scope      = config.scope || this;

        this.hasCustomRenderer = true;
    },

    rendererFunc : function (value, meta, task) {
        meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';

        return task.getDisplayStartDate(this.format, this.adjustMilestones, task.getBaselineStartDate(), false, true);
    }
});

/**

@class Gnt.column.BaselineEndDate
@extends Ext.grid.column.Date

A Column displaying the baseline end date of a task.

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your static columns
        columns         : [
            ...
            {
                xtype       : 'baselineenddatecolumn',
                width       : 80
            }
            ...
        ],
        ...
    })

Note, that this class inherit from [Ext.grid.column.Date](http://docs.sencha.com/ext-js/4-2/#!/api/Ext.grid.column.Date) and supports its configuration options, notably the "format" option.
*/
Ext.define('Gnt.column.BaselineEndDate', {
    extend              : 'Ext.grid.column.Date',

    mixins              : ['Gnt.mixin.Localizable'],

    alias               : 'widget.baselineenddatecolumn',

    width               : 100,

    /**
     * @cfg {Boolean} adjustMilestones When set to `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*. The task model will still hold the unmodified date.
     */
    adjustMilestones    : true,

    constructor : function (config) {
        config          = config || {};

        this.text   = config.text || this.L('text');

        this.callParent(arguments);

        this.renderer   = config.renderer || this.rendererFunc;
        this.scope      = config.scope || this;

        this.hasCustomRenderer = true;
    },

    rendererFunc : function (value, meta, task) {
        meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';

        return task.getDisplayEndDate(this.format, this.adjustMilestones, task.getBaselineEndDate(), false, true);
    }
});

/**
 @class Gnt.column.Milestone
 @extends Ext.grid.column.Column

 A Column showing if a task is a milestone or not.

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your static columns
        columns         : [
            ...
            {
                xtype       : 'milestonecolumn',
                width       : 80
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    });


 */
Ext.define('Gnt.column.Milestone', {
    extend  : 'Ext.grid.column.Column',
    alias   : 'widget.milestonecolumn',

    mixins  : ['Gnt.mixin.Localizable'],

    width   : 50,
    align   : 'center',

    constructor : function (config) {
        config = config || {};

        config.editor = config.editor || new Gnt.field.Milestone();

        this.text = config.text || this.L('text');

        this.field = config.editor;

        this.callParent(arguments);

        this.scope = this;
    },

    renderer : function (value, meta, task) {
        return this.field.valueToVisible(task.isMilestone());
    }
});

/**
@class Gnt.widget.AssignmentEditGrid
@extends Ext.grid.Panel

A widget used to display and edit the task assignments.
You can find this widget at the `Resources` tab of {@link Gnt.widget.taskeditor.TaskEditor}.
There you can configure it through the {@link Gnt.widget.taskeditor.TaskEditor#assignmentGridConfig assignmentGridConfig} object
available both on the {@link Gnt.widget.taskeditor.TaskEditor} and on the {@link Gnt.plugin.TaskEditor} (if you use TaskEditor by plugin).

{@img gantt/images/assignment-edit-grid2.png}

{@img gantt/images/assignment-edit-grid1.png}

You can also use this grid in your components, standalone:

    // the task store of the project
    var taskStore           = myGanttPanel.taskStore

    var assignmentGrid      = new Gnt.widget.AssignmentEditGrid({
        assignmentStore         : taskStore.assignmentStore,
        resourceStore           : taskStore.resourceStore,

        addResources            : true,

        renderTo                : Ext.getBody(),

        width                   : 800,
        height                  : 600
    })

*/
Ext.define('Gnt.widget.AssignmentEditGrid', {
    extend      : 'Ext.grid.Panel',

    alias       : 'widget.assignmenteditgrid',

    requires    : [
        'Ext.window.MessageBox',
        'Ext.form.field.ComboBox',
        'Ext.grid.plugin.CellEditing',
        'Gnt.util.Data',
        'Gnt.model.Resource',
        'Gnt.model.Assignment',
        'Gnt.column.ResourceName',
        'Gnt.column.AssignmentUnits'
    ],

    mixins                  : ['Gnt.mixin.Localizable'],

    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore A store with assignments.
     */
    assignmentStore         : null,

    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore A store with resources.
     */
    resourceStore           : null,

    /**
     * @cfg {Boolean} readOnly Whether this grid is read only.
     */
    readOnly                : false,

    cls                     : 'gnt-assignmentgrid',

    /**
     * @cfg {Number} defaultAssignedUnits Default amount of units. This value applies for new assignments.
     */
    defaultAssignedUnits    : 100,

    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - confirmAddResourceTitle : 'Confirm',
            - confirmAddResourceText  : 'No resource &quot;{0}&quot; in storage yet. Would you like to add it?',
            - noValueText             : 'Please select resource to assign',
            - noResourceText          : 'No resource &quot;{0}&quot; in storage'
     */
    /**
     * @cfg {String} confirmAddResourceTitle A title for the confirmation window when a new resource is about to be added.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {Mixed} confirmAddResourceText A title for the confirmation window when a new resource is about to be added.
     * If you set this to `false`, no confirmation window will be displayed.
     * In this mode, for every "unknown" resource name entered into the combobox field, a new resource will be created.
     * @deprecated Please use {@link #confirmAddResource} and {@link #l10n} instead.
     */

    /**
     * @cfg {String} noValueText A text for the error message displayed when no resource is selected in the resource combobox.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} noResourceText A text for the error message displayed when an unknown resource name is entered in the resource combobox.
     * You can use "{0}" placeholder in this parameter. It will be replaced with the text entered in the combobox.
     * For example: 'Cannot find resource: &quot;{0}&quot;'.
     * @deprecated Please use {@link #l10n} instead.
     */

    /**
     * @cfg {Boolean} confirmAddResource False to not display a confirmation window before adding a new resource.
     */
    confirmAddResource      : true,

    /**
     * @cfg {Boolean} addResources `true` to enable in-place resource adding.
     */
    addResources            : true,

    /**
     * @property {String/Number} taskId Identifier of the task to which the assignments belong.
     */
    taskId                  : null,

    refreshTimeout          : 100,

    constructor : function (config) {

        Ext.apply(this, config);

        // backward compatibility: config.confirmAddResourceText may also contain False so we treat it like this:
        this.confirmAddResource = this.confirmAddResourceText !== false;

        // grid store ..we make it Gnt.data.AssignmentStore instance since
        // we need it could play this role in case we link grid with TaskForm.taskBuffer
        this.store = Ext.create('Gnt.data.AssignmentStore', {
            taskStore   : config.taskStore || config.assignmentStore.getTaskStore()
        });

        this.resourceDupStore = Ext.create('Gnt.data.ResourceStore', {
            taskStore   : config.taskStore || config.assignmentStore.getTaskStore()
        });

        // resource combo store
        this.resourceComboStore = Ext.create('Ext.data.JsonStore', {
            model   : Gnt.model.Resource
        });

        if (config.addResources !== undefined) {
            this.addResources = config.addResources;
        }

        this.columns        = this.buildColumns();

        if (!this.readOnly) {
            this.plugins = this.buildPlugins();
        }

        this.callParent(arguments);
    },

    initComponent : function() {
        this.loadResources();

        var refreshResources        = Ext.Function.createBuffered(this.loadResources, this.refreshTimeout, this, []);

        this.mon(this.resourceStore, {
            add         : refreshResources,
            remove      : refreshResources,
            load        : refreshResources,
            clear       : refreshResources
        });

        this.loadTaskAssignments();

        var refreshAssignments      = Ext.Function.createBuffered(this.loadTaskAssignments, this.refreshTimeout, this, []);

        this.mon(this.assignmentStore, {
            add         : refreshAssignments,
            remove      : refreshAssignments,
            load        : refreshAssignments,
            clear       : refreshAssignments
        });

        this.callParent(arguments);
    },


    loadResources : function (justResources) {
        if (!this.resourceStore) return false;

        // make a copy of resourceStore
        var data = Gnt.util.Data.cloneModelSet(this.resourceStore, function (copiedResource, srcResource) {
            // each record without Id will be referred by internalId
            if (!copiedResource.getId()) {
                // but we need to put it to Id field for combobox,
                // since combobox valueField is set to get values from Id
                copiedResource.setId(srcResource.getInternalId());
            }
        });

        this.resourceDupStore.loadData(data);

        // clone data to not affect real store
        this.resourceComboStore.loadData(data);

        // we reload assignments as well since they depend on resources list
        if (!justResources) {
            this.loadTaskAssignments();
        }

        return true;
    },


    /**
     * Loads task assignments from {@link #assignmentStore}.
     *
     * @param {Mixed} [taskId] The task id indicating which assignments to load.
     * If this parameter is not specified then it will use the identifier provided to this function before (if any).
     * **Note**, that if the task doesn't have an identifier yet (a 'phantom' record), you can use the task phantomId instead.
     *
     * @return {Boolean} False if {@link #assignmentStore} doesn't yet exist or if no task identifier has been provided.
     * Otherwise returns `true`.
     */
    loadTaskAssignments : function (taskId) {
        taskId  = taskId || this.taskId;

        if (!taskId) return false;

        if (!this.assignmentStore) return false;

        this.taskId = taskId;

        // grab assignments to this task only
        var taskAssignments = this.assignmentStore.queryBy(function(a) {
            return a.getTaskId() == taskId;
        });

        var store       = this.store,
            resStore    = this.resourceDupStore,
            // clone assignments to not affect real records
            data        = Gnt.util.Data.cloneModelSet(taskAssignments, function (copiedAssignment, srcAssignment) {
                // get original resource Id
                var resId       = srcAssignment.getResourceId();
                // get cloned version of that resource
                var clonedRes   = resStore.queryBy(function (resource) {
                    var r   = resource.originalRecord;
                    return (r.getId() || r.internalId) == resId;
                });
                if (clonedRes.getCount()) {
                    clonedRes   = clonedRes.first();
                    // and bind cloned resource to copy of assignment instead of real resource
                    copiedAssignment.setResourceId(clonedRes.getId() || clonedRes.internalId);
                }
            });

        // load data to the store
        store.suspendEvents();
        store.loadData(data);
        store.resumeEvents();

        this.getView().refresh();

        return true;
    },


    /**
     * Adds a new assignment record and starts the editor.
     *
     * @param {Gnt.model.Assignment/Object} [newRecord] The new assignment to be added.
     * If this parameter is not provided, a new record will be created using the TaskId of the current task,
     * empty ResourceId field and Units field set to {@link #defaultAssignedUnits} amount.
     * @param {Boolean} [doNotActivateEditor=False] `true` to just insert record without activating editor after insertion.
     *
     * @return {Gnt.model.Assignment[]} The records that were added.
     */
    insertAssignment : function (newRecord, doNotActivateEditor) {
        if (!this.store) return;

        var model   = this.store.model.prototype,
            newRec  = {};

        if (newRecord) {
            newRec = newRecord;
        } else {
            newRec[model.unitsField]    = this.defaultAssignedUnits;
        }

        newRec[model.taskIdField]       = this.taskId;

        var added   = this.store.insert(0, newRec);

        var me              = this,
            oldValidator    = added[0].isValid;

        added[0].isValid    = function () {
            return oldValidator.apply(this, arguments) && me.isValidAssignment(this);
        };

        if (!doNotActivateEditor) {
            this.cellEditing.startEditByPosition({ row : 0, column : 0 });
        }

        return added;
    },

    /**
     * Checks if the data in the grid store is valid.
     * @return {Boolean}
     */
    isValid : function () {
        var result  = true;
        this.store.each(function (record) {
            if (!record.isValid()) {
                result  = false;
                return false;
            }
        });
        return result;
    },

    /**
     * Returns an array of task assignment error messages.
     * @return {String[]} Array of error messages.
     */
    getAssignmentErrors : function (assignment) {
        var resourceId  = assignment.getResourceId();
        if (!resourceId) return [this.L('noValueText')];

        if (!this.resourceDupStore.getByInternalId(resourceId)) {
            return [Ext.String.format(this.L('noResourceText'), resourceId)];
        }
    },

    isValidAssignment : function (assignment) {
        return !this.getAssignmentErrors(assignment);
    },


    // @private
    buildPlugins : function() {
        var cellEditing = this.cellEditing = Ext.create('Ext.grid.plugin.CellEditing', {
            clicksToEdit : 1
        });

        var oldStartEdit = cellEditing.startEdit;

        cellEditing.startEdit = function() {
            this.completeEdit();

            return oldStartEdit.apply(this, arguments);
        };

        cellEditing.on({
            beforeedit  : this.onEditingStart,

            scope       : this
        });

        return [cellEditing];
    },

    hide : function() {
        this.cellEditing.cancelEdit();
        return this.callParent(arguments);
    },

    onEditingStart  : function (ed, e) {
        var model   = this.store.model.prototype;

        if (e.field == model.resourceIdField) {
            this.assignment = e.record;
            // keep resourceId of record being edited
            this.resourceId = e.record.getResourceId();

            this.resourceComboStore.loadData(this.resourceDupStore.getRange());

            // and re-apply filter to refresh dataset
            this.resourceComboStore.filter(this.resourcesFilter);
        }
    },

    resourceRender : function (value, meta, assignment) {
        var errors  = this.getAssignmentErrors(assignment);

        if (errors && errors.length) {
            meta.tdCls  = Ext.baseCSSPrefix + 'form-invalid';
            meta.tdAttr = 'data-errorqtip="'+errors.join('<br>')+'"';
        } else {
            meta.tdCls  = '';
            meta.tdAttr = 'data-errorqtip=""';
        }

        var record  = this.resourceDupStore.getByInternalId(value);
        return Ext.String.htmlEncode((record && record.getName()) || value);
    },

    // filters resources store to exclude resources that already assigned to the task.
    filterResources : function (resource) {
        var resourceId      = resource.getInternalId(),
            resourceField   = Gnt.model.Assignment.prototype.resourceIdField,
            show            = true;

        // record that is being edited should always be presented in combobox dataset
        if (resourceId !== this.resourceId) {
            // filter out already assigned resources
            this.store.each(function (assignment) {
                if (resourceId == assignment.get(resourceField)) {
                    show    = false;
                    return false;
                }
            });
        }

        return show;
    },

    onResourceComboAssert : function (combo) {
        var rawValue    = combo.getRawValue();

        if (rawValue) {

            var idx = this.resourceDupStore.findExact(combo.displayField, rawValue);

            var record  = idx !== -1 ? this.resourceDupStore.getAt(idx) : false;

            // if no matching record in store
            if (!record) {
                var assignment  = this.assignment;
                var me          = this;

                // callback to proceed with resource creation
                var addResource = function (deferred) {
                    var model       = Gnt.model.Resource.prototype,
                        newResource = {};

                    // let`s add a new record with such name
                    newResource[model.nameField]    = combo.rawValue;

                    newResource = Ext.ModelManager.create(newResource, Gnt.model.Resource);
                    // set resource Id equal to internalId
                    // we need filled Id to combobox proper working
                    newResource.setId(newResource.internalId);

                    // push to store
                    var added   = me.resourceDupStore.add(newResource);
                    if (added && added.length) {
                        if (!deferred) {
                            combo.getStore().add(newResource);
                            // and set combobox value
                            combo.setValue(added[0].getId());
                        } else {
                            assignment.setResourceId(added[0].getId());
                        }
                    }
                };

                // if confirmation required
                if (this.confirmAddResource) {
                    var text    = Ext.String.format(this.L('confirmAddResourceText'), Ext.String.htmlEncode(rawValue));

                    Ext.Msg.confirm(this.L('confirmAddResourceTitle'), text, function (buttonId) {
                        if (buttonId == 'yes') {
                            addResource(true);
                        }
                    });
                } else {
                    addResource();
                }
            } else {
                combo.select(record, true);
            }
        }
    },

    buildColumns : function() {
        var me  = this;

        // task name column editor
        this.resourceCombo  = new Ext.form.field.ComboBox({
            queryMode           : 'local',
            store               : this.resourceComboStore,
            allowBlank          : false,
            editing             : this.addResources,
            validateOnChange    : false,
            autoSelect          : false,
            forceSelection      : !this.addResources,
            valueField          : Gnt.model.Resource.prototype.idProperty,
            displayField        : Gnt.model.Resource.prototype.nameField,
            queryCaching        : false,
            listConfig          : {
                // HTML encode combobox items
                getInnerTpl : function () {
                    return '{' + this.displayField + ':htmlEncode}';
                }
            }
        });

        if (this.addResources) {
            this.resourcesFilter    = Ext.create('Ext.util.Filter', {
                filterFn    : this.filterResources,
                scope       : this
            });

            // add new resource record to combo store before assertValue call
            Ext.Function.interceptBefore(this.resourceCombo, 'assertValue', function () {
                me.onResourceComboAssert(this);
            });
        }

        return [
            {
                xtype           : 'resourcenamecolumn',
                editor          : this.resourceCombo,
                dataIndex       : Gnt.model.Assignment.prototype.resourceIdField,
                renderer        : this.resourceRender,
                scope           : this
            },
            {
                xtype           : 'assignmentunitscolumn',
                assignmentStore : this.assignmentStore,
                editor          : {
                    xtype   : 'percentfield',
                    step    : 10
                }
            }
        ];
    },


    saveResources : function () {
        Gnt.util.Data.applyCloneChanges(this.resourceDupStore, this.resourceStore);
    },


    /**
     * Persists task assignments to {@link #assignmentStore}.
     * @return {Boolean} `false` if saving error occures. Otherwise returns `true`.
     */
    saveTaskAssignments : function () {

        this.resourceStore.suspendEvents(true);
        this.assignmentStore.suspendEvents(true);

        // first we have to save resources in case of *new* resource assignment
        this.saveResources();

        var model       = this.store.model,
            comboStore  = this.resourceDupStore,
            result      = true;

        Gnt.util.Data.applyCloneChanges(this.store, this.assignmentStore, function (data) {
            // get assigned resource
            var resource    = comboStore.getByInternalId(this.getResourceId());
            // and its original record
            if (!resource.originalRecord) {
                // normally it should`t occur this way since we had to save resources at first
                result  = false;
                return;
            }
            var r   = resource.originalRecord;
            // now let's use real resource ID for saving
            data[model.prototype.resourceIdField] = r.getId() || r.internalId;
        });

        this.resourceStore.resumeEvents();
        this.assignmentStore.resumeEvents();

        return result;
    }
});

/**
@class Gnt.widget.DependencyGrid
@extends Ext.grid.Panel

A widget used to display and edit the dependencies of a task.
This widget is used as the `Predecessors` tab of the {@link Gnt.widget.taskeditor.TaskEditor}.
There you can configure it through the {@link Gnt.widget.taskeditor.TaskEditor#dependencyGridConfig dependencyGridConfig} object
available both on the {@link Gnt.widget.taskeditor.TaskEditor} and on the {@link Gnt.plugin.TaskEditor} classes.

{@img gantt/images/dependency-grid.png}

You can create an instance of the grid like this:

        dependencyGrid = Ext.create('Gnt.widget.DependencyGrid', {
            renderTo : Ext.getBody()
        });

To load data into the grid you can use the {@link #loadDependencies} method:

        // create grid
        dependencyGrid = Ext.create('Gnt.widget.DependencyGrid', {
            renderTo : Ext.getBody()
        });

        // load data
        dependencyGrid.loadDependencies(someTask);

* **Note:** If you plan to use this grid for tasks that don't belong to any taskStore you should specify a {@link #dependencyStore}:

        dependencyGrid = Ext.create('Gnt.widget.DependencyGrid', {
            renderTo        : Ext.getBody(),
            dependencyStore : dependencyStore
        });

Let's make our example more interesting by adding toolbar with buttons for editing:

        dependencyGrid = Ext.create('Gnt.widget.DependencyGrid', {
            renderTo        : Ext.getBody(),
            dependencyStore : dependencyStore,

            // toolbar with buttons
            tbar            : {
                items   : [
                    {
                        xtype       : 'button',
                        iconCls     : 'gnt-action-add',
                        text        : 'Add',
                        handler     : function() {
                            dependencyGrid.insertDependency();
                        }
                    },
                    {
                        xtype       : 'button',
                        iconCls     : 'gnt-action-remove',
                        text        : 'Remove',
                        handler     : function() {
                            var recs = dependencyGrid.getSelectionModel().getSelection();
                            if (recs && recs.length) {
                                dependencyGrid.store.remove(recs);
                            }
                        }
                    }
                ]
            }
        });

#Set grid direction

By default this grid displays predecessors of a task. To display successors instead, set the {@link #direction} config to 'successors'.
Example:

        dependencyGrid = Ext.create('Gnt.widget.DependencyGrid', {
            // set grid to display successors
            direction : 'successors'
        });

#Embedded checks

This class contains embedded transitivity and cycle detection algorithms. It runs them every time a new dependency is being added.
* **For example**: There is `Task A`->`Task B` and `Task B`->`Task C` dependencies.
In this case dependency `Task A`->`Task C` will be **transitive** and therefore will be considered as invalid.
And dependency `Task C`->`Task A` (or `Task B`->`Task A`) will form a **cycle** and will also be considered as invalid.

*/
Ext.define('Gnt.widget.DependencyGrid', {
    extend              : 'Ext.grid.Panel',
    alias               : 'widget.dependencygrid',

    requires            : [
        'Ext.data.JsonStore',
        'Ext.grid.plugin.CellEditing',
        'Ext.form.field.ComboBox',
        'Gnt.model.Dependency',
        'Gnt.util.Data',
        'Gnt.field.Duration'
    ],

    mixins              : ['Gnt.mixin.Localizable'],

    /**
     * @cfg {Boolean} readOnly Whether this grid is read only.
     */
    readOnly            : false,

    /**
     * @cfg {Boolean} showCls Whether to show the column for `Cls` field of the dependencies.
     */
    showCls             : false,

    cls                 : 'gnt-dependencygrid',

    task                : null,

    /**
     * @cfg {Gnt.data.DependencyStore} dependencyStore A store with dependencies.
     */
    dependencyStore     : null,

    taskModel           : null,

    /**
     * @property {String} direction The type of dependencies that are displayed in the grid. Either 'predecessors' or 'successors'.
     * @readonly
     * **Note:** You should use this property for *reading only*.
     */

    /**
     * @cfg {String} direction Defines what kind of dependencies will be displayed in a grid. Either 'predecessors' or 'successors'.
     */
    direction           : 'predecessors',

    oppositeStore       : null,

    taskStoreListeners  : null,

    refreshTimeout      : 100,

    /**
     * @cfg {Boolean} allowParentTaskDependencies Set to `true` to include parent tasks in the list of possible predecessors/successors.
     */
    allowParentTaskDependencies     : false,

    /**
     * @cfg {Object} l10n
     * A object, purposed for class localization. Contains the following keys/values:

        - idText                      : 'ID',
        - taskText                    : 'Task Name',
        - blankTaskText               : 'Please select task',
        - invalidDependencyText       : 'Invalid dependency',
        - parentChildDependencyText   : 'Dependency between child and parent found',
        - duplicatingDependencyText   : 'Duplicating dependency found',
        - transitiveDependencyText    : 'Transitive dependency',
        - cyclicDependencyText        : 'Cyclic dependency',
        - typeText                    : 'Type',
        - lagText                     : 'Lag',
        - clsText                     : 'CSS class',
        - endToStartText              : 'Finish-To-Start',
        - startToStartText            : 'Start-To-Start',
        - endToEndText                : 'Finish-To-Finish',
        - startToEndText              : 'Start-To-Finish'
     */
    /**
     * @cfg {String} idText The text to use for `ID` column header.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} taskText The text to use for `Task Name` column header.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} blankTaskText The error text to display if no task is selected.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} invalidDependencyText The error text to display if an invalid dependency is found.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} parentChildDependencyText The error text to display if a parent-child or child-parent dependency is found.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} duplicatingDependencyText The error text to display if there is more than one dependency found between two tasks.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} transitiveDependencyText The error text to display if a transitive dependency is found.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} cyclicDependencyText The error text to display if a cyclic dependency id found.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} typeText The text to use for `Type` column header.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} lagText The text to use for `Lag` column header
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} clsText The text to use for `CSS class` column header
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} endToStartText The text for `end-to-start` dependency type
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} startToStartText The text for `start-to-start` dependency type
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} endToEndText The text for `end-to-end` dependency type
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} startToEndText The text for `start-to-end` dependency type
     * @deprecated Please use {@link #l10n} instead.
     */

    constructor : function (config) {
        config = config || {};

        // HACK
        // fix for tooltip width
        // http://www.sencha.com/forum/showthread.php?260106-Tooltips-on-forms-and-grid-are-not-resizing-to-the-size-of-the-text
        if (Ext.getVersion('extjs').isLessThan('4.2.1')) {
            if (typeof Ext.tip !== 'undefined' && Ext.tip.Tip && Ext.tip.Tip.prototype.minWidth != 'auto') {
                Ext.tip.Tip.prototype.minWidth      = 'auto';
            }
        }

        // map locales from legacy configs
        Ext.Array.each(
            [
                'idText',
                'taskText',
                'blankTaskText',
                'invalidDependencyText',
                'parentChildDependencyText',
                'duplicatingDependencyText',
                'transitiveDependencyText',
                'cyclicDependencyText',
                'typeText',
                'lagText',
                'clsText',
                'endToStartText',
                'startToStartText',
                'endToEndText',
                'startToEndText'
            ],
            function (prop) {
                if (prop in config) this[prop] = config[prop];
            },
            this
        );


        this.store  = Ext.create('Ext.data.JsonStore', {
            model   : 'Gnt.model.Dependency'
        });

        if (!this.readOnly) {
            this.plugins    = this.buildPlugins();
        }

        this.direction = config.direction || this.direction;

        if (config.oppositeStore) {
            this.setOppositeStore(config.oppositeStore);
        }

        if (config.task) {
            this.loadDependencies(config.task);
        }

        this.callParent(arguments);
    },

    initComponent : function() {
        this.columns = this.buildColumns();

        this.callParent(arguments);
    },

    destroy : function () {
        this.cellEditing.destroy();

        if (this.deferredStoreBind) {
            this.tasksCombo.un('render', this.bindTaskStore, this);
        }
        this.tasksCombo.destroy();
        this.lagEditor.destroy();

        this.callParent(arguments);
    },


    setTask : function (task) {
        if (!task) return;

        this.task               = task;

        var dependencyStore     = task.dependencyStore || task.getTaskStore().dependencyStore;

        if (dependencyStore && dependencyStore !== this.dependencyStore) {
            this.dependencyStore    = dependencyStore;

            this.mon(this.dependencyStore, {
                datachanged : function () {
                    this.loadDependencies();
                },
                scope       : this
            });
        }

    },


    buildPlugins : function() {

        var cellEditing = this.cellEditing = Ext.create('Ext.grid.plugin.CellEditing', {
            clicksToEdit: 1
        });

        cellEditing.on({
            beforeedit  : this.onEditingStart,
            edit        : this.onEditingDone,

            scope   : this
        });

        return [cellEditing];
    },


    hide : function() {
        this.cellEditing.cancelEdit();
        this.callParent(arguments);
    },


    onEditingStart  : function (ed, e) {
        var model   = this.store.model.prototype;

        switch (e.field) {
            case model.lagField     : this.lagEditor.durationUnit = e.record.getLagUnit(); break;

            //case model.fromField    :
                //this.idValue    = this.direction === 'predecessors' ? e.record.getSourceId() : e.record.getTargetId();
                //break;
        }
    },


    onEditingDone : function (ed, e) {
        var model = this.store.model.prototype;

        if (e.field == model.lagField) {
            e.record.setLagUnit(this.lagEditor.durationUnit);
        }

        // after editing we refresh view since some records could become invalid
        this.getView().refresh();
    },

    // dependency type column renderer
    dependencyTypeRender : function (value) {
        var type  = this.store.model.Type;

        switch (value) {
            case type.EndToStart    : return this.L('endToStartText');
            case type.StartToStart  : return this.L('startToStartText');
            case type.EndToEnd      : return this.L('endToEndText');
            case type.StartToEnd    : return this.L('startToEndText');
        }

        return value;
    },


    // gets list of dependency errors, used at task column renderer
    taskValidate : function (value, depRec) {
        if (!value) {
            return [this.L('blankTaskText')];
        }
        if (!depRec.isValid()) {
            var errors  = this.getDependencyErrors(depRec);
            if (errors && errors.length) {
                return errors;
            }
            return [this.L('invalidDependencyText')];
        }
    },

    // task name column renderer
    taskRender : function (value, meta, depRec) {
        var errors  = this.taskValidate(value, depRec),
            record;

        if (errors && errors.length) {
            meta.tdCls  = Ext.baseCSSPrefix + 'form-invalid';
            meta.tdAttr = 'data-errorqtip="'+errors.join('<br>')+'"';
        } else {
            meta.tdCls  = '';
            meta.tdAttr = 'data-errorqtip=""';
        }

        var taskStore   = this.dependencyStore && this.dependencyStore.getTaskStore();
        if (taskStore) {
            record = taskStore.getById(value) || taskStore.getByInternalId(value);
            return (record && Ext.String.htmlEncode(record.getName())) || '';
        }

        return '';
    },


    filterTasks : function (record) {
        var me      = this,
            taskId  = record.getInternalId(),
            method;

        if (this.direction === 'predecessors') {
            method  = 'getSourceId';
        } else {
            method  = 'getTargetId';
        }

        // filter out task itself
        return taskId != this.task.getInternalId() &&
            // a links between a parent and its child
            !this.task.contains(record) && !record.contains(this.task) &&
            (this.allowParentTaskDependencies || record.isLeaf()) /*&&
            (!me.idValue ||
                ((taskId != me.idValue) &&
                    (this.store.findBy(function (dep) { return taskId == dep[method](); }) < 0)))*/;
    },


    bindTaskStore : function() {
        var taskStore   = this.dependencyStore && this.dependencyStore.getTaskStore();

        if (taskStore) {

            if (!this.taskStoreListeners) {
                // merge multiple refreshes to single one
                var refreshTasks    = Ext.Function.createBuffered(this.bindTaskStore, this.refreshTimeout, this, []);

                this.taskStoreListeners = this.mon(taskStore, {
                    append      : refreshTasks,
                    insert      : refreshTasks,
                    update      : refreshTasks,
                    remove      : refreshTasks,
                    refresh     : refreshTasks,
                    clear       : refreshTasks,
                    scope       : this,
                    destroyable : true
                });
            }

            // make new store
            var store   = Ext.create('Ext.data.JsonStore', {
                model   : taskStore.model
            });

            var root = taskStore.tree.getRootNode();

            // load tasks from tasks store
            store.loadData(Gnt.util.Data.cloneModelSet(taskStore.tree.flatten(), function (rec, src) {
                if (src === root) return false;
                // set phantomId as Id for records without Id
                // we need it since combo's valueField is 'Id'
                if (!src.getId()) {
                    rec.setId(src.getPhantomId());
                }
            }));

            this.tasksFilter    = Ext.create('Ext.util.Filter', {
                filterFn    : this.filterTasks,
                scope       : this
            });

            // and apply filter to it
            store.filter(this.tasksFilter);

            this.tasksCombo.bindStore(store);
        }
    },


    buildTasksCombo : function () {
        var me  = this;

        return Ext.create('Ext.form.field.ComboBox', {
            queryMode       : 'local',
            alowBlank       : false,
            editing         : false,
            forceSelection  : true,
            valueField      : this.taskModel.prototype.idProperty,
            displayField    : this.taskModel.prototype.nameField,
            queryCaching    : false,
            listConfig      : {
                // HTML encode combobox items
                getInnerTpl : function () {
                    return '{' + this.displayField + ':htmlEncode}';
                }
            },
            validator       : function (value) {
                if (!value) {
                    return me.L('blankTaskText');
                }

                return true;
            }
        });
    },


    buildColumns : function () {
        var me          = this,
            model       = this.store.model.prototype,
            depType     = this.store.model.Type,
            cols        = [],
            taskStore   = this.dependencyStore && this.dependencyStore.getTaskStore();

        // task name column editor
        this.tasksCombo = this.buildTasksCombo();

        // if no taskStore yet let`s defer its binding
        if (!taskStore) {
            this.deferredStoreBind = true;
            this.tasksCombo.on('render', this.bindTaskStore, this);
        // let`s build & bind combobox store
        } else {
            this.bindTaskStore();
        }

        if (this.direction === 'predecessors') {
            cols.push(
                {
                    text        : this.L('idText'),
                    dataIndex   : model.fromField,
                    width       : 50
                },
                {
                    text        : this.L('taskText'),
                    dataIndex   : model.fromField,
                    flex        : 1,
                    editor      : this.tasksCombo,
                    renderer    : function (value, meta, depRec) {
                        return me.taskRender(value, meta, depRec);
                    }
                }
            );
        } else {
            cols.push(
                {
                    text        : this.L('idText'),
                    dataIndex   : model.toField,
                    width       : 50
                },
                {
                    text        : this.L('taskText'),
                    dataIndex   : model.toField,
                    flex        : 1,
                    editor      : this.tasksCombo,
                    renderer    : function (value, meta, depRec) {
                        return me.taskRender(value, meta, depRec);
                    }
                }
            );
        }

        this.lagEditor = Ext.create('Gnt.field.Duration', {
            minValue : Number.NEGATIVE_INFINITY
        });

        cols.push(
            {
                text        : this.L('typeText'),
                dataIndex   : model.typeField,
                width       : 120,
                renderer    : function (value) {
                    return me.dependencyTypeRender(value);
                },
                editor      : {
                    xtype           : 'combo',
                    triggerAction   : 'all',
                    queryMode       : 'local',
                    editable        : false,
                    store           : [
                        [   depType.EndToStart,     this.L('endToStartText')     ],
                        [   depType.StartToStart,   this.L('startToStartText')   ],
                        [   depType.EndToEnd,       this.L('endToEndText')       ],
                        [   depType.StartToEnd,     this.L('startToEndText')     ]
                    ]
                }
            },
            {
                text        : this.L('lagText'),
                dataIndex   : model.lagField,
                width       : 100,
                editor      : this.lagEditor,
                renderer    : function(value, meta, record) {
                    var model = this.store.model.prototype;

                    return me.lagEditor.valueToVisible(value, record.get(model.lagUnitField), 2);
                }
            },
            {
                text        : this.L('clsText'),
                dataIndex   : model.clsField,
                hidden      : !this.showCls,
                width       : 100
            }
        );

        return cols;
    },


    /**
     * Creates new record and starts process of its editing.
     * @param {Gnt.model.Dependency/Object} [newRecord] New dependency to be added.
     * @param {Boolean} [doNotActivateEditor=false] `true` to just insert record without dependency editing after insertion.
     * @return {Gnt.model.Dependency[]} The records that were added.
     */
    insertDependency  : function (newRecord, doNotActivateEditor) {
        if (!this.store) return;

        var taskId  = this.task.getInternalId(),
            model   = this.store.model.prototype,
            newRec  = {},
            me      = this;

        if (newRecord) {
            newRec = newRecord;
        } else {
            newRec[model.typeField]     = this.store.model.Type.EndToStart;
            newRec[model.lagField]      = 0;
            newRec[model.lagUnitField]  = 'd';
        }

        if (this.direction === 'predecessors') {
            newRec[model.toField]   = taskId;
        } else {
            newRec[model.fromField] = taskId;
        }

        var added   = this.store.insert(0, newRec);
        // bind our validator
        if (added.length) {
            var oldValidator    = added[0].isValid;
            added[0].isValid    = function () {
                return oldValidator.call(this, false) && me.isValidDependency(this);
            };
        }

        if (!doNotActivateEditor) {
            this.cellEditing.startEditByPosition({ row : 0, column : 1 });
        }

        return added;
    },

    onOppositeStoreChange : function () {
        this.getView().refresh();
    },

    setOppositeStore : function (store) {

        // this can be made public after resolving the problem with transitivity detection
        //
        // Sets store with opposite to the grid dependencies direction.
        // This can be used for example to implement two grids one with predecessors and another one with successors of the task.
        // Grids will work in conjunction and validation of one grid will instantly react on changes made in another one.
        // @param {Ext.data.Store} store Store with dependencies.
        // @example
        //      var predecessorsGrid = Ext.create('Gnt.widget.DependencyGrid', {
        //          direction       : 'predecessors',
        //          dependencyStore : dependencyStore,
        //          task            : task
        //      });
        //
        //      var successorsGrid = Ext.create('Gnt.widget.DependencyGrid', {
        //          direction       : 'successors',
        //          dependencyStore : dependencyStore,
        //          // set predecessors grid store as opposite to successors
        //          oppositeStore   : predecessorsGrid.store,
        //          task            : task
        //      });
        //
        //      // set successors grid store as opposite to predecessors
        //      predecessorsGrid.setOppositeStore(successorsGrid.store);
        //

        if (this.oppositeStore) {
            this.oppositeStore.un('update', this.onOppositeStoreChange, this);
            this.oppositeStore.un('datachanged', this.onOppositeStoreChange, this);
        }

        this.oppositeStore = store;

        // on opposite store changes we will refresh grid view
        // since it can affect rows validity
        this.oppositeStore.on('update', this.onOppositeStoreChange, this);
        this.oppositeStore.on('datachanged', this.onOppositeStoreChange, this);
    },

    /**
     * Loads task dependencies to grid store.
     * @param {Gnt.model.Task} task Task dependencies of which should be loaded.
     */
    loadDependencies : function (task) {
        var me = this;

        task = task || this.task;

        if (!task) return;

        if (this.task !== task) {
            this.setTask(task);
        }

        var data;

        if (this.direction === 'predecessors') {
            data = task.getIncomingDependencies(true);
            if (!this.oppositeStore) {
                this.oppositeData   = task.getOutgoingDependencies(true);
            }
        } else {
            data = task.getOutgoingDependencies(true);
            if (!this.oppositeStore) {
                this.oppositeData   = task.getIncomingDependencies(true);
            }
        }

        // let`s clone it to not affect real data
        // we save changes only by saveDependencies() call
        var result  = Gnt.util.Data.cloneModelSet(data, function (rec) {
            // validate record by our own validator
            var oldValidator    = rec.isValid;
            rec.isValid         = function () {
                return oldValidator.call(this, false) && me.isValidDependency(this);
            };
        });

        this.store.loadData(result);
    },


    /*
     * Gets an array of error messages for provided dependency.
     */
    getDependencyErrors : function (dependency) {
        var me          = this,
            depStore    = this.dependencyStore,
            fromId      = this.task.getInternalId(),
            toId        = fromId,
            errors      = [],
            cyclicMethod,
            cyclicId;

        if (this.direction === 'predecessors') {
            fromId          = dependency.getSourceId();
            cyclicMethod    = 'getTargetId';
            cyclicId        = fromId;
        } else {
            toId            = dependency.getTargetId();
            cyclicMethod    = 'getSourceId';
            cyclicId        = toId;
        }

        var fromTask    = depStore.getSourceTask(fromId);
        var toTask      = depStore.getTargetTask(toId);

        // Not allowed to setup a link between a parent and its child
        if (fromTask && toTask && (fromTask.contains(toTask) || toTask.contains(fromTask))) {
            errors.push(this.L('parentChildDependencyText'));
        }

        var cycleFound;
        // let`s check for loops
        if (this.oppositeStore) {
            cycleFound = this.oppositeStore.findBy(function (dep) {
                var args = me.direction === 'predecessors' ? [ dep[cyclicMethod](), cyclicId ] : [ cyclicId, dep[cyclicMethod]() ];

                return dep[cyclicMethod]() == cyclicId || depStore.hasTransitiveDependency.apply(depStore, args);
            }) >= 0;
        } else {
            Ext.each(this.oppositeData, function (dep) {
                var args = me.direction === 'predecessors' ? [ dep[cyclicMethod](), cyclicId ] : [ cyclicId, dep[cyclicMethod]() ];

                if (dep[cyclicMethod]() == cyclicId || depStore.hasTransitiveDependency.apply(depStore, args)) {
                    cycleFound = true;
                    return false;
                }
            });
        }
        if (cycleFound) {
            errors.push(this.L('cyclicDependencyText'));
        }

        this.store.each(function (dep) {
            var sourceId    = dep.getSourceId(),
                targetId    = dep.getTargetId();
            // check duplicating records
            if ((fromId == sourceId) && (toId == targetId) && (dep !== dependency)) {
                errors.push(me.L('duplicatingDependencyText'));
                return false;
            }
            // check transitivity
            var args    = me.direction === 'predecessors' ? [ fromId, sourceId ] : [ targetId, toId ];
            if (depStore.hasTransitiveDependency.apply(depStore, args)) {
                errors.push(me.L('transitiveDependencyText'));
                return false;
            }
        });

        return errors;
    },


    /*
     * Checks if the dependency is valid.
     */
    isValidDependency : function (dependency) {
        var errors = this.getDependencyErrors(dependency);

        return !errors || !errors.length;
    },


    /*
     * Checks if the grid is valid.
     */
    isValid : function () {
        var result  = true;
        this.store.each(function (record) {
            if (!record.isValid()) {
                result  = false;
                return false;
            }
        });
        return result;
    },

    /**
     * Applies all changes that have been made to grid data to dependency store.
     */
    saveDependencies : function () {
        if (!this.isValid()) return;

        // push changes from grid store to real dependencyStore
        Gnt.util.Data.applyCloneChanges(this.store, this.dependencyStore);
    }

});

/**
@class Gnt.widget.taskeditor.TaskForm
@extends Ext.form.Panel

{@img gantt/images/taskeditor-form.png}

This form is used to edit the task properties.
By default it supports editing of the following fields:

 - the name of the task (task title)
 - the start date of the task
 - the end date of the task
 - the task duration
 - the task effort
 - the current status of a task, expressed as the percentage completed
 - the baseline start date of the task (editing of this field is optional)
 - the baseline end date of the task (editing of this field is optional)
 - the baseline status of a task, expressed as the percentage completed (editing of this field is optional)
 - the calendar assigned to task
 - the scheduling mode for the task

* **Note:** However this standard set of fields can be easily overwritten (for more details check {@link #items}).

## Extending the default field set

The default field set can be overwritten using the {@link #items} config.
In case you want to keep the default fields and add some new custom fields, you can use the code below:

    // Extend the standard TaskForm class
    Ext.define('MyTaskForm', {
        extend : 'Gnt.widget.taskeditor.TaskForm',

        constructor : function(config) {
            this.callParent(arguments);

            // add some custom field
            this.add({
                fieldLabel  : 'Foo',
                name        : 'Name',
                width       : 200
            });
        }
    });

    // create customized form
    var form = new MyTaskForm({...});

*/
Ext.define('Gnt.widget.taskeditor.TaskForm', {
    // This form by default contains various "standard" fields of the task
    // and it "knows" about their "applyChanges" methods (for our fields),
    // and about renamed field names
    // This form can be also used with any other set of fields, provided
    // as the "items" config

    extend                  : 'Ext.form.Panel',

    alias                   : 'widget.taskform',

    requires                : [
        'Gnt.model.Task',
        'Ext.form.FieldContainer',
        'Ext.form.field.Text',
        'Ext.form.field.Date',
        'Gnt.field.Percent',
        'Gnt.field.StartDate',
        'Gnt.field.EndDate',
        'Gnt.field.Duration',
        'Gnt.field.SchedulingMode',
        'Gnt.field.Effort'
    ],

    mixins                  : ['Gnt.mixin.Localizable'],

    alternateClassName      : ['Gnt.widget.TaskForm'],

    /**
     * @cfg {Gnt.model.Task} task A task to load to the form.
     */
    /**
     * @property {Gnt.model.Task} task A task loaded to the form.
     */
    task                    : null,
    /**
     * @cfg {Gnt.model.Task} taskBuffer A task used to keep intermediate values of fields implemented by {@link Gnt.field.mixin.TaskField} mixin.
     */
    /**
     * @property {Gnt.model.Task} taskBuffer A task used to keep intermediate values of fields implemented by {@link Gnt.field.mixin.TaskField} mixin.
     */
    taskBuffer              : null,
    /**
     * @cfg {Gnt.data.TaskStore} taskStore A store with tasks.
     *
     * **Note:** This is required option if task being loaded isn't yet belong to any task store.
     */
    taskStore               : null,

    /**
     * @cfg {Boolean} highlightTaskUpdates `true` to highlight fields updates initiated by changes of another fields.
     */
    highlightTaskUpdates    : true,

    /**
     * @cfg {Object/Object[]} items A single item, or an array of child Components to be added to this container.
     *
     * For example:
     *
        var myForm  = new Gnt.widget.taskeditor.TaskForm({
            items       : [
                {
                    xtype       : 'calendarfield',
                    fieldLabel  : 'Calendar',
                    name        : 'CalendarId'
                },
                {
                    xtype       : 'displayfield',
                    fieldLabel  : "WBS",
                    name        : 'wbsCode'
                }
            ],
            task        : myTask,
            taskStore   : myTaskStore
        });


     *
     * **Note:** By default this form provide pre-configured set of fields. Using this option will overwrite that field set.
     */

    /**
     * @cfg {Boolean} showBaseline `true` to display baseline fields.
     */
    showBaseline            : true,
    /**
     * @cfg {Boolean} editBaseline `true` to allow editing of baseline fields.
     */
    editBaseline            : false,
    /**
     * @cfg {Boolean} showCalendar `true` to show `Calendar` field.
     */
    showCalendar            : false,
    /**
     * @cfg {Boolean} showSchedulingMode `true` to show `Scheduling Mode` field.
     */
    showSchedulingMode      : false,

    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

        - taskNameText            : 'Name',
        - durationText            : 'Duration',
        - datesText               : 'Dates',
        - baselineText            : 'Baseline',
        - startText               : 'Start',
        - finishText              : 'Finish',
        - percentDoneText         : 'Percent Complete',
        - baselineStartText       : 'Start',
        - baselineFinishText      : 'Finish',
        - baselinePercentDoneText : 'Percent Complete',
        - effortText              : 'Effort',
        - invalidEffortText       : 'Invalid effort value',
        - calendarText            : 'Calendar',
        - schedulingModeText      : 'Scheduling Mode'
     */

    /**
     * @cfg {String} taskNameText A text for the `Name` field.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} durationText A text for the `Duration` field.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} datesText A text for the `Dates` fields container.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} baselineText A text for the `Baseline` fields container.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} startText A text for the `Start` field of the `Dates` fields container.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} finishText A text for the `Finish` field of the `Dates` fields container.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} percentDoneText A text for the `Percent Complete` field.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} baselineStartText A text for the `Start` field of the `Baseline` fields container.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} baselineFinishText A text for the `Finish` field of the `Baseline` fields container.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} baselinePercentDoneText A text for the `Percent Complete` field of the `Baseline` fields container.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} effortText A text for the `Effort` field.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} invalidEffortText A text for the error message when invalid effort value entered.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} calendarText A text for the `Calendar` field.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} schedulingModeText A text for the `Scheduling Mode` field.
     * @deprecated Please use {@link #l10n} instead.
     */

    /**
     * @cfg {Object} taskNameConfig A config object to be applied to the `Name` field.
     */
    taskNameConfig          : null,

    /**
     * @cfg {Object} durationConfig A config object to be applied to the `Duration` field.
     */
    durationConfig          : null,

    /**
     * @cfg {Object} startConfig A config object to be applied to the `Start` field.
     */
    startConfig             : null,

    /**
     * @cfg {Object} finishConfig A config object to be applied to the `Finish` field.
     */
    finishConfig            : null,

    /**
     * @cfg {Object} percentDoneConfig A config object to be applied to the `Percent Complete` field.
     */
    percentDoneConfig       : null,

    /**
     * @cfg {Object} baselineStartConfig A config object to be applied to the `Start` field of the `Baseline` fields container.
     */
    baselineStartConfig     : null,

    /**
     * @cfg {Object} baselineFinishConfig A config object to be applied to the `Finish` field of the `Baseline` fields container.
     */
    baselineFinishConfig    : null,

    /**
     * @cfg {Object} baselinePercentDoneConfig A config object to be applied to the `Percent Complete` field of the `Baseline` fields container.
     */
    baselinePercentDoneConfig   : null,

    /**
     * @cfg {Object} effortConfig A config object to be applied to the `Effort` field.
     */
    effortConfig            : null,

    /**
     * @cfg {Object} calendarConfig A config object to be applied to the `Calendar` field.
     */
    calendarConfig          : null,

    /**
     * @cfg {Object} schedulingModeConfig A config object to be applied to the `Scheduling Mode` field.
     */
    schedulingModeConfig    : null,

    constructor : function(config) {
        config = config || {};

        this.showBaseline = config.showBaseline;
        this.editBaseline = config.editBaseline;

        var model = Gnt.model.Task.prototype;

        // default field names
        this.fieldNames = {
            baselineEndDateField        : model.baselineEndDateField,
            baselinePercentDoneField    : model.baselinePercentDoneField,
            baselineStartDateField      : model.baselineStartDateField,
            calendarIdField             : model.calendarIdField,
            clsField                    : model.clsField,
            draggableField              : model.draggableField,
            durationField               : model.durationField,
            durationUnitField           : model.durationUnitField,
            effortField                 : model.effortField,
            effortUnitField             : model.effortUnitField,
            endDateField                : model.endDateField,
            manuallyScheduledField      : model.manuallyScheduledField,
            nameField                   : model.nameField,
            percentDoneField            : model.percentDoneField,
            resizableField              : model.resizableField,
            schedulingModeField         : model.schedulingModeField,
            startDateField              : model.startDateField,
            noteField                   : model.noteField
        };

        Ext.apply(this, config, {
            border      : false,
            layout      : 'anchor',
            defaultType : 'textfield'
        });

        // if task provided on construction step
        if (this.task) {
            // get actual field names from task
            this.fieldNames = this.getFieldNames(this.task);

            // if taskBuffer is not provided let`s make it
            this.taskBuffer = this.taskBuffer || this.task.copy();
        }

        // if no fields definition provided we make default fields set
        if (!this.items) {
            this.buildFields();
        }

        this.callParent(arguments);
    },


    getFieldNames : function (task) {
        if (!task) return;

        var result = {};

        for (var i in this.fieldNames) {
            result[i] = task[i];
        }

        return result;
    },


    // Renames form fields according to provided task model.
    renameFields : function (task) {
        var newFields   = this.getFieldNames(task);
        if (!newFields) return;

        var form    = this.getForm(),
            changed = false,
            field;

        for (var i in this.fieldNames) {
            field = form.findField(this.fieldNames[i]);

            // check if field name should be changed
            if (field && newFields[i] && newFields[i] != field.name) {
                changed     = true;
                field.name  = newFields[i];
            }
        }

        // if something was changed
        if (changed) {
            // keep new fields' names dictionary
            this.fieldNames = newFields;
        }
    },

    // Builds default set of form fields.
    buildFields : function () {
        var me      = this,
            f       = this.fieldNames,
            task    = this.task,
            store   = this.taskStore,
            beforeLabelTextTpl  = '<table class="gnt-fieldcontainer-label-wrap"><td width="1" class="gnt-fieldcontainer-label">',
            afterLabelTextTpl   = '<td><div class="gnt-fieldcontainer-separator"></div></table>';

        // shorten to get value from task
        var getVal = function (field) {
            return task ? task.get(f[field]) : '';
        };

        // shorthand to apply task, taskStore and highlightTaskUpdates to TaskField-s
        var applyCfg = function (definition, cfg) {

            var commonParams    = {
                taskStore               : me.taskStore,
                task                    : me.task,
                highlightTaskUpdates    : me.highlightTaskUpdates
            };

            // if field isn't already read only then let's take into account Task.isEditable() result
            if (!definition.readOnly && me.task) {
                commonParams.readOnly   = !me.task.isEditable(definition.name);
            }

            return Ext.apply(definition, commonParams, cfg);
        };

        this.items = this.items || [];

        this.items.push.call(this.items, {
            xtype       : 'fieldcontainer',
            layout      : 'hbox',
            defaults    : {
                allowBlank  : false
            },
            items       : [
                applyCfg({
                    xtype       : 'textfield',
                    fieldLabel  : this.L('taskNameText'),
                    name        : f.nameField,
                    labelWidth  : 110,
                    flex        : 1,
                    value       : getVal(f.nameField)
                }, this.taskNameConfig),
                applyCfg({
                    xtype       : 'durationfield',
                    fieldLabel  : this.L('durationText'),
                    name        : f.durationField,
                    margins     : '0 0 0 6',
                    labelWidth  : 90,
                    width       : 170,
                    value       : getVal(f.durationField)
                }, this.durationConfig)
            ]
        },
        applyCfg({
            xtype       : 'percentfield',
            fieldLabel  : this.L('percentDoneText'),
            name        : f.percentDoneField,
            labelWidth  : 110,
            width       : 200,
            allowBlank  : false,
            value       : getVal(f.percentDoneField)
        }, this.percentDoneConfig),
        {
            xtype               : 'fieldcontainer',
            fieldLabel          : this.L('datesText'),
            labelAlign          : 'top',
            labelSeparator      : '',
            beforeLabelTextTpl  : beforeLabelTextTpl,
            afterLabelTextTpl   : afterLabelTextTpl,
            layout              : 'hbox',
            defaults            : {
                labelWidth  : 110,
                flex        : 1,
                allowBlank  : false
            },
            items               : [
                applyCfg({
                    xtype       : 'startdatefield',
                    fieldLabel  : this.L('startText'),
                    name        : f.startDateField,
                    value       : getVal(f.startDateField)
                }, this.startConfig),
                applyCfg({
                    xtype       : 'enddatefield',
                    fieldLabel  : this.L('finishText'),
                    name        : f.endDateField,
                    margins     : '0 0 0 6',
                    value       : getVal(f.endDateField)
                }, this.finishConfig)
            ]
        },
        applyCfg({
            xtype       : 'effortfield',
            fieldLabel  : this.L('effortText'),
            name        : f.effortField,
            invalidText : this.L('invalidEffortText'),
            labelWidth  : 110,
            width       : 200,
            margins     : '0 0 0 6',
            allowBlank  : true,
            value       : getVal(f.effortField)
        }, this.effortConfig));

        if (this.showBaseline) {

            this.items.push.call(this.items, {
                xtype               : 'fieldcontainer',
                fieldLabel          : this.L('baselineText'),
                labelAlign          : 'top',
                labelSeparator      : '',
                beforeLabelTextTpl  : beforeLabelTextTpl,
                afterLabelTextTpl   : afterLabelTextTpl,
                layout              : 'hbox',
                defaultType         : 'datefield',
                defaults            : {
                    labelWidth  : 110,
                    flex        : 1,
                    cls         : 'gnt-baselinefield'
                },
                items               : [
                    applyCfg({
                        fieldLabel  : this.L('baselineStartText'),
                        name        : f.baselineStartDateField,
                        value       : getVal(f.baselineStartDateField),
                        readOnly    : !this.editBaseline
                    }, this.baselineStartConfig),
                    applyCfg({
                        fieldLabel  : this.L('baselineFinishText'),
                        name        : f.baselineEndDateField,
                        margins     : '0 0 0 6',
                        value       : getVal(f.baselineEndDateField),
                        readOnly    : !this.editBaseline
                    }, this.baselineFinishConfig)
                ]
            },
            applyCfg({
                xtype       : 'percentfield',
                fieldLabel  : this.L('baselinePercentDoneText'),
                name        : f.baselinePercentDoneField,
                labelWidth  : 110,
                width       : 200,
                cls         : 'gnt-baselinefield',
                value       : getVal(f.baselinePercentDoneField),
                readOnly    : !this.editBaseline
            }, this.baselinePercentDoneConfig));

        }

        if (this.showCalendar) {
            this.items.push(applyCfg({
                xtype       : 'calendarfield',
                fieldLabel  : this.L('calendarText'),
                name        : f.calendarIdField,
                value       : getVal(f.calendarIdField)
            }, this.calendarConfig));
        }

        if (this.showSchedulingMode) {
            this.items.push(applyCfg({
                xtype       : 'schedulingmodefield',
                fieldLabel  : this.L('schedulingModeText'),
                name        : f.schedulingModeField,
                value       : getVal(f.schedulingModeField),
                allowBlank  : false
            }, this.schedulingModeConfig));
        }
    },

    /**
     * Suppress task updates invoking by form fields. Calls setSuppressTaskUpdate() of each field that supports this method.
     * @param {Boolean} state Suppress or allow task updating.
     */
    setSuppressTaskUpdate : function (state) {
        var fields  = this.getForm().getFields();

        fields.each(function (field) {
            // if field contains setTask() method
            field.setSuppressTaskUpdate && field.setSuppressTaskUpdate(state);
        });
    },

    /**
     * Loads an Gnt.model.Task into this form.
     * @param {Gnt.model.Task} task The record to edit.
     * @param {Gnt.model.Task} [taskBuffer] The record to be used as a buffer to keep changed values of fields which implement {@link Gnt.field.mixin.TaskField}
     * mixin interface. This parameter can be used in case when you want to implement two form instances instantly
     * reflecting changes of each other:
     *
     *      // create 1st TaskForm instance
     *      var taskForm = Ext.create('Gnt.widget.taskeditor.TaskForm');
     *      // load record into 1st form
     *      taskForm.loadRecord(someTask);
     *
     *      // create 2nd TaskForm instance
     *      var anotherForm = Ext.create('Gnt.widget.taskeditor.TaskForm');
     *      // load the same record into 2nd form
     *      // and set to share taskBuffer with 1st form to immediately refect changes of each other
     *      anotherForm.loadRecord(someTask, taskForm.taskBuffer);
     */
    loadRecord : function (task, taskBuffer) {

        // if new or another task loading
        if (task && task !== this.task) {
            // let's rename form fields according to task model
            this.renameFields(task);
        }

        this.task       = task;
        this.taskBuffer = taskBuffer;

        // if no pre-created taskBuffer provided, let`s create it
        if (!this.taskBuffer) {
            this.taskBuffer             = task.copy();
            // since copy() doesn't copy taskStore let`s copy it ourself
            this.taskBuffer.taskStore   = task.taskStore;
        }

        var me      = this,
            form    = me.getForm();

        // following code is modified implementation
        // of Ext.form.Basic setValues() method
        form._record  = task;

        Ext.suspendLayouts();

        Ext.iterate(task.getData(), function (fieldId, val) {
            var field = form.findField(fieldId);
            if (field) {
                // if field contains setTask() method
                // we gonna use it since setTask() execute setValue()
                if (field.setTask) {
                    // let's suppress task updating on initial
                    // values loading during parent's loadRecord() call
                    field.setSuppressTaskUpdate(true);
                    field.setTask(me.taskBuffer);
                    field.setSuppressTaskUpdate(false);
                } else {
                    field.setValue(val);

                    // let's take into account Task.isEditable() result
                    field.setReadOnly(!me.taskBuffer.isEditable(field.name));
                }

                if (form.trackResetOnLoad) {
                    field.resetOriginalValue();
                }
            }
        });

        Ext.resumeLayouts(true);

        this.fireEvent('afterloadrecord', this, task);
    },

    /**
     * Applies the values from this form into the passed {@link Gnt.model.Task} object.
     * If the task is not specified, it will attempt to update (if it exists) the record provided to {@link #loadRecord}.
     * @param {Gnt.model.Task} [task] The record to apply change to.
     */
    updateRecord : function (task) {
        task = task || this.task;

        var cont    = Ext.Function.bind(function () {

            this.setSuppressTaskUpdate(true);

            var fields  = this.getForm().getFields();

            task.beginEdit();

            fields.each(function (field) {
                // if field contains applyChanges() method
                // we gonna use it to apply changes to task
                if (field.applyChanges) {
                    field.applyChanges(task);
                } else {
                    var modelField  = task.fields.getByKey(field.name);

                    if (modelField && modelField.persist) task.set(field.name, field.getValue());
                }

            });

            task.endEdit();

            this.setSuppressTaskUpdate(false);

            this.fireEvent('afterupdaterecord', this, task);
        }, this);

        if (task && this.fireEvent('beforeupdaterecord', this, task, cont) !== false) {
            cont();

            return true;
        }

        return false;
    }

});

/**
@class Gnt.widget.taskeditor.TaskEditor
@extends Ext.panel.Panel

A widget used to display and edit task information.
By default the widget contains an Ext.tab.Panel which can contain the following tabs:

 - General information
 - Predecessors
 - Resources
 - Advanced
 - Notes

You can easily add new custom tabs using {@link #tabsConfig} config.

# General

{@img gantt/images/taskeditor-panel-general.png}

Contains a customizable {@link Gnt.widget.TaskForm form} instance for viewing and editing the following task data:

 - the name of the task
 - the start date of the task
 - the end date of the task
 - the task duration
 - the task effort
 - the current status of a task, expressed as the percentage completed
 - the baseline start date of the task (editing of this field is optional)
 - the baseline end date of the task (editing of this field is optional)
 - the baseline status of a task, expressed as the percentage completed (editing of this field is optional)

### Task form customization

There is a {@link #taskFormConfig} config which can be used to customize the form panel.

        Ext.create('Gnt.widget.taskeditor.TaskEditor', {
            // Configure the form located in the "General" tab
            taskFormConfig : {
                // turn off fields highlighting
                highlightTaskUpdates : false,
                // alter panel margin
                margin : 20
            }
        });

### Fields configuration

The {@link Gnt.widget.TaskForm} class has a config for each field presented at the `General` tab.
And using {@link #taskFormConfig} we can get access for those options to setup fields.
For example:

        Ext.create('Gnt.widget.taskeditor.TaskEditor', {
            // setup form located at "General" tab
            taskFormConfig : {
                // set Baseline Finish Date field invisible
                baselineFinishConfig : {
                    hidden : true
                }
            }
        });

Here are some more configs for other fields:

 - {@link Gnt.widget.TaskForm#taskNameConfig taskNameConfig} (the name of the task field)
 - {@link Gnt.widget.TaskForm#startConfig startConfig} (the start date of the task field)
 - {@link Gnt.widget.TaskForm#finishConfig finishConfig} (the end date of the task field)
 - {@link Gnt.widget.TaskForm#durationConfig durationConfig} (the task duration field)

Please see {@link Gnt.widget.TaskForm} class to see the full list of available config options.

### Extending the General field set

If you want to add a new field to the `General` tab you will have to extend the {@link Gnt.widget.TaskForm TaskForm} class.
After that you will need to configure the task editor to use your extended class:

        // extend standard TaskForm class
        Ext.define('MyTaskForm', {
            extend : 'Gnt.widget.taskeditor.TaskForm',

            constructor : function(config) {
                this.callParent(arguments);

                // add some custom field
                this.add({
                    fieldLabel  : 'Foo',
                    name        : 'Name',
                    width       : 200
                });
            }
        });

        // Let task editor know which class to use
        Ext.create('Gnt.widget.taskeditor.TaskEditor', {
            // to use MyTaskForm to build the "General" tab
            taskFormClass : 'MyTaskForm'
        });

#Predecessors

Contains a {@link Gnt.widget.DependencyGrid grid} instance displaying the predecessors for the task.
You can add, edit or remove dependencies of the task using this panel.

{@img gantt/images/taskeditor-panel-predecessors.png}

You can enable/disable this tab by setting the {@link #showDependencyGrid} option.
To rename this tab you can use `dependencyText` property of {@link #l10n} config.
Customizing the grid itself can be done via the {@link #dependencyGridConfig} config.
To change make this tab display successors instead of predecessors - use the following code:

        Ext.create('Gnt.widget.taskeditor.TaskEditor', {
            l10n : {
                // here we change tab title
                dependencyText : 'Successors'
            },
            // here is the grid config
            dependencyGridConfig : {
                // set grid to display successors
                direction : 'successors'
            }
        });

### Customizing dependency grid class

You can also configure the task editor to use a custom class to build this tab using the {@link #dependencyGridClass} option.
If you need to add an extra column to the grid, you can do it like this:

        // extend standard DependencyGrid
        Ext.define('MyDependencyGrid', {
            extend: 'Gnt.widget.DependencyGrid',

            // extend buildColumns method to append extra column
            buildColumns : function () {
                // add custom column as last one
                return this.callParent(arguments).concat({
                    header    : 'Foo',
                    dataIndex : 'foo',
                    width     : 100
                });
            }
        });

        // setup task editor
        Ext.create('Gnt.widget.taskeditor.TaskEditor', {
            // to use extended class to build tab
            dependencyGridClass : 'MyDependencyGrid'
        });

#Resources

Contains a {@link Gnt.widget.AssignmentEditGrid grid} instance displaying the task assignments.
It allows you to add, edit or remove task assignments.

{@img gantt/images/taskeditor-panel-resources2.png}

It also supports inline resource adding (for more details, take a look at the {@link Gnt.widget.AssignmentEditGrid#addResources} config.

{@img gantt/images/taskeditor-panel-resources1.png}

You can enable/disable this tab by setting the {@link #showAssignmentGrid} option.
To rename this tab you can use the `resourcesText` property of {@link #l10n} config.
Customizing the grid can be done via the {@link #assignmentGridConfig} config.

Example:

        Ext.create('Gnt.widget.taskeditor.TaskEditor', {
            l10n : {
                // rename tab
                resourcesText : 'Assignments'
            },
            // here is grid the config
            assignmentGridConfig : {
                // disable in-place resources adding
                addResources : false
            }
        });

### Customizing assignment grid class

You can use a custom grid class for this tab by using the {@link #assignmentGridClass} option.
For example if you need to add extra column to the grid you can do it like this:

        // Extend the standard AssignmentGrid
        Ext.define('MyAssignmentGrid', {
            extend: 'Gnt.widget.AssignmentEditGrid',

            // extend buildColumns method to append extra column
            buildColumns : function () {
                // add custom column as last one
                return this.callParent(arguments).concat({
                    header       : 'Foo',
                    dataIndex    : 'foo',
                    width        : 100
                });
            }
        });

        // setup task editor
        Ext.create('Gnt.widget.taskeditor.TaskEditor', {
            // use extended class
            assignmentGridClass : 'MyAssignmentGrid'
        });

#Advanced

Contains a {@link Gnt.widget.TaskForm form} instance which can be customized, allowing the user to view and edit the following task data:

 - the calendar assigned to the task
 - the scheduling mode for the task

{@img gantt/images/taskeditor-panel-advanced.png}

You can enable/disable this tab by setting the {@link #showAdvancedForm} option.
To rename this tab you can use the `advancedText` property of {@link #l10n} config.

Customizing the form itself can be done via the {@link #advancedFormConfig} config. For example this is how form content can be overwritten:

        Ext.create("Gnt.widget.taskeditor.TaskEditor", {
            advancedFormConfig: {
                items: [
                     // new fields that will go here
                     // will replace standard presented in the "Advanced" tab
                     ...
                ]
            }
        });

### Customizing the form class

You can use your own custom class to build this tab by using the {@link #advancedFormClass} config:
For example if you need to add some extra field you can do it like this:

        // Extend standard TaskForm class
        Ext.define('MyAdvancedForm', {
            extend : 'Gnt.widget.taskeditor.TaskForm',

            constructor : function(config) {
                this.callParent(arguments);

                // add some custom field
                this.add({
                    fieldLabel  : 'Foo',
                    name        : 'Name',
                    width       : 200
                });
            }
        });

        // setup task editor
        Ext.create("Gnt.widget.taskeditor.TaskEditor", {
            // to use new class to build the "Advanced" tab
            advancedFormClass: 'MyAdvancedForm',
        });

#Notes

Contains an {@link Ext.form.field.HtmlEditor HTML editor instance} for viewing and editing a freetext note about the task.

{@img gantt/images/taskeditor-panel-notes.png}

You can enable/disable this tab by setting the {@link #showNotes} option.
To rename this tab you can use the `notesText` property of {@link #l10n} config.
Customizing the grid itself can be done via the {@link #notesConfig} config.

*/
Ext.define('Gnt.widget.taskeditor.TaskEditor', {

    extend                  : 'Ext.panel.Panel',

    alias                   : 'widget.taskeditor',

    requires                : [
        'Ext.tab.Panel',
        'Ext.form.Panel',
        'Gnt.widget.taskeditor.TaskForm',
        'Gnt.widget.AssignmentEditGrid',
        'Gnt.widget.DependencyGrid',
        'Gnt.field.Calendar',
        'Gnt.field.SchedulingMode',
        'Ext.form.field.HtmlEditor'
    ],

    mixins                  : ['Gnt.mixin.Localizable'],
    margin                  : '5 0 0 0',
    alternateClassName      : ['Gnt.widget.TaskEditor'],

    /**
     * @event loadtask
     * Fires after task has been loaded into the editor.
     * @param {Gnt.widget.taskeditor.TaskEditor} taskEditor The task editor widget instance.
     * @param {Gnt.model.Task} task The task.
     *
     * This event can be used to do additional data loading if task editor was extended with some extra fields.
     * Also please take a look at {@link #afterupdatetask} event to have an example of how to implement custom data saving.
     *
     *      // some custom user form
     *      var customForm = new Gnt.widget.taskeditor.TaskForm({
     *          title : 'Custom form panel',
     *          xtype : 'taskform',
     *          items : [
     *              {
     *                  fieldLabel  : 'Foo field',
     *                  name        : 'foo',
     *                  allowBlank  : false
     *              }
     *          ],
     *          taskStore   : taskStore
     *      });
     *
     *      var taskEditor = Ext.create('Gnt.plugin.TaskEditor', {
     *          tabsConfig: {
     *              // register custom form as an additional tab
     *              items: customForm
     *          },
     *          listeners   : {
     *              // populate custom form with task values
     *              loadtask : function (taskeditor, task) {
     *                  customForm.loadRecord(task);
     *              },
     *              ....
     *          }
     *      });
     */

    /**
     * @event beforeupdatetask
     * Fires before task updating occurs. Return `false` to prevent the update.
     * @param {Gnt.widget.taskeditor.TaskEditor} taskEditor The task editor widget instance.
     * @param {Function} proceedCallback The function which can be called manually to continue task updating. Example:
     *
     *      var taskEditor = Ext.create('Gnt.widget.taskeditor.TaskEditor', {
     *          listeners   : {
     *              beforeupdatetask    : function (taskeditor, proceedCallback) {
     *                  var me  = this;
     *                  Ext.MessageBox.confirm('Confirm', 'Are you sure you want to do that?', function (buttonId) {
     *                      if (buttonId == 'yes') {
     *                          // here we continue updating asynchronously after user click "Yes" button
     *                          proceedCallback();
     *                          me.hide();
     *                      }
     *                  });
     *                  // here we return false to stop updating
     *                  return false;
     *              }
     *          }
     *      });
     *
     */

    /**
     * @event afterupdatetask
     * Fires after a task has been updated.
     * @param {Gnt.widget.taskeditor.TaskEditor} taskEditor The task editor instance.
     *
     * This event can be used to do some extra processing after task was updated by task editor.
     * For example in case when you have some additional fields you can implement saving of them using this event.
     * Also please take a look at {@link #loadtask} event to have an example of how to implement custom data loading.
     *
     *      // some custom user form
     *      var customForm = new Gnt.widget.taskeditor.TaskForm({
     *          title : 'Custom form panel',
     *          xtype : 'taskform',
     *          items : [
     *              {
     *                  fieldLabel  : 'Foo field',
     *                  // foo - is the name of custom task field
     *                  name        : 'foo',
     *                  allowBlank  : false
     *              }
     *          ],
     *          taskStore   : taskStore
     *      });
     *
     *      var taskEditor = Ext.create('Gnt.plugin.TaskEditor', {
     *          tabsConfig: {
     *              // register custom form as an additional tab
     *              items: customForm
     *          },
     *          listeners   : {
     *              afterupdatetask : function (taskeditor) {
     *                  // update form fields to loaded task
     *                  customForm.updateRecord();
     *              },
     *              ....
     *          }
     *      });
     */

    /**
     * @event validate
     * Fires when task validating occurs.
     * @param {Gnt.widget.taskeditor.TaskEditor} taskEditor The task editor instance.
     * @param {Ext.Component} tabToFocus The tab panel item where one or more invalid fields was detected.
     *
     * Fires during a {@link #method-validate} method call when task validation occurs.
     * Return `false` to make the validation fail, but take care of marking invalid component somehow (to let user know of error)
     * since normally invalid components are being highlighted during validate call.
     * For example:
     *
     *      var taskEditor = Ext.create('Gnt.widget.taskeditor.TaskEditor', {
     *          tabsConfig: {
     *              items: [{
     *                  title : "Some custom tab",
     *                  items: [{
     *                      xtype: 'textfield',
     *                      fieldLabel  : 'Enter your name',
     *                      id: 'enter-your-name',
     *                      allowBlank: false,
     *                      blankText: 'Please enter your name'
     *                  }]
     *              }]
     *          },
     *          listeners   : {
     *              validate    : function (taskeditor, tabToFocus) {
     *                  var field = taskeditor.down('#enter-your-name');
     *                  // if validation of our field failed
     *                  if (!field.isValid()) {
     *                      // if no other tabs with some invalid control
     *                      if (!tabToFocus) {
     *                          var activeTab = taskeditor.getActiveTab();
     *                          // if our field is not placed at currently active tab
     *                          if (!field.isDescendantOf(activeTab)) {
     *                              // then we'll switch to tab where our field resides
     *                              taskeditor.setActiveTab(taskeditor.getTabByComponent(field));
     *                          }
     *                      }
     *                      // return false since validation failed
     *                      return false;
     *                  }
     *              }
     *          }
     *      });
     *
     */

    /**
     * @cfg {Gnt.model.Task} task The task to edit.
     */
    task                    : null,

    /**
     * @cfg {Gnt.data.TaskStore} taskStore A store with tasks.
     *
     * **Note:** This is a required option if the task being edited doesn't belong to any task store.
     */
    taskStore               : null,

    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore A store with assignments.
     *
     * **Note:** It has to be provided to show the `Resources` tab (See also {@link #resourceStore}).
     */
    assignmentStore         : null,

    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore A store with resources.
     *
     * **Note:** It has to be provided to show the `Resources` tab (See also {@link #assignmentStore}).
     */
    resourceStore           : null,

    /**
     * @cfg {String} taskFormClass Class representing the form in the `General` tab.
     *
     * This option supposed to be used to implement a custom form in the `General` tab content.
     */
    taskFormClass           : 'Gnt.widget.taskeditor.TaskForm',

    /**
     * @cfg {String} advancedFormClass Class representing the form in the `Advanced` tab.
     *
     * This option supposed to be used to implement a custom form in the `Advanced` tab content.
     */
    advancedFormClass       : 'Gnt.widget.taskeditor.TaskForm',

    /**
     * @cfg {Boolean} showAssignmentGrid `true` to display a `Resources` tab.
     */
    showAssignmentGrid      : true,

    /**
     * @cfg {Boolean} showDependencyGrid `true` to display a `Predecessors` tab.
     */
    showDependencyGrid      : true,

    /**
     * @cfg {Boolean} allowParentTaskDependencies `true` to display a `Predecessors` tab for parent tasks
     * (requires {@link #showDependencyGrid} to be `true` as well) and also include parent tasks in the list
     * of possible predecessors.
     */
    allowParentTaskDependencies     : false,

    /**
     * @cfg {Boolean} showNotes `true` to display a `Notes` tab.
     */
    showNotes               : true,

    showStyle               : true,

    /**
     * @cfg {Boolean} showAdvancedForm `true` to display an `Advanced` tab.
     */
    showAdvancedForm        : true,

    /**
     * @cfg {Boolean} showBaseline `true` to display baseline fields in the `General` tab.
     */
    showBaseline            : true,

    /**
     * @cfg {Object} tabsConfig TabPanel configuration. Any Ext.tab.Panel options can be used.
     *
     * Also you can append custom tabs after standard ones, using `items` config:
     *
     *      var taskEditor = Ext.create('Gnt.widget.taskeditor.TaskEditor', {
     *          tabsConfig: {
     *              items: [{
     *                  title : "Some custom tab",
     *                  items: [{
     *                      xtype: 'textfield',
     *                      fieldLabel  : 'Enter your name',
     *                      id: 'enter-your-name',
     *                      allowBlank: false,
     *                      blankText: 'Please enter your name'
     *                  }]
     *              }]
     *          }
     *      });
     */
    tabsConfig              : null,

    /**
     * @cfg {Object} taskFormConfig Configuration options to be supplied to the `General` tab.
     * For possible options take a look at the {@link Gnt.widget.TaskForm}.
     */
    taskFormConfig          : null,

    /**
     * @cfg {String} dependencyGridClass Class representing the grid panel in the `Predecessor` tab.
     *
     * Override this to provide your own implementation subclassing the {@link Gnt.widget.DependencyGrid} class.
     */
    dependencyGridClass     : 'Gnt.widget.DependencyGrid',

    /**
     * @cfg {Object} dependencyGridConfig Configuration options for the `Predecessors` tab.
     * For possible options take a look at the {@link Gnt.widget.DependencyGrid}.
     *
     */
    dependencyGridConfig    : null,

    /**
     * @cfg {String} assignmentGridClass Class representing the grid panel in the `Resources` tab.
     *
     * Override this to provide your own implementation subclassing the {@link Gnt.widget.AssignmentEditGrid} class.
     */
    assignmentGridClass     : 'Gnt.widget.AssignmentEditGrid',

    /**
     * @cfg {Object} assignmentGridConfig Configuration options for the `Resources` tab.
     * For possible options take a look at the {@link Gnt.widget.AssignmentEditGrid}.
     *
     */
    assignmentGridConfig    : null,

    styleFormConfig         : null,

    /**
     * @cfg {Object} advancedFormConfig Configuration options for the `Advanced` tab.
     * For possible options take a look at the {@link Gnt.widget.TaskForm}.
     *
     */
    advancedFormConfig      : null,

    /**
     * @cfg {Object} notesConfig Configuration options for the `Notes` tab.
     * For possible options take a look at the {@link Ext.form.field.HtmlEditor}.
     *
     */
    notesConfig             : null,

    height                  : 340,
    width                   : 600,
    layout                  : 'fit',

    /**
     * @property {Ext.tab.Panel} tabs Main TabPanel contained by task editor widget.
     */
    tabs                    : null,

    /**
     * @property {Gnt.widget.TaskForm} taskForm The `General` tab task form.
     * By default it's a {@link Gnt.widget.TaskForm} instance but it might be customized by using {@link #taskFormClass} option.
     */
    taskForm                : null,

    /**
     * @property {Gnt.widget.AssignmentEditGrid} assignmentGrid The grid used for the `Resources` tab.
     *
     */
    assignmentGrid          : null,

    /**
     * @property {Gnt.widget.DependencyGrid} dependencyGrid The `Predecessors` tab instance.
     *
     */
    dependencyGrid          : null,
    /**
     * @property {Gnt.widget.TaskForm} advancedForm The `Advanced` tab form.
     * By default it's a {@link Gnt.widget.TaskForm} instance but it can be customized by using {@link #advancedFormClass} option.
     *
     */
    advancedForm            : null,

    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - generalText         : 'General',
            - resourcesText       : 'Resources',
            - dependencyText      : 'Predecessors',
            - addDependencyText   : 'Add new',
            - dropDependencyText  : 'Remove',
            - notesText           : 'Notes',
            - advancedText        : 'Advanced',
            - wbsCodeText         : 'WBS code',
            - addAssignmentText   : 'Add new',
            - dropAssignmentText  : 'Remove'
     */
    /**
     * @cfg {String} generalText A text for the `General` tab title.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} resourcesText A text for the `Resources` tab title.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} dependencyText A text for the `Predecessors` tab title.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} addDependencyText A text for the `Add new` button in the `Predecessors` tab.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} dropDependencyText A text for the `Remove` button in the "Predecessors" tab.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} notesText A text for the `Notes` tab title.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} advancedText A text for the `Advanced` tab title.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} wbsCodeText A text for the `WBS code` field label.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} addAssignmentText A text for the `Add new` button in the `Resources` tab.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} dropAssignmentText A text for the `Remove` button in the `Resources` tab.
     * @deprecated Please use {@link #l10n} instead.
     */

    stylingText             : 'Styling',
    clsText                 : 'CSS Class',
    backgroundText          : 'Background',
    doneBackgroundText      : 'Progress Background',

    constructor : function (config) {
        var me          = this,
            taskModel   = Gnt.model.Task.prototype;

        config = config || {};

        Ext.apply(this, config);

        this.taskFormConfig = this.taskFormConfig || {};

        Ext.applyIf(this.taskFormConfig, {
            showBaseline    : this.showBaseline
        });

        var items   = [];

        // create TaskForm instance
        this.taskForm = Ext.create(this.taskFormClass || 'Gnt.widget.taskeditor.TaskForm', Ext.applyIf(this.taskFormConfig, {
            task        : this.task,
            taskStore   : this.taskStore
        }));

        items.push(this.taskForm);

        // create DependencyGrid instance
        if (this.showDependencyGrid) {
            this.dependencyGrid = Ext.create(this.dependencyGridClass, Ext.apply({
                allowParentTaskDependencies     : this.allowParentTaskDependencies,
                taskModel   : this.taskStore.model,
                task        : this.task,
                margin      : 5,
                tbar        : {
                    layout  : 'auto',
                    items   : [
                        {
                            xtype       : 'button',
                            iconCls     : 'gnt-action-add',
                            text        : this.L('addDependencyText'),
                            handler     : function() {
                                me.dependencyGrid.insertDependency();
                            }
                        },
                        {
                            xtype       : 'button',
                            iconCls     : 'gnt-action-remove',
                            text        : this.L('dropDependencyText'),
                            itemId      : 'drop-dependency-btn',
                            disabled    : true,
                            handler     : function() {
                                var recs = me.dependencyGrid.getSelectionModel().getSelection();
                                if (recs && recs.length) {
                                    me.dependencyGrid.store.remove(recs);
                                }
                            }
                        }
                    ]
                },
                listeners   : {
                    selectionchange : function(sm, sel) {
                        var grid    = me.dependencyGrid;
                        if (!grid.dropDepBtn) {
                            grid.dropDepBtn  = grid.down('[itemId=drop-dependency-btn]');
                        }
                        grid.dropDepBtn && grid.dropDepBtn.setDisabled(!sel.length);
                    }
                }
            }, this.dependencyGridConfig));

            items.push(this.dependencyGrid);
        }

        // if AssignmentGrid required
        if (this.showAssignmentGrid && this.assignmentStore && this.resourceStore) {
            // create AssignmentGrid instance
            this.assignmentGrid = Ext.create(this.assignmentGridClass, Ext.apply({
                assignmentStore : this.assignmentStore,
                resourceStore   : this.resourceStore,
                tbar        : {
                    layout  : 'auto',
                    items   : [
                        {
                            xtype       : 'button',
                            iconCls     : 'gnt-action-add',
                            text        : this.L('addAssignmentText'),
                            handler     : function() {
                                me.assignmentGrid.insertAssignment();
                            }
                        },
                        {
                            xtype       : 'button',
                            iconCls     : 'gnt-action-remove',
                            text        : this.L('dropAssignmentText'),
                            itemId      : 'drop-assignment-btn',
                            disabled    : true,
                            handler     : function() {
                                var recs = me.assignmentGrid.getSelectionModel().getSelection();
                                if (recs && recs.length) {
                                    me.assignmentGrid.store.remove(recs);
                                }
                            }
                        }
                    ]
                },
                listeners       : {
                    // we need this to draw selection properly on very first activation of tab
                    // to gracefully process deferredRender = true
                    afterrender : {
                        fn      : function(el) {
                            el.loadTaskAssignments(me.task.get(me.task.idProperty));
                        },
                        single  : true
                    },
                    selectionchange : function(sm, sel) {
                        var grid    = me.assignmentGrid;
                        if (!grid.dropBtn) {
                            grid.dropBtn = grid.down('[itemId=drop-assignment-btn]');
                        }
                        grid.dropBtn && grid.dropBtn.setDisabled(!sel.length);
                    }
                }
            }, this.assignmentGridConfig));

            items.push(this.assignmentGrid);
        }

        // if advanced form required
        if (this.showAdvancedForm) {
            var frm = Ext.ClassManager.get(this.advancedFormClass || 'Gnt.widget.taskeditor.TaskForm').prototype;

            this.advancedFormConfig = this.advancedFormConfig || {};

            // create TaskForm instance for the "Advanced" tab form
            this.advancedForm = Ext.create(this.advancedFormClass || 'Gnt.widget.taskeditor.TaskForm', Ext.applyIf(this.advancedFormConfig, {
                items       : [
                    {
                        xtype       : 'calendarfield',
                        fieldLabel  : frm.L('calendarText'),
                        name        : this.task ? this.task.calendarIdField : taskModel.calendarIdField,
                        value       : this.task && this.task.getCalendarId(true),
                        taskStore   : this.taskStore,
                        task        : this.task
                    },
                    {
                        xtype       : 'schedulingmodefield',
                        fieldLabel  : frm.L('schedulingModeText'),
                        name        : this.task ? this.task.schedulingModeField : taskModel.schedulingModeField,
                        value       : this.task && this.task.getSchedulingMode(),
                        allowBlank  : false,
                        taskStore   : this.taskStore,
                        task        : this.task
                    },
                    {
                        xtype       : 'displayfield',
                        fieldLabel  : this.L('wbsCodeText'),
                        name        : 'wbsCode',
                        value       : this.task && this.task.getWBSCode()
                    }
                ],
                task        : this.task,
                taskStore   : this.taskStore
            }));

            items.push(this.advancedForm);
        }

        // create notes panel
        if (this.showNotes) {
            // create notes HtmlEditor instance
            this.notesEditor = Ext.create('Ext.form.field.HtmlEditor', Ext.apply({
                listeners       : {
                    // we need this to draw content of HtmlEditor properly on very first activation of tab
                    // to gracefully process deferredRender = true
                    afterrender : function(el) {
                        me.notesEditor.setValue(me.task.get(me.task.noteField));
                    }
                }
            }, this.notesConfig));

            // we have to wrap it to panel since it's gonna be tab in TabPanel
            // (to avoid some render bugs)
            this.notesPanel = Ext.create('Ext.panel.Panel', {
                border  : false,
                layout  : 'fit',
                items   : this.notesEditor
            });

            items.push(this.notesPanel);
        }

        // show style tab
        /*if (this.showStyle) {
            var fname = this.task ? this.task.clsField : taskModel.clsField;

            this.styleFormConfig = this.styleFormConfig || {};

            this.styleFormConfig.items = [
                {
                    xtype       : 'textfield',
                    fieldLabel  : this.clsText,
                    name        : fname,
                    value       : this.task ? this.task.get(fname) : ''
                },
                {
                    xtype       : 'backgroundfield',
                    fieldLabel  : this.backgroundText
                },
                {
                    xtype       : 'backgroundfield',
                    fieldLabel  : this.doneBackgroundText
                }
            ];

            this.styleForm  = Ext.create('Ext.form.Panel', Ext.applyIf(this.styleFormConfig, {
                border      : false,
                task        : this.task,
                taskStore   : this.taskStore
            }));

            items.push(this.styleForm);
        }*/

        this.tabsConfig = this.tabsConfig || {};
        // if we have enough stuff to make TabPanel let's make it
        if (items.length > 1 || this.tabsConfig.items) {
            // make sure that each panel has its title
            this.taskForm.title         = this.taskForm.title || this.L('generalText');

            if (this.dependencyGrid) this.dependencyGrid.title  = this.dependencyGrid.title || this.L('dependencyText');
            if (this.assignmentGrid) this.assignmentGrid.title  = this.assignmentGrid.title || this.L('resourcesText');
            if (this.advancedForm) this.advancedForm.title      = this.advancedForm.title || this.L('advancedText');
            if (this.notesPanel) this.notesPanel.title          = this.notesPanel.title || this.L('notesText');
            if (this.styleForm) this.styleForm.title            = this.styleForm.title || this.stylingText;

            // user defined tabs go after our predefined ones
            if (this.tabsConfig.items) {
                items.push.apply(items, Ext.isArray(this.tabsConfig.items) ? this.tabsConfig.items : [this.tabsConfig.items]);
                delete this.tabsConfig.items;
            }

            this.tabs = new Ext.tab.Panel(Ext.apply({
                border      : false,
                items       : items,
                plain       : true,
                defaults    : {
                    margin  : 5,
                    border  : false
                }
            }, this.tabsConfig));
        }

        this.items = this.tabs || this.taskForm;

        this.callParent(arguments);
    },


    /**
     * Loads task data into task editor.
     * @param {Gnt.model.Task} task Task to load to editor.
     */
    loadTask : function (task) {
        if (!task) return;

        this.task           = task;

        var taskForm        = this.taskForm;

        // on task loading step let's suppress task updating
        taskForm.setSuppressTaskUpdate(true);
        taskForm.getForm().reset();

        // if we have assignmentGrid we need to make copy of taskStore as well
        // we will bind it to assignmentGrid's stores to have instant correlation
        // between taskForm and assignmentGrid
        if (this.assignmentGrid) {
            var taskBuffer          = task.copy();
            // such simple copying is enough for our purposes
            taskBuffer.taskStore    = Ext.apply({}, task.taskStore);

            taskForm.loadRecord(task, taskBuffer);
        } else {
            taskForm.loadRecord(task);
        }

        if (this.advancedForm) {
            // disable 'taskupdated' event processing for advancedForm
            this.advancedForm.setSuppressTaskUpdate(true);

            var form    = this.advancedForm.getForm();

            form.reset();

            // we point advancedForm.taskBuffer to taskForm.taskBuffer
            // it will allow them to share changes of each other
            this.advancedForm.loadRecord(task, taskForm.taskBuffer);

            var field   = form.findField('wbsCode');
            if (field) {
                field.setValue(task.getWBSCode());
            }

            // enable 'taskupdated' event processing for advancedForm back
            this.advancedForm.setSuppressTaskUpdate(false);
        }

        // enable 'taskupdated' event processing back
        taskForm.setSuppressTaskUpdate(false);

        if (this.styleForm) {
            this.styleForm.loadRecord(task);
        }

        if (this.notesEditor) {
            this.notesEditor.setValue(task.get(task.noteField));
        }

        var assignmentGrid  = this.assignmentGrid;

        if (assignmentGrid) {
            // set assignmentGrid store as assignmentStore for taskForm.taskBuffer
            // to reflect all assignments changes immediately
            taskForm.taskBuffer.taskStore.setAssignmentStore(assignmentGrid.store);
            // do the same with resourceStore (assignmentGrid.resourceDupStore play the role)
            taskForm.taskBuffer.taskStore.setResourceStore(assignmentGrid.resourceDupStore);
            // and vise versa ..we set taskStore to cloned version of task.taskStore
            assignmentGrid.store.taskStore                 = taskForm.taskBuffer.taskStore;
            assignmentGrid.resourceDupStore.taskStore      = taskForm.taskBuffer.taskStore;

            assignmentGrid.loadResources();
            // load task assignments to grid
            assignmentGrid.loadTaskAssignments(task.getId() || task.getPhantomId());
        }

        var dependencyGrid  = this.dependencyGrid;

        if (dependencyGrid) {
            if (this.allowParentTaskDependencies || task.isLeaf()) {
                dependencyGrid.tab.show();
                dependencyGrid.loadDependencies(task);
            } else {
                dependencyGrid.tab.hide();
            }
        }

        this.fireEvent('loadtask', this, task);
    },

    /**
     * Returns the item that is currently active inside this task editor TabPanel.
     * Internally calls Ext.tab.Panel.getActiveTab method.
     * @return {Ext.Component} Currently active item or `null` if task editor doesn't have TabPanel.
     */
    getActiveTab : function () {
        return this.tabs && this.tabs.getActiveTab();
    },

    /**
     * Makes the given card active (if task editor have TabPanel).
     * Internally calls Ext.tab.Panel.setActiveTab method.
     * @param {String/Number/Ext.Component} card The card to make active. Either an ID, index or the component itself.
     * @return {Ext.Component} The resulting active item or `null` if task editor doesn't have TabPanel.
     */
    setActiveTab : function (card) {
        return this.tabs && this.tabs.setActiveTab(card);
    },

    /**
     * Returns the item of task editor TabPanel that contains specified component.
     * @return {Ext.Component} Item of TabPanel containing specified component or `undefined` if item wasn't found
     * or task editor doesn't have TabPanel.
     */
    getTabByComponent : function (component) {
        if (!this.tabs) return;

        var result;
        this.tabs.items.each(function (el) {
            if (component === el || component.isDescendantOf(el)) {
                result = el;
                return false;
            }
        }, this);

        return result;
    },

    /**
     * Checks data loaded or entered to task editor for errors.
     * Calls isValid methods of taskForm, dependencyGrid, advancedForm (if corresponding objects are presented at the task editor).
     * In case some of calls returns `false` switch active tab so that user can view invalid object.
     * Validation can be customized by handling {@link #event-validate} event.
     *
     * Returns `false` in that case.
     * @return {Boolean} Returns `true` if all components are valid.
     */
    validate : function () {
        var activeTab   = this.getActiveTab(),
            result      = true,
            tabToFocus;

        if (activeTab) {
            if (!this.taskForm.isValid()) {
                // if we are already at tab with error
                if (this.taskForm === activeTab || this.taskForm.isDescendantOf(activeTab)) {
                    return false;
                }

                result      = false;
                // get tab to switch to
                tabToFocus  = this.getTabByComponent(this.taskForm);
            }

            if (this.dependencyGrid && !this.dependencyGrid.isValid()) {
                // if we are already at tab with error
                if (this.dependencyGrid === activeTab || this.dependencyGrid.isDescendantOf(activeTab)) {
                    return false;
                }

                result      = false;
                // get tab to switch to
                tabToFocus  = tabToFocus || this.getTabByComponent(this.dependencyGrid);
            }

            if (this.assignmentGrid && !this.assignmentGrid.isValid()) {
                // if we are already at tab with error
                if (this.assignmentGrid === activeTab || this.assignmentGrid.isDescendantOf(activeTab)) {
                    return false;
                }

                result      = false;
                // get tab to switch to
                tabToFocus  = tabToFocus || this.getTabByComponent(this.assignmentGrid);
            }

            if (this.advancedForm && !this.advancedForm.isValid()) {
                // if we are already at tab with error
                if (this.advancedForm === activeTab || this.advancedForm.isDescendantOf(activeTab)) {
                    return false;
                }

                result      = false;
                // get tab to switch to
                tabToFocus  = tabToFocus || this.getTabByComponent(this.advancedForm);
            }
        }

        // switch to another tab with error
        if (tabToFocus) {
            this.setActiveTab(tabToFocus);
        }

        // validation result
        return (this.fireEvent('validate', this, tabToFocus) !== false) && result;
    },

    /**
     * Persists the values in this task editor into corresponding {@link Gnt.model.Task} object provided to showTask.
     * @return {Boolean} Returns `true` if task was updated. Returns False if some {@link #beforeupdatetask} listener returns False.
     */
    updateTask : function () {
        // process finalization function code to allow to use return "false" in
        // "beforeupdatetask" handler and call finalization asynchronously
        var cont = Ext.Function.bind(function () {
            this.taskForm.updateRecord();

            if (this.advancedForm) {
                this.advancedForm.updateRecord();
            }

            if (this.notesEditor) {
                this.task.set(this.task.noteField, this.notesEditor.getValue());
            }

            if (this.styleForm) {
                this.styleForm.getForm().updateRecord();
            }

            if (this.assignmentGrid) {
                this.assignmentGrid.saveTaskAssignments();
            }

            if (this.dependencyGrid) {
                this.dependencyGrid.saveDependencies();
            }

            this.fireEvent('afterupdatetask', this);
        }, this);


        if (this.fireEvent('beforeupdatetask', this, cont) !== false) {
            cont();

            return true;
        }

        return false;
    }

});

/**

@class Gnt.plugin.TaskEditor
@extends Ext.window.Window

{@img gantt/images/taskeditor-general.png}

A plugin (ptype = 'gantt_taskeditor') which shows a {@link Gnt.widget.taskeditor.TaskEditor} in a window when a user double-clicks a task bar in the gantt chart.

You can enable this plugin in your Gantt chart like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        ...
        plugins : Ext.create("Gnt.plugin.TaskEditor", {
            // window title
            title           : 'Task Editor'
        }),
        ...
    })


{@img gantt/images/taskeditor-general.png}

#Plugin customizing
Essentially this widget extends Ext.window.Window so any regular window configs can be used for it.
Also it supports a lot of configs provided by the {@link Gnt.widget.taskeditor.TaskEditor} class.
So if you want to customize task editor content (task form, resources grid etc.) you can read
the {@link Gnt.widget.taskeditor.TaskEditor} guide and apply corresponding configs to the plugin.

Another way to customize the task editor panel is {@link #panelConfig} config. With it you can
customize any config of the task editor panel, even the ones not translated by this plugin
(like `title`, `width`, `height` etc). For example:

    var plugin = Ext.create("Gnt.plugin.TaskEditor", {
        title       : 'I am window title',
        panelConfig : {
            title   : 'I am panel title'
        }
    });

**Note:** Please see {@link Gnt.widget.taskeditor.TaskEditor} class for details on how to customize the components of the tabs.

#Buttons customizing

By default window has two buttons `Ok` and `Cancel` to apply and rollback changes respectively.
If you want to just rename them you can use {@link #l10n} config. Like this:

    var plugin = Ext.create("Gnt.plugin.TaskEditor", {
        l10n : {
            okText      : 'Apply changes',
            cancelText  : 'Reject changes'
        }
    });

And if you need to implement custom buttons you can easily do it using `buttons` config. Like this:

    var plugin = Ext.create("Gnt.plugin.TaskEditor", {
        buttons : [
            {
                text    : 'Show some alert',
                handler : function() {
                    alert('Some alert');
                }
            }
        ]
    });

And finally if you don't want any buttons at all you can overwrite `buttons` config with an empty array. Like this:

    var plugin = Ext.create("Gnt.plugin.TaskEditor", {
        buttons : []
    });


*/
Ext.define('Gnt.plugin.TaskEditor', {
    extend          : 'Ext.window.Window',

    requires        : [
        'Ext.window.MessageBox',
        'Gnt.widget.taskeditor.TaskEditor'
    ],

    alias           : 'plugin.gantt_taskeditor',
    mixins          : ['Ext.AbstractPlugin', 'Gnt.mixin.Localizable'],

    lockableScope   : 'top',

    /**
     * @property {Gnt.widget.taskeditor.TaskEditor} taskEditor The task editor widget contained by the plugin.
     */
    taskEditor      : null,

    /**
     * @cfg {Object} panelConfig Configuration for {@link Gnt.widget.taskeditor.TaskEditor} instance.
     */
    panelConfig     : null,

    height          : 340,

    width           : 600,
    layout          : 'fit',

    /**
     * @cfg {String} triggerEvent
     * The event upon which the editor shall be shown. Defaults to 'taskdblclick'.
     */
    triggerEvent    : 'taskdblclick',

    closeAction     : 'hide',

    modal           : true,

    gantt           : null,

    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore A store with assignments.
     * If this config is not provided plugin will try to retrieve assignments store from {@link Gnt.panel.Gantt} instance.
     */
    assignmentStore : null,

    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore A store with resources.
     * If this config is not provided plugin will try to retrieve resources store from {@link Gnt.panel.Gantt} instance.
     */
    resourceStore   : null,

    /**
     * @cfg {Gnt.data.TaskStore} taskStore A store with tasks.
     * If this config is not provided plugin will try to retrieve tasks store from {@link Gnt.panel.Gantt} instance.
     * **Note:** Task store is required if task doesn't belong to any task store yet.
     */
    taskStore       : null,

    /**
     * @cfg {String} alertCaption A caption for message box displaying on validation errors.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} alertText A text for message displaying on validation errors.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} okText A text for Ok button.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} cancelText A text Cancel button.
     * @deprecated Please use {@link #l10n} instead.
     */

    /**
     * @cfg {Gnt.model.Task} task The task to show in the task editor.
     */

    /**
     * @cfg {String} taskFormClass Class instance of which will represent form in the `General` tab.
     *
     * This option supposed to be used to implement custom form in the `General` tab content.
     */

    /**
     * @cfg {String} advancedFormClass Class instance of which will represent form in the `Advanced` tab.
     *
     * This option supposed to be used to implement custom form in the `Advanced` tab content.
     */

    /**
     * @cfg {Boolean} showAssignmentGrid `true` to display `Resources` tab.
     */

    /**
     * @cfg {Boolean} showDependencyGrid `true` to display `Predecessors` tab.
     */

    /**
     * @cfg {Boolean} allowParentTaskDependencies `true` to display a `Predecessors` tab for parent tasks
     * (requires {@link #showDependencyGrid} to be `true` as well) and also include parent tasks in the list
     * of possible predecessors. Defaults to `false`.
     */

    /**
     * @cfg {Boolean} showNotes `true` to display `Notes` tab.
     */

    /**
     * @cfg {Boolean} showAdvancedForm `true` to display `Advanced` tab.
     */

    /**
     * @cfg {Object} tabsConfig TabPanel configuration. Any Ext.tab.Panel options can be used.
     *
     * **Note:** TabPanel may not be created due to configuration settings.
     */

    /**
     * @cfg {Object} taskFormConfig Configuration of task form placed at `General` tab.
     * For possible options take a look at {@link Gnt.widget.TaskForm}.
     */

    /**
     * @cfg {String} dependencyGridClass Class representing the grid panel in the `Predecessor` tab.
     *
     * Override this to provide your own implementation subclassing the {@link Gnt.widget.DependencyGrid} class.
     */
    /**
     * @cfg {Object} dependencyGridConfig Configuration of grid placed at `Predecessors` tab.
     * For possible options take a look at {@link Gnt.widget.DependencyGrid}.
     *
     * **Note:** This grid may not be created if {@link #showDependencyGrid} set to `false`.
     */

    /**
     * @cfg {String} assignmentGridClass Class representing the grid panel in the `Resources` tab.
     *
     * Override this to provide your own implementation subclassing the {@link Gnt.widget.AssignmentEditGrid} class.
     */
    /**
     * @cfg {Object} assignmentGridConfig Configuration of grid placed at `Resources` tab.
     * For possible options take a look at {@link Gnt.widget.AssignmentEditGrid}.
     *
     * **Note:** This grid may not be created if {@link #showAssignmentGrid} set to `false`
     * or {@link #assignmentStore} or {@link #resourceStore} is not specified.
     */

    /**
     * @cfg {Object} advancedFormConfig Configuration of task form placed at `Advanced` tab.
     * For possible options take a look at {@link Gnt.widget.TaskForm}.
     *
     * **Note:** This form may not be created if {@link #showAdvancedForm} set to `false`.
     */

    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - title               : 'Task Information',
            - alertCaption        : 'Information',
            - alertText           : 'Please correct marked errors to save changes',
            - okText              : 'Ok',
            - cancelText          : 'Cancel',
            - generalText         : 'General',
            - resourcesText       : 'Resources',
            - dependencyText      : 'Predecessors',
            - addDependencyText   : 'Add new',
            - dropDependencyText  : 'Remove',
            - notesText           : 'Notes',
            - advancedText        : 'Advanced',
            - wbsCodeText         : 'WBS code',
            - addAssignmentText   : 'Add new',
            - dropAssignmentText  : 'Remove'
     */
    /**
     * @cfg {String} generalText A text for the `General` tab title.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} resourcesText A text for the `Resources` tab title.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} dependencyText A text for the `Predecessors` tab title.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} addDependencyText A text for the `Add new` button in the `Predecessors` tab.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} dropDependencyText A text for the `Remove` button in the "Predecessors" tab.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} notesText A text for the `Notes` tab title.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} advancedText A text for the `Advanced` tab title.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} wbsCodeText A text for the `WBS code` field label.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} addAssignmentText A text for the `Add new` button in the `Resources` tab.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} dropAssignmentText A text for the `Remove` button in the `Resources` tab.
     * @deprecated Please use {@link #l10n} instead.
     */

    constructor : function (config) {
        config = config || {};

        // we need to apply config to let locale()
        // know about legacy locales since it will check them in 'this'
        Ext.apply(this, config);

        this.title = this.L('title');

        // by default we make 'Ok', 'Cancel' buttons
        if (!config.buttons) {
            this.buttons = ['->',
                {
                    text    : this.L('okText'),
                    handler : function() {
                        this.completeEditing() || Ext.Msg.alert(this.L('alertCaption'), this.L('alertText'));
                    },
                    scope   : this
                },
                {
                    text    : this.L('cancelText'),
                    handler : this.close,
                    scope   : this
                }
            ];
        }

        this.callParent(arguments);
        this.addCls('gnt-taskeditor-window');
    },

    init : function (cmp) {
        // if assignmentStore or resourceStore wasn't defined as configuration options
        // during plugin constructing we get them from Gnt.panel.Gantt instance
        this.assignmentStore    = this.assignmentStore || cmp.getAssignmentStore();
        this.resourceStore      = this.resourceStore || cmp.getResourceStore();
        this.taskStore          = this.taskStore || cmp.getTaskStore();

        // let's map some configuration options from plugin to taskEditor
        var cfg = {
                width   : null,
                height  : null,
                border  : false
            },
            map = [
                'l10n',
                'task',
                'taskStore',
                'assignmentStore',
                'resourceStore',
                'generalText',
                'resourcesText',
                'dependencyText',
                'addDependencyText',
                'dropDependencyText',
                'notesText',
                'advancedText',
                'wbsCodeText',
                'addAssignmentText',
                'dropAssignmentText',
                'showAssignmentGrid',
                'showDependencyGrid',
                'allowParentTaskDependencies',
                'showNotes',
                'showStyle',
                'showAdvancedForm',
                'taskFormClass',
                'advancedFormClass',
                'tabsConfig',
                'taskFormConfig',
                'dependencyGridConfig',
                'assignmentGridConfig',
                'advancedFormConfig',
                'styleFormConfig',
                'dependencyGridClass',
                'assignmentGridClass'
            ];

        for (var i = 0, l = map.length; i < l; i++) {
            if (this[map[i]] !== undefined) cfg[map[i]] = this[map[i]];
        }

        cfg.showBaseline = cmp.enableBaseline;

        Ext.apply(cfg, this.panelConfig);

        this.taskEditor = Ext.create('Gnt.widget.taskeditor.TaskEditor', cfg);

        /**
         * @event loadtask
         * Fires after task loading complete.
         * @param {Gnt.widget.taskeditor.TaskEditor} taskEditor Task editor widget instance used for editing.
         * @param {Gnt.model.Task} task The loaded task.
         *
         *
         * This event can be used to do additional data loading if task editor was extended with some extra fields.
         * Also please take a look at {@link #afterupdatetask} event to have an example of how to implement custom data saving.
         *
         *      // some custom user form
         *      var customForm = new Gnt.widget.taskeditor.TaskForm({
         *          title : 'Custom form panel',
         *          xtype : 'taskform',
         *          items : [
         *              {
         *                  fieldLabel  : 'Foo field',
         *                  name        : 'foo',
         *                  allowBlank  : false
         *              }
         *          ],
         *          taskStore   : taskStore
         *      });
         *
         *      var taskEditor = Ext.create('Gnt.plugin.TaskEditor', {
         *          tabsConfig: {
         *              // register custom form as an additional tab
         *              items: customForm
         *          },
         *          listeners   : {
         *              // populate custom form with task values
         *              loadtask : function (taskeditor, task) {
         *                  customForm.loadRecord(task);
         *              },
         *              ....
         *          }
         *      });
         */

        /**
         * @event validate
         * Fires when task validation occurs. Take a look at example of using this event {@link Gnt.widget.taskeditor.TaskEditor#event-validate here}.
         * @param {Gnt.widget.taskeditor.TaskEditor} taskEditor Task editor widget instance.
         */

        /**
         * @event beforeupdatetask
         * Fires before task updating occurs. Return false to prevent the update.
         * @param {Gnt.widget.taskeditor.TaskEditor} taskEditor Task editor widget instance used for editing.
         * @param {Function} proceedCallback The function which can be called manually to continue task updating. Example:
         *
         *      var taskEditor = Ext.create('Gnt.plugin.TaskEditor', {
         *          listeners   : {
         *              beforeupdatetask    : function (taskeditor, proceedCallback) {
         *                  var me  = this;
         *                  Ext.MessageBox.confirm('Confirm', 'Are you sure you want to do that?', function (buttonId) {
         *                      if (buttonId == 'yes') {
         *                          // here we continue updating asynchronously after user click "Yes" button
         *                          proceedCallback();
         *                          me.hide();
         *                      }
         *                  });
         *                  // here we return false to stop updating
         *                  return false;
         *              }
         *          }
         *      });
         *
         */

        /**
         * @event afterupdatetask
         * Fires after task updating is finished.
         * @param {Gnt.widget.taskeditor.TaskEditor} taskEditor Task editor widget instance.
         *
         * This event can be used to do some extra processing after task was updated by task editor.
         * For example in case when you have some additional fields you can implement saving of them using this event.
         * Also please take a look at {@link #loadtask} event to have an example of how to implement custom data loading.
         *
         *      // some custom user form
         *      var customForm = new Gnt.widget.taskeditor.TaskForm({
         *          title : 'Custom form panel',
         *          xtype : 'taskform',
         *          items : [
         *              {
         *                  fieldLabel  : 'Foo field',
         *                  // foo - is the name of custom task field
         *                  name        : 'foo',
         *                  allowBlank  : false
         *              }
         *          ],
         *          taskStore   : taskStore
         *      });
         *
         *      var taskEditor = Ext.create('Gnt.plugin.TaskEditor', {
         *          tabsConfig: {
         *              // register custom form as an additional tab
         *              items: customForm
         *          },
         *          listeners   : {
         *              afterupdatetask : function (taskeditor) {
         *                  // update form fields to loaded task
         *                  customForm.updateRecord();
         *              },
         *              ....
         *          }
         *      });
         */

        this.add(this.taskEditor);

        // relay TaskEditor widget events
        this.relayEvents(this.taskEditor, ['validate', 'beforeupdatetask', 'afterupdatetask', 'loadtask']);

        cmp.on(this.triggerEvent, this.onTriggerEvent, this);
        cmp.on('destroy', this.destroy, this);

        this.gantt      = cmp;
        cmp.taskEditor  = this;
    },

    destroy : function () {
        this.taskEditor.destroy();

        this.callParent(arguments);
    },

    onTriggerEvent : function (gantt, task) {
        this.showTask(task);
    },

    /**
     * Shows window and loads task into the task editor.
     * @param {Gnt.model.Task} task Task to load.
     */
    showTask : function (task) {
        if (this.taskEditor && task) {
            this.taskEditor.loadTask(task);
            this.show();
        }
    },

    validate : function () {
        if (this.taskEditor) {
            return this.taskEditor.validate();
        }
    },

    /**
     * This function is a shorthand for the following typical steps:
     *
     *      if (!taskEditor.validate()) {
     *          Ext.MessageBox.alert('Information', 'Please correct marked errors to save changes');
     *      } else {
     *          if (taskEditor.updateTask()) taskEditor.hide();
     *      }
     *
     * Instead of above code you can write:
     *
     *      if (!taskEditor.completeEditing()) {
     *          Ext.MessageBox.alert('Information', 'Please correct marked errors to save changes');
     *      }
     *
     * @return {Boolean} true if validation successfully passed and record was successfully updated as well.
     */
    completeEditing : function () {
        if (this.taskEditor) {
            if (!this.taskEditor.validate()) return false;

            if (this.taskEditor.updateTask()) {
                this.hide();
                return true;
            }

            return false;
        }
    },

    /**
     * Persists the values in this task editor into corresponding {@link Gnt.model.Task}
     * object provided to {@link #showTask}.
     * Internally just calls {@link Gnt.widget.taskeditor.TaskEditor#updateTask updateTask} method of task editor panel.
     */
    updateTask : function () {
        if (this.taskEditor) {
            return this.taskEditor.updateTask();
        }
    }

});

/**

@class Gnt.column.Dependency
@extends Ext.grid.column.Column
@private

An internal private class serving as base class for Predecessor and Successor column classes.

*/
Ext.define("Gnt.column.Dependency", {
    extend      : "Ext.grid.column.Column",

    requires    : [
        'Gnt.field.Dependency'
    ],

    separator   : ';',
    type        : 'predecessors',        // Or 'successors'

    field       : null,

    /**
     * @cfg {Boolean} useSequenceNumber Set to `true` to use auto-generated sequential identifiers
     * to reference other tasks (see {@link Gnt.model.Task#getSequenceNumber} for definition). 
     * If value is `false`then the "real" id (that is stored in the database) will be used.
     */
    useSequenceNumber : false,

    constructor : function (config) {
        config      = config || {};

        var field   = config.field || config.editor;

        delete config.field;
        delete config.editor;

        Ext.apply(this, config);

        config.editor   = field || Ext.create('Gnt.field.Dependency', {
            type              : this.type,
            separator         : this.separator,
            useSequenceNumber : this.useSequenceNumber
        });

        if (!(config.editor instanceof Gnt.widget.DependencyField)) {
            config.editor = Ext.ComponentManager.create(config.editor, 'dependencyfield');
        }

        config.field = config.editor;

        this.scope      = this;

        this.callParent([ config ]);

    },

    afterRender : function() {
        var panel = this.up('ganttpanel');

        // Make top Gantt panel aware of the need for refreshing locked grid after changes in the dependency store
        panel.registerLockedDependencyListeners();

        this.callParent(arguments);
    },

    renderer    : function (value, meta, task) {
        if (!task.isEditable(this.dataIndex)) {
            meta.tdCls      = (meta.tdCls || '') + ' sch-column-readonly';
        }

        return this.field.getDisplayValue(task);
    }
});

/**

@class Gnt.column.Successor
@extends Gnt.column.Dependency

A Column showing the predecessors of a task. The column is editable, however to enable the editing you will need to add a
`Sch.plugin.TreeCellEditing` pluing to your gantt panel. The overall setup will look like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your grid columns
        columns         : [
            ...
            {
                xtype       : 'successorcolumn',
                width       : 70
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

This column uses a specialized field - {@link Gnt.field.Dependency} which allows the
user to specify multiple successors including lag. Please refer to {@link Gnt.field.Dependency}
documentation for expected value format.

*/
Ext.define("Gnt.column.Successor", {
    extend      : "Gnt.column.Dependency",

    mixins      : ['Gnt.mixin.Localizable'],

    alias       : "widget.successorcolumn",

    /**
     * @cfg {String} text The text to show in the column header, defaults to `Successors`.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - text : 'Successors'
     */

    type        : 'successors',

    constructor : function (config) {
        config = config || {};        

        this.text   = config.text || this.L('text');

        this.callParent(arguments);
    }
});

/**

@class Gnt.column.Predecessor
@extends Gnt.column.Dependency

A Column showing the predecessors of a task. The column is editable when adding a
`Sch.plugin.TreeCellEditing` plugin to your gantt panel. The overall setup will look like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your grid columns
        columns         : [
            ...
            {
                xtype       : 'predecessorcolumn',
                width       : 70
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

This column uses a specialized field - {@link Gnt.field.Dependency} which allows the
user to specify multiple predecessor including lag. Please refer to {@link Gnt.field.Dependency}
documentation for expected value format.

*/
Ext.define("Gnt.column.Predecessor", {
    extend      : "Gnt.column.Dependency",

    mixins      : ['Gnt.mixin.Localizable'],

    alias       : "widget.predecessorcolumn",

    /**
     * @cfg {String} text The text to show in the column header, defaults to `Predecessors`.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - text : 'Predecessors'
     */

    type        : 'predecessors',

    constructor : function (config) {
        config = config || {};        

        this.text   = config.text || this.L('text');

        this.callParent(arguments);
    }
});

/**

@class Gnt.column.Duration
@extends Ext.grid.column.Column

{@img gantt/images/duration-field.png}

A Column representing a `Duration` field of a task. The column is editable, however to enable the editing you will need to add a
`Sch.plugin.TreeCellEditing` pluing to your gantt panel. The overall setup will look like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your grid columns
        columns         : [
            ...
            {
                xtype       : 'durationcolumn',
                width       : 70
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

This column uses a field - {@link Gnt.field.Duration} which allows the
user to specify not only the duration value, but also the duration units.

When rendering the name of the duration unit, the {@link Sch.util.Date#getReadableNameOfUnit}
method will be used to retrieve the name of the unit.

*/
Ext.define('Gnt.column.Duration', {
    extend      : 'Ext.grid.column.Column',

    alias       : 'widget.durationcolumn',

    requires    : ['Gnt.field.Duration'],

    mixins      : ['Gnt.mixin.Localizable'],

    /**
     * @cfg {String} text The text to show in the column header.
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

        - text : 'Duration'
     */

    /**
     * @cfg {Number} width The width of the column.
     */
    width       : 80,

    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align       : 'left',

    /**
     * @cfg {Number} decimalPrecision A number of digits to show after the dot when rendering the value of the field or when editing it.
     * When set to 0, the duration values containing decimals part (like "6.5 days") will be considered invalid.
     */
    decimalPrecision        : 2,

    /**
     * @cfg {Boolean} useAbbreviation When set to `true`, the column will render the abbreviated duration unit name, not full. Abbreviation will also be used
     * when editing the value. Useful if the column width is limited.
     */
    useAbbreviation         : false,

    /**
     * @cfg {Boolean} instantUpdate Setting this to `false` will cause editor to apply its value to task only after it's closed.
     * And if this otion is `true` then each value change will be reflected to task immediately. This option is just translated
     * to the {@link Gnt.field.mixin.TaskField#instantUpdate} config option.
     */
    instantUpdate           : true,

    field                   : null,

    constructor : function (config) {
        config      = config || {};

        this.text   = config.text || this.L('text');

        var field   = config.field || config.editor;

        delete config.field;
        delete config.editor;

        Ext.apply(this, config);

        config.editor     = field || Ext.create('Gnt.field.Duration', {
            useAbbreviation         : this.useAbbreviation,
            decimalPrecision        : this.decimalPrecision,
            instantUpdate           : this.instantUpdate
        });

        if (!(config.editor instanceof Gnt.field.Duration)) {

            // apply default instantUpdate state
            Ext.applyIf(config.editor, {
                instantUpdate   : this.instantUpdate
            });

            config.editor = Ext.ComponentManager.create(config.editor, 'durationfield');
        }

        this.field = config.editor;
        this.scope = this;
        this.hasCustomRenderer = true;

        this.callParent([ config ]);
    },

    afterRender : function() {
        var tree    = this.up('treepanel');

        if (!this.dataIndex) {
            this.dataIndex = tree.store.model.prototype[this.field.taskField];
        }

        this.callParent(arguments);

    },

    renderer : function (value, meta, task) {
        if (!Ext.isNumber(value)) return '';

        if (!task.isEditable(this.dataIndex)) {
            meta.tdCls      = (meta.tdCls || '') + ' sch-column-readonly';
        }

        var durationUnit    = task.getDurationUnit();

        return this.field.valueToVisible(value, durationUnit);
    }
});

/**

@class Gnt.column.Effort
@extends Gnt.column.Duration

{@img gantt/images/duration-field.png}

A Column representing a `Effort` field of a task. The column is editable, however to enable the editing you will need to add a
`Sch.plugin.TreeCellEditing` pluing to your gantt panel. The overall setup will look like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your grid columns
        columns         : [
            ...
            {
                xtype       : 'effortcolumn',
                width       : 70
            }
            ...
        ],

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

This column uses a field - {@link Gnt.field.Duration} which allows the
user to specify not only the duration value, but also the duration units.

When rendering the name of the duration unit, the {@link Sch.util.Date#getReadableNameOfUnit}
method will be used to retrieve the name of the unit.

*/
Ext.define('Gnt.column.Effort', {
    extend                  : 'Gnt.column.Duration',

    alias                   : 'widget.effortcolumn',

    requires                : ['Gnt.field.Effort'],

    /**
     * @cfg {String} text A text of the header, default value is `Effort`
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

        - text : 'Effort'
     */

    /**
     * @cfg {Number} width The width of the column.
     */
    width                   : 80,

    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align                   : 'left',

    /**
     * @cfg {Number} decimalPrecision A number of digits to show after the dot when rendering the value of the field or when editing it.
     * When set to 0, the duration values containing decimals part (like "6.5 days") will be considered invalid.
     */
    decimalPrecision        : 2,

    field                   : null,

    constructor : function (config) {
        config      = config || {};

        this.text   = config.text || this.L('text');

        var field   = config.field || config.editor;

        delete config.field;
        delete config.editor;

        Ext.apply(this, config);

        config.editor     = field || Ext.create('Gnt.field.Effort', {
            useAbbreviation         : this.useAbbreviation,
            decimalPrecision        : this.decimalPrecision,
            getDurationMethod       : null,

            instantUpdate           : this.instantUpdate
        });

        if (!(config.editor instanceof Gnt.field.Effort)) {

            // apply default instantUpdate state
            Ext.applyIf(config.editor, {
                useAbbreviation         : this.useAbbreviation,
                decimalPrecision        : this.decimalPrecision,
                getDurationMethod       : null,

                instantUpdate           : this.instantUpdate
            });

            config.editor = Ext.ComponentManager.create(config.editor, 'effortfield');
        }

        this.field = config.editor;
        this.scope = this;
        this.hasCustomRenderer = true;

        this.callParent([ config ]);
    },

    afterRender : function() {
        var tree    = this.up('treepanel');

        if (!this.dataIndex) {
            this.dataIndex = tree.store.model.prototype[this.field.taskField];
        }

        this.callParent(arguments);

    },

    renderer : function (value, meta, task) {
        if (!Ext.isNumber(value)) return '';

        if (!task.isEditable(this.dataIndex)) {
            meta.tdCls      = (meta.tdCls || '') + ' sch-column-readonly';
        }

        var effortUnit      = task.getEffortUnit();

        return this.field.valueToVisible(value, effortUnit);
    }

});

/**

@class Gnt.widget.Calendar
@extends Ext.picker.Date

{@img gantt/images/widget-calendar.png}

This a very simple subclass of the {@link Ext.picker.Date} which will show the holidays/weekends from the provided calendar.
The non-working time will be shown as the disabled dates.

*/
Ext.define('Gnt.widget.Calendar', {
    extend              : 'Ext.picker.Date',

    alias               : 'widget.ganttcalendar',

    requires            : ['Gnt.data.Calendar', 'Sch.util.Date'],

    mixins              : ['Gnt.mixin.Localizable'],

    /**
     * @cfg {Gnt.data.Calendar} calendar An instance of the {@link Gnt.data.Calendar} to read the holidays from
     */
    calendar            : null,

    /**
     * @cfg {Date} startDate A start date of the range to show the holidays for.
     */
    startDate           : null,

    /**
     * @cfg {Date} endDate An end date of the range to show the holidays for.
     */
    endDate             : null,

    /**
     * @cfg {String} disabledDatesText A text to show in the tooltip when user selects a non-working day.
     * @deprecated
     */

    initComponent : function () {
        if (!this.calendar) {
            Ext.Error.raise('Required attribute "calendar" missing during initialization of `Gnt.widget.Calendar`');
        }

        if (!this.startDate) {
            Ext.Error.raise('Required attribute "startDate" missing during initialization of `Gnt.widget.Calendar`');
        }

        if (!this.endDate) {
            this.endDate = Sch.util.Date.add(this.startDate, Sch.util.Date.MONTH, 1);
        }

        this.setCalendar(this.calendar);

        this.minDate        = this.value = this.startDate;

        this.callParent(arguments);
        
        // this method requires "this.format" presense which, starting from 4.2.1 is initialized in the parent "initComponent"
        this.injectDates();
    },

    injectDates : function() {
        var me              = this;
        var disabledDates   = me.disabledDates = [];

        Ext.each(me.calendar.getHolidaysRanges(me.startDate, me.endDate), function (range) {
            range.forEachDate(function (date) {
                disabledDates.push(Ext.Date.format(date, me.format));
            });
        });

        me.setDisabledDates(disabledDates);
    },

    /**
     * Sets the calendar for this calendar picker
     *
     * @param {Gnt.data.Calendar} calendar
     */
    setCalendar : function (calendar) {
        var listeners = {
            update  : this.injectDates,
            remove  : this.injectDates,
            add     : this.injectDates,
            load    : this.injectDates,
            clear   : this.injectDates,
            scope   : this
        };

        if (this.calendar) {
            this.calendar.un(listeners);
        }

        this.calendar = calendar;

        calendar.on(listeners);
    }
});

Ext.define('Gnt.widget.calendar.ResourceCalendarGrid', {
    extend          : 'Ext.grid.Panel',

    requires        : [
        'Gnt.data.Calendar',
        'Sch.util.Date'
    ],

    mixins          : ['Gnt.mixin.Localizable'],

    alias           : 'widget.resourcecalendargrid',

    resourceStore   : null,
    calendarStore   : null,

    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - name      : 'Name',
            - calendar  : 'Calendar'
     */

    initComponent   : function() {
        var me = this;

        this.calendarStore = this.calendarStore || Ext.create('Ext.data.Store', {
            fields : ['Id', 'Name']
        });

        Ext.apply(me, {
            store           : me.resourceStore,

            columns: [{
                header      : this.L('name'),
                dataIndex   : 'Name',
                flex        : 1
            }, {
                header      : this.L('calendar'),
                dataIndex   : 'CalendarId',
                flex        : 1,
                renderer    : function(value, meta, record, col, index, store) {
                    if (!value) {
                        var cal = record.getCalendar();
                        value = cal ? cal.calendarId : "";
                    }
                    var rec = me.calendarStore.getById(value);
                    return rec ? rec.get('Name') : value;
                },
                editor      : {
                    xtype           : 'combobox',
                    store           : me.calendarStore,
                    queryMode       : 'local',
                    displayField    : 'Name',
                    valueField      : 'Id',
                    editable        : false,
                    allowBlank      : false
                }
            }],
            border      : true,
            height      : 180,
            plugins     : Ext.create('Ext.grid.plugin.CellEditing', { clicksToEdit : 2 })
        });

        this.calendarStore.loadData(this.getCalendarData());
        this.callParent(arguments);
    },

    getCalendarData : function(){
        var result = [];
        Ext.Array.each(Gnt.data.Calendar.getAllCalendars(), function (cal) {
            result.push({ Id : cal.calendarId, Name : cal.name || cal.calendarId });
        });
        return result;
    }
});

Ext.define('Gnt.widget.calendar.AvailabilityGrid', {
    extend              : 'Ext.grid.Panel',

    requires            : [
        'Ext.Button',
        'Ext.data.Store',
        'Ext.grid.plugin.CellEditing',
        'Ext.MessageBox',
        'Gnt.data.Calendar',
        'Sch.util.Date'
    ],

    mixins              : ['Gnt.mixin.Localizable'],

    alias               : 'widget.calendaravailabilitygrid',

    // input
    calendarDay         : null,

    height              : 160,

    addButton           : null,
    removeButton        : null,

    maxIntervalsNum     : 5,

    /**
     * @cfg {String} startText The text to show in the start column header
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} endText The text to show in the end column header
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} addText The text to show on the add button
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} removeText The text to show on the remove button
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - startText         : 'Start',
            - endText           : 'End',
            - addText           : 'Add',
            - removeText        : 'Remove',
            - error             : 'Error'
     */

    initComponent : function() {

        Ext.applyIf(this, {
            store       : new Ext.data.Store({
                fields      : [ 'startTime', 'endTime' ],

                data        : this.calendarDay.getAvailability()
            }),

            plugins     : [ new Ext.grid.plugin.CellEditing({ clicksToEdit: 2 }) ],

            tbar        : this.buildToolbar(),
            columns     : [
                {
                    xtype       : 'datecolumn',
                    header      : this.L('startText'),

                    format      : 'g:i a',
                    dataIndex   : 'startTime',
                    flex        : 1,
                    editor      : { xtype: 'timefield', allowBlank: false, initDate: '31/12/1899' }
                },
                {
                    xtype       : 'datecolumn',
                    header      : this.L('endText'),

                    format      : 'g:i a',
                    dataIndex   : 'endTime',
                    flex        : 1,
                    editor      : { xtype: 'timefield', allowBlank: false, initDate: '31/12/1899' }
                }
            ],

            listeners : {
                selectionchange : this.onAvailabilityGridSelectionChange,
                scope           : this
            }
        });

        this.callParent(arguments);
    },

    buildToolbar : function() {
        this.addButton      = new Ext.Button({ text: this.L('addText'), iconCls: 'gnt-action-add', handler: this.addAvailability, scope: this });
        this.removeButton   = new Ext.Button({ text: this.L('removeText'), iconCls: 'gnt-action-remove', handler: this.removeAvailability, scope: this, disabled: true });

        return [
            this.addButton,
            this.removeButton
        ];
    },

    onAvailabilityGridSelectionChange : function (selection) {
        this.removeButton.setDisabled(!selection || selection.getSelection().length === 0);
    },


    setAvailability : function (availability) {
        this.store.loadData(availability);

        this.addButton.setDisabled(this.store.getCount() >= this.maxIntervalsNum);
    },


    addAvailability: function () {
        var store = this.getStore(),
            count = store.count();

        if (count >= this.maxIntervalsNum) {
            return;
        }

        store.add({
            startTime       : new Date(0, 0, 0, 12, 0),
            endTime         : new Date(0, 0, 0, 13, 0)
        });

        if (count + 1 >= this.maxIntervalsNum && this.addButton) {
            this.addButton.disable();
        }
    },


    removeAvailability: function() {
        var store       = this.getStore(),
            count       = store.getCount(),
            selection   = this.getSelectionModel().getSelection();

        if (selection.length === 0) {
            return;
        }

        store.remove(selection[ 0 ]);

        if (count < this.maxIntervalsNum && this.addButton) {
            this.addButton.enable();
        }
    },

    // output
    isValid: function (noMessage) {
        try {
            this.calendarDay.verifyAvailability(this.getIntervals());
        } catch (ex) {
            if (!noMessage) {
                Ext.MessageBox.show({
                    title       : this.L('error'),
                    msg         : ex,
                    modal       : true,
                    icon        : Ext.MessageBox.ERROR,
                    buttons     : Ext.MessageBox.OK
                });
            }

            return false;
        }

        return true;
    },


    extractTimeFromDate : function (date) {
        return new Date(0, 0, 0, date.getHours(), date.getMinutes(), date.getSeconds());
    },


    // output
    getIntervals : function () {
        var intervals   = [];
        var me          = this;

        this.getStore().each(function (item) {
            intervals.push({ startTime : me.extractTimeFromDate(item.get('startTime')), endTime : me.extractTimeFromDate(item.get('endTime')) });
        });

        return intervals;
    }
});

Ext.define('Gnt.widget.calendar.DayEditor', {
    extend      : 'Gnt.widget.calendar.AvailabilityGrid',

    requires    : [
        'Ext.grid.plugin.CellEditing',
        'Gnt.data.Calendar',
        'Sch.util.Date'
    ],

    mixins      : ['Gnt.mixin.Localizable'],

    alias       : 'widget.calendardayeditor',

    height      : 160,

    /**
     * @cfg {String} workingTimeText The text to use for the working time radio button
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {String} nonworkingTimeText The text to use for the non-working time radio button
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - startText           : 'Start',
            - endText             : 'End',
            - workingTimeText     : 'Working time',
            - nonworkingTimeText  : 'Non-working time'
     */

    initComponent : function() {

        var isWorkingDay        = this.calendarDay.getIsWorkingDay();

        Ext.applyIf(this, {
            dockedItems : [
                {
                    xtype       : 'radiogroup',
                    dock        : 'top',
                    name        : 'dayType',
                    padding     : "0 5px",
                    margin      : 0,
                    items       : [
                        { boxLabel : this.L('workingTimeText'), name: 'IsWorkingDay', inputValue : true, checked : isWorkingDay },
                        { boxLabel : this.L('nonworkingTimeText'), name: 'IsWorkingDay', inputValue : false, checked : !isWorkingDay }
                    ],

                    listeners   : {
                        change      : this.onDayTypeChanged,
                        scope       : this
                    }
                }
            ]
        });

        this.on('viewready', this.applyState, this);

        this.callParent(arguments);
    },


    getDayTypeRadioGroup : function(){
        return this.down('radiogroup[name="dayType"]');
    },


    applyState : function () {
        if (!this.isWorkingDay()) {
            this.getView().disable();
            this.addButton.disable();
        }
    },


    onDayTypeChanged : function(sender) {
        var value = sender.getValue();

        if (Ext.isArray(value.IsWorkingDay)) return;

        this.getView().setDisabled(!value.IsWorkingDay);

        this.addButton.setDisabled(!value.IsWorkingDay || this.getStore().getCount() >= this.maxIntervalsNum);
    },


    isWorkingDay : function() {
        return this.getDayTypeRadioGroup().getValue().IsWorkingDay;
    },


    isValid: function () {
        if (this.isWorkingDay()) return this.callParent();

        return true;
    },


    getIntervals : function () {
        if (!this.isWorkingDay()) return [];

        return this.callParent();
    }
});

Ext.define('Gnt.widget.calendar.WeekEditor', {
    extend                      : 'Ext.form.Panel',

    requires                    : [
        'Ext.grid.Panel',
        'Gnt.data.Calendar',
        'Sch.util.Date',
        'Gnt.widget.calendar.AvailabilityGrid'
    ],

    mixins                      : ['Gnt.mixin.Localizable'],

    alias                       : 'widget.calendarweekeditor',

    weekName                    : null,
    startDate                   : null,
    endDate                     : null,

    // the availability array for the week being edited
    weekAvailability            : null,

    // the `weekAvailability` of the calendar
    calendarWeekAvailability    : null,
    // the `defaultWeekAvailability` of the calendar
    defaultWeekAvailability     : null,

    backupWeekAvailability      : null,

    layout                      : 'anchor',

    defaults                    : { border: false, anchor: '100%' },

    /**
     * @cfg {String} defaultTimeText The text to use for the default time radio button
     * @deprecated Please use {@link #l10n l10n} instead.
    */
    /**
     * @cfg {String} workingTimeText The text to use for the working time radio button
     * @deprecated Please use {@link #l10n l10n} instead.
    */
    /**
     * @cfg {String} nonworkingTimeText The text to use for the non-working time radio button
     * @deprecated Please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - defaultTimeText    : 'Default time',
            - workingTimeText    : 'Working time',
            - nonworkingTimeText : 'Non-working time',
            - error              : 'Error',
            - noOverrideError    : "Week override contains only 'default' days - can't save it"
     */

    currentDayIndex         : null,

    _weekDaysGrid           : null,
    _availabilityGrid       : null,

    initComponent: function () {

        this.backupWeekAvailability     = [];

        this.items = [
            {
                xtype       : 'radiogroup',
                padding     : "0 5px",
                name        : 'dayType',
                items       : [
                    { boxLabel: this.L('defaultTimeText'), name: 'IsWorkingDay', inputValue: 0 },
                    { boxLabel: this.L('workingTimeText'), name: 'IsWorkingDay', inputValue: 1 },
                    { boxLabel: this.L('nonworkingTimeText'), name: 'IsWorkingDay', inputValue: 2 }
                ],
                listeners   : {
                    change      : this.onDayTypeChanged,
                    scope       : this
                }
            },
            {
                layout      : 'column',
                padding     : '0 0 5px 0',
                defaults    : { border: false },

                items       : [
                    {
                        margin          : '0 10px 0 5px',
                        columnWidth     : 0.5,
                        items           : this.getWeekDaysGrid()
                    },
                    {
                        columnWidth     : 0.5,
                        margin          : '0 5px 0 0',
                        items           : this.getAvailabilityGrid()
                    }
                ]
            }
        ];

        this.callParent(arguments);
    },


    getWeekDaysGrid: function () {
        if (this._weekDaysGrid != null) return this._weekDaysGrid;

        var DN = Ext.Date.dayNames;

        return this._weekDaysGrid = new Ext.grid.Panel({
            hideHeaders     : true,
            height          : 160,
            columns         : [{
                header          : '',
                dataIndex       : 'name',
                flex            : 1
            }],

            store           : new Ext.data.Store({
                fields          :['id', 'name'],
                idProperty      : 'id',
                data            : [
                    { id : 1, name: DN[1] },
                    { id : 2, name: DN[2] },
                    { id : 3, name: DN[3] },
                    { id : 4, name: DN[4] },
                    { id : 5, name: DN[5] },
                    { id : 6, name: DN[6] },
                    { id : 0, name: DN[0] }
                ]
            }),

            listeners: {
                viewready           : this.onWeekDaysListViewReady,
                selectionchange     : this.onWeekDaysListSelectionChange,
                beforeselect        : this.onWeekDaysListBeforeSelect,

                scope               : this
            }
        });
    },


    getAvailabilityGrid: function () {
        if (!this._availabilityGrid) {
            this._availabilityGrid = new Gnt.widget.calendar.AvailabilityGrid({
                calendarDay     : new Gnt.model.CalendarDay()
            });
        }

        return this._availabilityGrid;
    },


    getDayTypeRadioGroup : function () {
        if (!this.dayTypeRadioGroup) this.dayTypeRadioGroup = this.down('radiogroup[name="dayType"]');
        return this.dayTypeRadioGroup;
    },


    getWeekAvailability : function () {
        return this.weekAvailability;
    },


    onWeekDaysListViewReady : function () {
        var weekDaysGrid            = this.getWeekDaysGrid(),
            monday                  = weekDaysGrid.getStore().getAt(0);

        this.currentDayIndex        = monday.getId();

        this.readFromData();

        weekDaysGrid.getSelectionModel().select(monday, false, true);
    },


    onWeekDaysListBeforeSelect : function () {
        if (!this.saveToData()) return false;
    },


    applyChanges : function (toWeekAvailability) {
        if (!this.saveToData()) return false;

        var weekAvailability    = this.weekAvailability;

        var hasOverride         = false;

        for (var i = 0; i < 7; i++) {
            var currentAvailability = weekAvailability[ i ];

            if (currentAvailability) hasOverride = true;

            if (!currentAvailability) toWeekAvailability[ i ] = null;

            if (currentAvailability && !toWeekAvailability[ i ]) toWeekAvailability[ i ] = currentAvailability;

            if (currentAvailability && toWeekAvailability[ i ]) {
                toWeekAvailability[ i ].setIsWorkingDay(currentAvailability.getIsWorkingDay());
                toWeekAvailability[ i ].setAvailability(currentAvailability.getAvailability());
            }
        }

        if (!hasOverride) {
            Ext.MessageBox.show({
                title       : this.L('error'),
                msg         : this.L('noOverrideError'),
                modal       : true,
                icon        : Ext.MessageBox.ERROR,
                buttons     : Ext.MessageBox.OK
            });

            return false;
        }

        return true;
    },


    onWeekDaysListSelectionChange: function (view, records) {
        this.currentDayIndex            = records[ 0 ].getId();

        this.readFromData();
    },


    // 0 - default, 1 - working , 2 - non-working
    getCurrentTypeOfWeekDay : function (index) {
        return this.weekAvailability[ index ] ? (this.weekAvailability[ index ].getIsWorkingDay() ? 1 : 2) : 0;
    },


    getCurrentWeekDay : function (index) {
        return this.weekAvailability[ index ] || this.calendarWeekAvailability[ index ] || this.defaultWeekAvailability[ index ];
    },


    saveToData: function () {
        var currentDayIndex         = this.currentDayIndex;
        var type                    = this.getDayTypeRadioGroup().getValue().IsWorkingDay;

        var weekAvailability        = this.weekAvailability;

        // default day - remove the element from `weekAvailability`
        if (type === 0) {
            weekAvailability[ currentDayIndex ] = null;

            return true;
        }

        var availabilityGrid        = this.getAvailabilityGrid();

        // working day
        if (type == 1) {
            if (!availabilityGrid.isValid()) return false;

            if (!weekAvailability[ currentDayIndex ]) weekAvailability[ currentDayIndex ] = this.copyDefaultWeekDay(currentDayIndex);

            weekAvailability[ currentDayIndex ].setIsWorkingDay(true);
            weekAvailability[ currentDayIndex ].setAvailability(availabilityGrid.getIntervals());

            this.backupWeekAvailability[ currentDayIndex ] = null;

            return true;
        }

        // type == 2
        if (!weekAvailability[ currentDayIndex ]) weekAvailability[ currentDayIndex ] = this.copyDefaultWeekDay(currentDayIndex);

        weekAvailability[ currentDayIndex ].setIsWorkingDay(false);
        weekAvailability[ currentDayIndex ].setAvailability([]);

        return true;
    },


    copyDefaultWeekDay : function (index) {
        var copy        = (this.calendarWeekAvailability[ index ] || this.defaultWeekAvailability[ index ]).copy();

        copy.setType('WEEKDAYOVERRIDE');
        copy.setOverrideStartDate(this.startDate);
        copy.setOverrideEndDate(this.endDate);
        copy.setName(this.weekName);

        return copy;
    },


    readFromData : function (intervalsToRestore) {
        var day         = this.getCurrentWeekDay(this.currentDayIndex);
        var type        = this.getCurrentTypeOfWeekDay(this.currentDayIndex);

        var grid = this.getAvailabilityGrid();
        grid.setAvailability(intervalsToRestore || day.getAvailability());

        var group = this.getDayTypeRadioGroup();
        group.suspendEvents();
        group.setValue({ IsWorkingDay: [ type ] });
        group.resumeEvents();

        grid.setDisabled(type != 1);
    },


    onDayTypeChanged : function (sender, newValue, oldValue) {
        var value       = sender.getValue();

        // ignore case when no radio buttons selected?
        // weird call with empty object as "newValue"
        if (value.IsWorkingDay == null || Ext.isArray(value.IsWorkingDay)) return;

        var weekAvailability            = this.weekAvailability;
        var backupWeekAvailability      = this.backupWeekAvailability;
        var currentDayIndex             = this.currentDayIndex;

        var availabilityGrid            = this.getAvailabilityGrid();

        var intervalsToRestore;

        if (oldValue.IsWorkingDay == 1) backupWeekAvailability[ currentDayIndex ] = availabilityGrid.getIntervals();

        switch (value.IsWorkingDay) {
            case 0:
                weekAvailability[ currentDayIndex ] = null;
            break;

            case 1:
                if (!weekAvailability[ currentDayIndex ]) weekAvailability[ currentDayIndex ] = this.copyDefaultWeekDay(currentDayIndex);

                intervalsToRestore = backupWeekAvailability[ currentDayIndex ];

                weekAvailability[ currentDayIndex ].setIsWorkingDay(true);
            break;

            case 2:
                if (!weekAvailability[ currentDayIndex ]) weekAvailability[ currentDayIndex ] = this.copyDefaultWeekDay(currentDayIndex);

                weekAvailability[ currentDayIndex ].setAvailability([]);
                weekAvailability[ currentDayIndex ].setIsWorkingDay(false);
            break;

            default:
                throw "Unrecognized day type";
        }

        this.readFromData(intervalsToRestore);
    }
});

Ext.define('Gnt.widget.calendar.DatePicker', {
    extend      : 'Ext.picker.Date',

    alias       : 'widget.gntdatepicker',

    
    workingDayCls           : 'gnt-datepicker-workingday',
    nonWorkingDayCls        : 'gnt-datepicker-nonworkingday',
    overriddenDayCls        : 'gnt-datepicker-overriddenday',
    overriddenWeekDayCls    : 'gnt-datepicker-overriddenweekday',
    
    weekOverridesStore      : null,
    dayOverridesCalendar    : null,


    // @OVERRIDE
    // Adds custom classes to certain day cells
    update : function () {
        this.callParent(arguments);
        
        this.refreshCssClasses();
    },
    
    
    refreshCssClasses : function () {
        var me      = this,
            cells   = me.cells.elements;
            
        this.removeCustomCls();
        
        for (var i = 0; i < me.numDays; i++) {
            // will contain number of ms since Epoch, so need to convert it into Date on the next line
            var date                = cells[ i ].firstChild.dateValue;
            cells[ i ].className    += ' ' + this.getDateCls(new Date(date));
        }
    },

    
    getDateCls : function (date) {
        var cls         = "";
        
        if (date.getMonth() !== this.getActive().getMonth()) return;
        
        var dayOverridesCalendar   = this.dayOverridesCalendar;

        if (dayOverridesCalendar.getOwnCalendarDay(date)) {
            cls         += " " + this.overriddenDayCls;

            if (!dayOverridesCalendar.isWorkingDay(date)) cls += " " + this.nonWorkingDayCls;
            
        } else {
            // this will be an internal week override model instance from the weekStore
            var week    = null;
            
            this.weekOverridesStore.each(function (internalWeekModel) {
                if (Ext.Date.between(date, internalWeekModel.get('startDate'), internalWeekModel.get('endDate'))) {
                    week = internalWeekModel;
                    return false;
                }
            });

            if (week) {
                cls                     += " " + this.overriddenWeekDayCls;

                var index               = date.getDay(),
                    weekAvailability    = week.get('weekAvailability');

                if (weekAvailability && weekAvailability[ index ] && !weekAvailability[ index ].getIsWorkingDay()) {
                    cls                 += " " + this.nonWorkingDayCls;
                }
                
            } else if (!dayOverridesCalendar.isWorkingDay(date)) {
                cls                     += " " + this.nonWorkingDayCls;
            }
        }

        return cls || this.workingDayCls;
    },

    
    removeCustomCls : function(){
        this.cells.removeCls([ this.overriddenDayCls, this.nonWorkingDayCls, this.workingDayCls, this.overriddenWeekDayCls ]);
    }
});
/**

@class Gnt.widget.calendar.Calendar
@extends Ext.form.Panel
@aside guide gantt_calendars

{@img gantt/images/calendar.png}

This widget can be used to edit the calendar content. As the input it should receive an instance of the {@link Gnt.data.Calendar} class.
Once the editing is done and user is happy with the result the {@link #applyChanges} method should be called. It will apply
all the changes user made in UI to the calendar.

Note, this widget does not have the "Ok", "Apply changes" etc button intentionally, as you might want to combine it with your widgets.
See {@link Gnt.widget.calendar.CalendarWindow} for this widget embedded in the Ext.window.Window instance.


*/
Ext.define('Gnt.widget.calendar.Calendar', {
    extend                      : 'Ext.form.Panel',

    requires                    : [
        'Ext.XTemplate',
        'Ext.data.Store',
        'Ext.grid.Panel',
        'Ext.grid.plugin.CellEditing',
        'Gnt.data.Calendar',
        'Gnt.model.CalendarDay',
        'Gnt.widget.calendar.DayEditor',
        'Gnt.widget.calendar.WeekEditor',
        'Gnt.widget.calendar.DatePicker'
    ],

    mixins                      : ['Gnt.mixin.Localizable'],

    alias                       : 'widget.calendar',

    defaults                    : { padding: 10, border: false },

    /**
     * @cfg {String} css class will be applied to all working days at legend block and datepicker
     */
    workingDayCls               : 'gnt-datepicker-workingday',

    /**
     * @cfg {string} css class will be applied to all non-working days at legend block and datepicker
     */
    nonWorkingDayCls            : 'gnt-datepicker-nonworkingday',

    /**
     * @cfg {String} css class will be applied to all overridden days at legend block and datepicker
     */
    overriddenDayCls            : 'gnt-datepicker-overriddenday',

    /**
     * @cfg {String} css class will be applied to all overridden days inside overridden week at legend block and date picker
     */
    overriddenWeekDayCls        : 'gnt-datepicker-overriddenweekday',

    /**
     * @cfg {Gnt.data.Calendar} calendar An instance of the {@link Gnt.data.Calendar} to read/change the holidays from/in.
     */
    calendar                    : null,

    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

        - dayOverrideNameHeaderText : 'Name',
        - overrideName        : 'Name',
        - startDate           : 'Start Date',
        - endDate             : 'End Date',
        - error               : 'Error',
        - dateText            : 'Date',
        - addText             : 'Add',
        - editText            : 'Edit',
        - removeText          : 'Remove',
        - workingDayText      : 'Working day',
        - weekendsText        : 'Weekends',
        - overriddenDayText   : 'Overridden day',
        - overriddenWeekText  : 'Overridden week',
        - workingTimeText     : 'Working time',
        - nonworkingTimeText  : 'Non-working time',
        - dayOverridesText    : 'Day overrides',
        - weekOverridesText   : 'Week overrides',
        - okText              : 'OK',
        - cancelText          : 'Cancel',
        - parentCalendarText  : 'Parent calendar',
        - noParentText        : 'No parent',
        - selectParentText    : 'Select parent',
        - newDayName          : '[Without name]',
        - calendarNameText    : 'Calendar name',
        - tplTexts            : {
            - tplWorkingHours : 'Working hours for',
            - tplIsNonWorking : 'is non-working',
            - tplOverride     : 'override',
            - tplInCalendar   : 'in calendar',
            - tplDayInCalendar: 'standard day in calendar'
        },
        - overrideErrorText   : 'There is already an override for this day',
        - overrideDateError   : 'There is already week override on this date: {0}',
        - startAfterEndError  : 'Start date should be less than end date',
        - weeksIntersectError : 'Week overrides should not intersect'
     */
    /**
     * @cfg {String} dayOverrideNameHeaderText The text to show in the day override name column header
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} dateText The text to show in the date column header
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} addText The text to show on the add button
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} editText The text to show on the edit button
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} removeText The text to show on the remove button
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} workingDayText The "working day" text to include in the calendar legend.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} weekendsText The "weekends" text to in the calendar legend.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} overriddenDayText The "Overridden day" text to in the calendar legend.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} overriddenWeekText The "Overridden week" text to in the calendar legend.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} workingTimeText The text to use for the working time radio button
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} nonworkingTimeText The text to use for the non-working time radio button
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} dayOverridesText The text to show in the day overrides tab panel title and edit window title.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} weekOverridesText The text to show in the week overrides tab panel title and edit window title.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} okText The text to show in the OK button
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} cancelText The text to show in the Cancel button
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} calendarNameText The text to show before the calendar name in the form.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {Object} tplTexts The texts used in the date info template
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} parentCalendarText Label for the parent calendar field
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} noParentText Text shown when no parent calendar selected
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} selectParentText Empty text for the parent calendar combo field.
     * @deprecated Please use {@link #l10n} instead.
     */
    /**
     * @cfg {String} newDayName Name for a new day override.
     * @deprecated Please use {@link #l10n} instead.
     */

    /**
     * @cfg {Object} dayGridConfig A custom config object to use when configuring the Gnt.widget.calendar.DayGrid instance.
     */
    dayGridConfig               : null,

    /**
     * @cfg {Object} weekGridConfig A custom config object to use when configuring the Gnt.widget.calendar.WeekGrid instance.
     */
    weekGridConfig              : null,

    /**
     * @cfg {Object} datePickerConfig A custom config object to use when configuring the Gnt.widget.calendar.DatePicker instance.
     */
    datePickerConfig            : null,

    /**
     * @cfg {String} overrideErrorText Text for error shown when an attempt to override
     * an already overridden day is being made.
     */

    dayGrid                     : null,
    weekGrid                    : null,
    datePicker                  : null,

    legendTpl                   : '<ul class="gnt-calendar-legend">' +
            '<li class="gnt-calendar-legend-item">' +
                '<div class="gnt-calendar-legend-itemstyle {workingDayCls}"></div>' +
                '<span class="gnt-calendar-legend-itemname">{workingDayText}</span>' +
                '<div style="clear: both"></div>' +
            '</li>' +
            '<li>' +
                '<div class="gnt-calendar-legend-itemstyle {nonWorkingDayCls}"></div>' +
                '<span class="gnt-calendar-legend-itemname">{weekendsText}</span>' +
                '<div style="clear: both"></div>' +
            '</li>' +
            '<li class="gnt-calendar-legend-override">' +
                '<div class="gnt-calendar-legend-itemstyle {overriddenDayCls}">31</div>' +
                '<span class="gnt-calendar-legend-itemname">{overriddenDayText}</span>' +
                '<div style="clear: both"></div>' +
            '</li>' +
            '<li class="gnt-calendar-legend-override">' +
                '<div class="gnt-calendar-legend-itemstyle {overriddenWeekDayCls}">31</div>' +
                '<span class="gnt-calendar-legend-itemname">{overriddenWeekText}</span>' +
                '<div style="clear: both"></div>' +
            '</li>' +
        '</ul>',

    dateInfoTpl                 : null,

    dayOverridesCalendar        : null,
    weekOverridesStore          : null,

    copiesIndexByOriginalId     : null,

    getDayGrid : function() {
        if (!this.dayGrid) {
            var calendarDayModel        = this.calendar.model.prototype;

            // create day overrides grid
            this.dayGrid = new Ext.grid.Panel(Ext.apply({
                title       : this.L('dayOverridesText'),
                tbar        : [
                    { text: this.L('addText'), action: 'add', iconCls: 'gnt-action-add', handler: this.addDay, scope: this },
                    { text: this.L('editText'), action: 'edit', iconCls: 'gnt-action-edit', handler: this.editDay, scope: this },
                    { text: this.L('removeText'), action: 'remove', iconCls: 'gnt-action-remove', handler: this.removeDay, scope: this }
                ],
                store       : new Gnt.data.Calendar(),
                plugins     : [ new Ext.grid.plugin.CellEditing({ clicksToEdit : 2 }) ],
                columns     : [
                    {
                        header      : this.L('dayOverrideNameHeaderText'),
                        dataIndex   : calendarDayModel.nameField,
                        flex        : 1,
                        editor      : { allowBlank : false }
                    },
                    {
                        header      : this.L('dateText'),
                        dataIndex   : calendarDayModel.dateField,
                        width       : 100,
                        xtype       : 'datecolumn',
                        editor      : { xtype : 'datefield' }
                    }
                ]
            }, this.dayGridConfig || {}));

            this.dayOverridesCalendar   = this.dayGrid.store;
        }

        return this.dayGrid;
    },


    getWeekGrid : function() {
        if (!this.weekGrid) {
            // create week overrides grid
            this.weekGrid = new Ext.grid.Panel(Ext.apply({
                title       : this.L('weekOverridesText'),
                border      : true,

                plugins     : [ new Ext.grid.plugin.CellEditing({ clicksToEdit : 2 }) ],

                store       : new Ext.data.Store({
                    fields      : [ 'name', 'startDate', 'endDate', 'weekAvailability', 'mainDay' ]
                }),

                tbar        : [
                    { text: this.L('addText'), action: 'add', iconCls: 'gnt-action-add', handler: this.addWeek, scope: this },
                    { text: this.L('editText'), action: 'edit', iconCls: 'gnt-action-edit', handler: this.editWeek, scope: this },
                    { text: this.L('removeText'), action: 'remove', iconCls: 'gnt-action-remove', handler: this.removeWeek, scope: this }
                ],

                columns     : [
                    {
                        header      : this.L('overrideName'),
                        dataIndex   : 'name',
                        flex        : 1,
                        editor      : { allowBlank : false }
                    },
                    {
                        xtype       : 'datecolumn',
                        header      : this.L('startDate'),
                        dataIndex   : 'startDate',
                        width       : 100,
                        editor      : { xtype : 'datefield' }
                    },
                    {
                        xtype       : 'datecolumn',
                        header      : this.L('endDate'),
                        dataIndex   : 'endDate',
                        width       : 100,
                        editor      : { xtype : 'datefield' }
                    }
                ]

            }, this.weekGridConfig || {}));

            this.weekOverridesStore     = this.weekGrid.store;
        }

        return this.weekGrid;
    },


    getDatePicker : function() {
        if (!this.datePicker) {
            this.datePicker = new Gnt.widget.calendar.DatePicker(Ext.apply({
                dayOverridesCalendar    : this.getDayGrid().store,
                weekOverridesStore      : this.getWeekGrid().store
            }, this.datePickerConfig));
        }

        return this.datePicker;
    },


    initComponent : function() {

        this.copiesIndexByOriginalId        = {};

        var me = this;

        me.setupTemplates();

        if (!(this.legendTpl instanceof Ext.Template))      this.legendTpl      = new Ext.XTemplate(this.legendTpl);
        if (!(this.dateInfoTpl instanceof Ext.Template))    this.dateInfoTpl    = new Ext.XTemplate(this.dateInfoTpl);

        var calendar        = this.calendar;

        if (!calendar) {
            Ext.Error.raise('Required attribute "calendar" is missed during initialization of `Gnt.widget.Calendar`');
        }

        var weekGrid        = this.getWeekGrid(),
            dayGrid         = this.getDayGrid(),
            datePicker      = this.getDatePicker();

        dayGrid.on({
            selectionchange : this.onDayGridSelectionChange,
            validateedit    : this.onDayGridValidateEdit,
            edit            : this.onDayGridEdit,
            scope           : this
        });

        dayGrid.store.on({
            update          : this.refreshView,
            remove          : this.refreshView,
            add             : this.refreshView,
            scope           : this
        });

        weekGrid.on({
            selectionchange : this.onWeekGridSelectionChange,
            validateedit    : this.onWeekGridValidateEdit,
            edit            : this.onWeekGridEdit,
            scope           : this
        });

        weekGrid.store.on({
            update          : this.refreshView,
            remove          : this.refreshView,
            add             : this.refreshView,
            scope           : this
        });

        datePicker.on({
            select          : this.onDateSelect,
            scope           : this
        });

        this.fillDaysStore();
        this.fillWeeksStore();

        this.mon(calendar, {
            load    : this.onCalendarChange,
            add     : this.onCalendarChange,
            remove  : this.onCalendarChange,
            update  : this.onCalendarChange,
            scope   : this
        });

        this.dateInfoPanel = new Ext.Panel({
            cls             : 'gnt-calendar-dateinfo',
            columnWidth     : 0.33,
            border          : false,
            height          : 200
        });

        this.items = [
            {
                xtype       : 'container',
                layout      : 'hbox',
                pack        : 'start',
                align       : 'stretch',
                items       : [
                    {
                        html            : Ext.String.format('{0}: "{1}"', this.L('calendarNameText'), calendar.name),
                        border          : false,
                        flex            : 1
                    },
                    {
                        xtype           : 'combobox',
                        name            : 'cmb_parentCalendar',
                        fieldLabel      : this.L('parentCalendarText'),

                        store           : new Ext.data.Store({
                            fields  : [ 'Id', 'Name' ],
                            data    : [ { Id : -1, Name : this.L('noParentText') } ].concat(calendar.getParentableCalendars())
                        }),

                        queryMode       : 'local',
                        displayField    : 'Name',
                        valueField      : 'Id',

                        editable        : false,
                        emptyText       : this.L('selectParentText'),

                        value           : calendar.parent ? calendar.parent.calendarId : -1,
                        flex            : 1
                    }
                ]
            },
            {
                layout      : 'column',
                defaults    : { border : false },
                items       : [
                    {
                        margin          : '0 15px 0 0',
                        columnWidth     : 0.3,
                        html            : this.legendTpl.apply({
                            workingDayText          : this.L('workingDayText'),
                            weekendsText            : this.L('weekendsText'),
                            overriddenDayText       : this.L('overriddenDayText'),
                            overriddenWeekText      : this.L('overriddenWeekText'),
                            workingDayCls           : this.workingDayCls,
                            nonWorkingDayCls        : this.nonWorkingDayCls,
                            overriddenDayCls        : this.overriddenDayCls,
                            overriddenWeekDayCls    : this.overriddenWeekDayCls
                        })
                    },
                    {
                        columnWidth     : 0.37,
                        margin          : '0 5px 0 0',
                        items           : [ datePicker ]
                    },
                    this.dateInfoPanel
                ]
            },
            {
                xtype       : 'tabpanel',
                height      : 220,
                items       : [ dayGrid, weekGrid ]
            }
        ];

        this.callParent(arguments);
    },

    onCalendarChange : function() {
        this.fillDaysStore();
        this.fillWeeksStore();
        this.refreshView();
    },

    setupTemplates : function () {
        var tplTexts    = this.L('tplTexts');

        this.dateInfoTpl = this.dateInfoTpl || Ext.String.format(
            '<tpl if="isWorkingDay == true"><div>{0} {date}:</div></tpl>' +
            '<tpl if="isWorkingDay == false"><div>{date} {1}</div></tpl>' +
            '<ul class="gnt-calendar-availabilities"><tpl for="availability"><li>{.}</li></tpl></ul>' +
            '<span>{5}: ' +
                '<tpl if="override == true">{2} "{name}" {3} "{calendarName}"</tpl><tpl if="override == false">{4} "{calendarName}"</tpl>' +
            '</span>',
            tplTexts.tplWorkingHours,
            tplTexts.tplIsNonWorking,
            tplTexts.tplOverride,
            tplTexts.tplInCalendar,
            tplTexts.tplDayInCalendar,
            tplTexts.tplBasedOn
        );
    },

    afterRender : function() {
        this.callParent(arguments);

        this.onDateSelect(this.getDatePicker(), new Date());
    },


    fillDaysStore : function() {
        // only filter days with type "DAY" that has "Date" set
        var dataTemp        = Gnt.util.Data.cloneModelSet(this.calendar, function (calendarDay) {
            return (calendarDay.getType() == 'DAY' && calendarDay.getDate());
        });

        this.dayOverridesCalendar.loadData(dataTemp);
    },


    copyCalendarDay : function (calendarDay) {
        var copy            = calendarDay.copy();

        copy.__COPYOF__     = calendarDay.internalId;

        this.copiesIndexByOriginalId[ calendarDay.internalId ]   = copy.internalId;

        return copy;
    },


    fillWeeksStore : function () {
        var me              = this;
        var data            = [];

        this.calendar.forEachNonStandardWeek(function (nonStandardWeek) {
            var week                = Ext.apply({}, nonStandardWeek);

            week.weekAvailability   = Ext.Array.map(week.weekAvailability, function (day) {
                return day && me.copyCalendarDay(day) || null;
            });

            week.mainDay            = me.copyCalendarDay(week.mainDay);

            data.push(week);
        });

        this.weekOverridesStore.loadData(data);
    },


    addDay : function(){
        var date        = this.getDatePicker().getValue();

        // do not allow duplicate day overrides
        if (this.dayOverridesCalendar.getOwnCalendarDay(date)) {
            this.alert({ msg : this.L('overrideErrorText') });
            return;
        }

        var newDay      = Ext.create('Gnt.model.CalendarDay', {
            Name            : this.L('newDayName'),
            Type            : 'DAY',
            Date            : date,
            IsWorkingDay    : false
        });

        this.dayOverridesCalendar.insert(0, newDay);
        this.getDayGrid().getSelectionModel().select([ newDay ], false, false);
    },


    editDay : function(){
        var me          = this,
            selection   = this.getDayGrid().getSelectionModel().getSelection();

        if (selection.length === 0) return;

        var day         = selection[ 0 ];

        var editor      = new Gnt.widget.calendar.DayEditor({
            addText             : this.L('addText'),
            removeText          : this.L('removeText'),
            workingTimeText     : this.L('workingTimeText'),
            nonworkingTimeText  : this.L('nonworkingTimeText'),

            calendarDay         : day
        });

        var editorWindow      = Ext.create('Ext.window.Window', {
            title           : this.L('dayOverridesText'),
            modal           : true,

            width           : 280,
            height          : 260,

            layout          : 'fit',
            items           : editor,

            buttons         : [
                {
                    text        : this.L('okText'),
                    handler     : function () {
                        if (editor.isValid()) {
                            var calendarDay = editor.calendarDay;

                            calendarDay.setIsWorkingDay(editor.isWorkingDay());
                            calendarDay.setAvailability(editor.getIntervals());

                            me.applyCalendarDay(calendarDay, day);

                            me.refreshView();

                            editorWindow.close();
                        }
                    }
                },
                {
                    text        : this.L('cancelText'),
                    handler     : function () {
                        editorWindow.close();
                    }
                }
            ]
        });

        editorWindow.show();
    },


    removeDay : function () {
        var grid        = this.getDayGrid(),
            selection   = grid.getSelectionModel().getSelection();

        if (!selection.length) return;

        grid.getStore().remove(selection[0]);

        this.refreshView();
    },


    refreshView : function () {
        var date        = this.getDatePicker().getValue(),
            day         = this.getCalendarDay(date),
            weekGrid    = this.getWeekGrid(),
            dayGrid     = this.getDayGrid(),
            dayOverride = this.dayOverridesCalendar.getOwnCalendarDay(date),
            weekOverride;

        var name;

        // First check if there is an override on day level
        if (dayOverride) {
            dayGrid.getSelectionModel().select([ dayOverride ], false, true);
            name        = dayOverride.getName();
        } else {
            // Now check if there is an override on week level
            weekOverride = this.getWeekOverrideByDate(date);
            if (weekOverride) {
                weekGrid.getSelectionModel().select([ weekOverride ], false, true);
                name    = weekOverride.get('name');
            }
        }

        var dayData = {
            name            : name || day.getName(),
            date            : Ext.Date.format(date, 'M j, Y'),
            calendarName    : this.calendar.name || this.calendar.calendarId,
            availability    : day.getAvailability(true),
            override        : Boolean(dayOverride || weekOverride),
            isWorkingDay    : day.getIsWorkingDay()
        };

        this.dateInfoPanel.update(this.dateInfoTpl.apply(dayData));

        this.datePicker.refreshCssClasses();
    },


    onDayGridSelectionChange : function (selection) {
        if (selection.getSelection().length === 0) return;

        var day     = selection.getSelection()[ 0 ];

        this.getDatePicker().setValue(day.getDate());
        this.refreshView();
    },


    onDayGridEdit : function (editor, context){
        if (context.field === 'Date') {
            context.grid.getStore().clearCache();
            this.getDatePicker().setValue(context.value);
        }

        this.refreshView();
    },


    onDayGridValidateEdit : function (editor, context){
        var calendar = this.getDayGrid().store;

        if (context.field === calendar.model.prototype.dateField && calendar.getOwnCalendarDay(context.value) && context.value !== context.originalValue) {
            this.alert({ msg : this.L('overrideErrorText') });
            return false;
        }
    },


    onDateSelect : function (picker, date) {
        this.refreshView();
    },


    getCalendarDay: function (date) {
        var day     = this.dayOverridesCalendar.getOwnCalendarDay(date);

        if (day) return day;

        day         = this.getWeekOverrideDay(date);

        if (day) return day;

        return this.calendar.weekAvailability[ date.getDay() ] || this.calendar.defaultWeekAvailability[ date.getDay() ];
    },


    getWeekOverrideDay : function (date) {
        var dateTime            = new Date(date),
            internalWeekModel   = this.getWeekOverrideByDate(date),
            index               = dateTime.getDay();

        if (internalWeekModel == null) return null;

        var weekAvailability = internalWeekModel.get('weekAvailability');

        if (!weekAvailability) return null;

        return weekAvailability[ index ];
    },


    getWeekOverrideByDate: function(date) {
        var week = null;

        this.weekOverridesStore.each(function (internalWeekModel) {
            if (Ext.Date.between(date, internalWeekModel.get('startDate'), internalWeekModel.get('endDate'))) {
                week = internalWeekModel;
                return false;
            }
        });

        return week;
    },


    intersectsWithCurrentWeeks : function (startDate, endDate, except) {
        var result                          = false;

        this.weekOverridesStore.each(function (internalWeekModel) {
            if (internalWeekModel == except) return;

            var weekStartDate       = internalWeekModel.get('startDate');
            var weekEndDate         = internalWeekModel.get('endDate');

            if (weekStartDate <= startDate && startDate < weekEndDate || weekStartDate < endDate && endDate <= weekEndDate) {
                result      = true;

                // stop the iteration
                return false;
            }
        });

        return result;
    },


    addWeek : function () {
        var weekOverridesStore      = this.weekOverridesStore;
        var startDate               = this.getDatePicker().getValue();
        var endDate;

        // we are about to create a week override and we need to make sure it does not
        // intersect with already created week overrides. Also we'd like to make it 1w long initially
        // but in case there will be an intersection with current overrides we are ok to shorten it
        for (var duration = 7; duration > 0; duration--) {
            endDate     = Sch.util.Date.add(startDate, Sch.util.Date.DAY, duration);

            if (!this.intersectsWithCurrentWeeks(startDate, endDate)) break;
        }

        if (!duration) {
            this.alert({ msg : Ext.String.format(this.L('overrideDateError'), Ext.Date.format(startDate, 'Y/m/d')) });
            return;
        }

        var mainDay     = new this.calendar.model();

        mainDay.setType('WEEKDAYOVERRIDE');
        mainDay.setName(this.L('newDayName'));
        mainDay.setOverrideStartDate(startDate);
        mainDay.setOverrideEndDate(endDate);
        mainDay.setWeekday(-1);

        var newWeek                 = weekOverridesStore.insert(0, {
            name                : this.L('newDayName'),
            startDate           : startDate,
            endDate             : endDate,

            weekAvailability    : [],
            mainDay             : mainDay
        })[ 0 ];

        this.getWeekGrid().getSelectionModel().select([ newWeek ], false, false);
    },


    editWeek : function(){
        var selection   = this.getWeekGrid().getSelectionModel().getSelection(),
            me          = this;

        if (selection.length === 0) return;

        var weekModel   = selection[ 0 ];

        var editor      = new Gnt.widget.calendar.WeekEditor({
            startDate                   : weekModel.get('startDate'),
            endDate                     : weekModel.get('endDate'),
            weekName                    : weekModel.get('name'),

            // keep the "weekModel" private and pass individual fields to the editor
            weekAvailability            : weekModel.get('weekAvailability'),
            calendarWeekAvailability    : this.calendar.weekAvailability,
            defaultWeekAvailability     : this.calendar.defaultWeekAvailability
        });

        var editorWindow    = Ext.create('Ext.window.Window', {
            title       : this.L('weekOverridesText'),
            modal       : true,
            width       : 370,
            defaults    : { border : false },

            layout      : 'fit',
            items       : editor,

            buttons     : [
                {
                    // this property will be used in test to locate the button
                    action      : 'ok',

                    text        : this.L('okText'),
                    handler     : function () {
                        if (editor.applyChanges(weekModel.get('weekAvailability'))) {
                            me.refreshView();
                            editorWindow.close();
                        }
                    }
                },
                {
                    text        : this.L('cancelText'),
                    handler     : function() {
                        editorWindow.close();
                    }
                }
            ]
        });

        editorWindow.show();
    },


    removeWeek: function () {
        var selection   = this.getWeekGrid().getSelectionModel().getSelection(),
            me          = this;

        if (selection.length === 0) return;

        this.weekOverridesStore.remove(selection[ 0 ]);

        this.refreshView();
    },


    onWeekGridSelectionChange : function (selModel){
        var selection       = selModel.getSelection();

        if (selection.length === 0) return;

        this.getDatePicker().setValue(selection[ 0 ].get('startDate'));
    },


    onWeekGridEdit : function (editor, context){
        var weekModel       = context.record,
            startDate       = weekModel.get('startDate'),
            endDate         = weekModel.get('endDate');

        if (context.field == 'startDate' || context.field == 'endDate') {
            Ext.Array.each(weekModel.get('weekAvailability').concat(weekModel.get('mainDay')), function (weekDay) {
                if (weekDay) {
                    weekDay.setOverrideStartDate(startDate);
                    weekDay.setOverrideEndDate(endDate);
                }
            });

            this.getDatePicker().setValue(startDate);
        }

        if (context.field == 'name') {
            Ext.Array.each(weekModel.get('weekAvailability').concat(weekModel.get('mainDay')), function (weekDay) {
                if (weekDay) {
                    weekDay.setName(weekModel.get('name'));
                }
            });
        }

        this.refreshView();
    },

    alert : function (config) {
        config = config || {};

        Ext.MessageBox.show(Ext.applyIf(config, {
            title       : this.L('error'),
            icon        : Ext.MessageBox.WARNING,
            buttons     : Ext.MessageBox.OK
        }));
    },

    onWeekGridValidateEdit : function (editor, context) {
        var weekModel            = context.record,
            startDate            = context.field == 'startDate' ? context.value : weekModel.get('startDate'),
            endDate              = context.field == 'endDate' ? context.value : weekModel.get('endDate');

        if (startDate > endDate) {
            this.alert({ msg : this.L('startAfterEndError') });
            return false;
        }

        if (this.intersectsWithCurrentWeeks(startDate, endDate, weekModel)) {
            this.alert({ msg : this.L('weeksIntersectError') });
            return false;
        }
    },


    applyCalendarDay : function (from, to){
        to.beginEdit();

        to.setId(from.getId());
        to.setName(from.getName());
        to.setIsWorkingDay(from.getIsWorkingDay());
        to.setDate(from.getDate());
        to.setOverrideStartDate(from.getOverrideStartDate());
        to.setOverrideEndDate(from.getOverrideEndDate());

        var fromAvailability    = from.getAvailability(true);
        var toAvailability      = to.getAvailability(true);

        if (fromAvailability + '' != toAvailability + '') to.setAvailability(from.getAvailability());

        to.endEdit();
    },


    applySingleDay : function (copyDay, toAdd) {
        if (copyDay.__COPYOF__)
            this.applyCalendarDay(copyDay, this.calendar.getByInternalId(copyDay.__COPYOF__));
        else {
            copyDay.unjoin(copyDay.stores[ 0 ]);
            toAdd.push(copyDay);
        }
    },


    /**
     * Call this method when user is satisfied with the current state of the calendar in the UI. It will apply all the changes made in the UI
     * to the original calendar.
     *
     */
    applyChanges : function () {
        var me              = this;
        var calendar        = this.calendar;
        var parent          = this.down('combobox[name="cmb_parentCalendar"]').getValue();

        calendar.suspendEvents(true);
        calendar.suspendCacheUpdate++;

        calendar.setParent(parent ? Gnt.data.Calendar.getCalendar(parent) : null);

        calendar.proxy.extraParams.calendarId   = calendar.calendarId;

        // days part
        Gnt.util.Data.applyCloneChanges(this.dayOverridesCalendar, calendar);

        var daysToAdd               = [];
        var daysToRemove            = [];
        var remainingWeekDays       = {};

        // weeks part
        this.weekOverridesStore.each(function (weekModel) {
            Ext.Array.each(weekModel.get('weekAvailability').concat(weekModel.get('mainDay')), function (weekDay) {
                if (weekDay) {
                    if (weekDay.__COPYOF__) remainingWeekDays[ weekDay.__COPYOF__ ] = true;

                    me.applySingleDay(weekDay, daysToAdd);
                }
            });
        });

        calendar.forEachNonStandardWeek(function (originalWeek) {
            Ext.Array.each(originalWeek.weekAvailability.concat(originalWeek.mainDay), function (originalWeekDay) {
                if (originalWeekDay && !remainingWeekDays[ originalWeekDay.internalId ]) daysToRemove.push(originalWeekDay);
            });
        });

        calendar.add(daysToAdd);
        calendar.remove(daysToRemove);

        calendar.suspendCacheUpdate--;
        calendar.resumeEvents();

        calendar.clearCache();
    }
});

/**

@class Gnt.widget.calendar.CalendarWindow
@extends Ext.window.Window
@aside guide gantt_calendars

{@img gantt/images/calendar.png}

This is just a {@link Gnt.widget.calendar.Calendar} widget, wrapped with the Ext.window.Window instance.
It proxies the {@link #calendar} config and {@link #applyChanges} method.

*/
Ext.define('Gnt.widget.calendar.CalendarWindow', {
    extend          : 'Ext.window.Window',

    requires        : ['Gnt.widget.calendar.Calendar'],

    mixins          : ['Gnt.mixin.Localizable'],

    alias           : 'widget.calendarwindow',

    /**
     * @cfg {Object} calendarConfig An object to be applied to the newly created instance of the {@link Gnt.widget.calendar.Calendar}
     */
    calendarConfig  : null,

    /**
     * @cfg {Gnt.data.Calendar} calendar An instance of the {@link Gnt.data.Calendar} to read/change the holidays from/in.
     */
    calendar        : null,

    /**
     * @property {Gnt.widget.calendar.Calendar} calendarWidget An underlying calendar widget instance
     */
    calendarWidget  : null,

    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - ok         : 'Ok',
            - cancel     : 'Cancel',
     */

    initComponent   : function () {
        Ext.apply(this, {
            width       : 600,

            layout      : 'fit',

            items       : this.calendarWidget = new Gnt.widget.calendar.Calendar(Ext.apply({
                calendar        : this.calendar
            }, this.calendarConfig)),

            buttons     : [
                {
                    text        : this.L('ok'),
                    handler     : function () {
                        this.applyChanges();
                        this.close();
                    },
                    scope       : this
                },
                {
                    text        : this.L('cancel'),
                    handler     : this.close,
                    scope       : this
                }
            ]
        });

        this.callParent(arguments);
    },


    /**
     * Call this method when user is satisfied with the current state of the calendar in the UI. It will apply all the changes made in the UI
     * to the original calendar.
     */
    applyChanges : function () {
        this.calendarWidget.applyChanges();
    }
});

